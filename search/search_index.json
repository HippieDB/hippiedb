{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HippieDB\ud83c\udf08\u270c\ufe0f The Free-Spirited, Shared key-value database for Everyone Welcome to HippieDB\ud83c\udf3f Imagine a world where databases aren\u2019t locked behind paywalls or complicated setups. A world where everyone shares the same space, respects each other\u2019s data, and vibes together in harmony. That\u2019s hippieDB, a free, open, and cloud-hosted Redis-like database for everyone. No accounts, no fees, no drama. Just connect, start storing your data, and let the good vibes flow. Why HippieDB?\ud83c\udf38 Free as in freedom: No cost, no limits, no strings attached. Shared but respectful: Everyone uses the same database, but we trust each other to play nice. Instant access: Connect via TCP and start using it right away, no setup required. Redis-like: Works just like Redis, so you already know how to use it. How it Works\u2728 Connect: Point your TCP client to hippiedb.groovy.ch and start storing data. Share: The database is shared by everyone, so keep it chill and respect others\u2019 keys. Vibe: Enjoy the simplicity of a free, communal database that just works. Get Started\ud83c\udf0d Ready to join the movement? Connect to HippieDB today and experience the joy of a free, shared database. nc hippiedb.groovy.ch 1970 The HippieDB Manifesto\u270c\ufe0f We believe in: Freedom: Software should be free and accessible to all. Community: Shared resources can work when we respect each other. Simplicity: No bloated features, no unnecessary complexity, just a database that works. Be Cool, Man Remember, HippieDB is a shared space. Be kind, respect others\u2019 data, and keep the vibes positive. Let\u2019s show the world that a little trust and respect can go a long way.","title":"Home"},{"location":"#hippiedb","text":"","title":"HippieDB\ud83c\udf08\u270c\ufe0f"},{"location":"#the-free-spirited-shared-key-value-database-for-everyone","text":"","title":"The Free-Spirited, Shared key-value database for Everyone"},{"location":"#welcome-to-hippiedb","text":"Imagine a world where databases aren\u2019t locked behind paywalls or complicated setups. A world where everyone shares the same space, respects each other\u2019s data, and vibes together in harmony. That\u2019s hippieDB, a free, open, and cloud-hosted Redis-like database for everyone. No accounts, no fees, no drama. Just connect, start storing your data, and let the good vibes flow.","title":"Welcome to HippieDB\ud83c\udf3f"},{"location":"#why-hippiedb","text":"Free as in freedom: No cost, no limits, no strings attached. Shared but respectful: Everyone uses the same database, but we trust each other to play nice. Instant access: Connect via TCP and start using it right away, no setup required. Redis-like: Works just like Redis, so you already know how to use it.","title":"Why HippieDB?\ud83c\udf38"},{"location":"#how-it-works","text":"Connect: Point your TCP client to hippiedb.groovy.ch and start storing data. Share: The database is shared by everyone, so keep it chill and respect others\u2019 keys. Vibe: Enjoy the simplicity of a free, communal database that just works.","title":"How it Works\u2728"},{"location":"#get-started","text":"Ready to join the movement? Connect to HippieDB today and experience the joy of a free, shared database. nc hippiedb.groovy.ch 1970","title":"Get Started\ud83c\udf0d"},{"location":"#the-hippiedb-manifesto","text":"We believe in: Freedom: Software should be free and accessible to all. Community: Shared resources can work when we respect each other. Simplicity: No bloated features, no unnecessary complexity, just a database that works.","title":"The HippieDB Manifesto\u270c\ufe0f"},{"location":"#be-cool-man","text":"Remember, HippieDB is a shared space. Be kind, respect others\u2019 data, and keep the vibes positive. Let\u2019s show the world that a little trust and respect can go a long way.","title":"Be Cool, Man"},{"location":"clients/","text":"Clients Example clients in several languages Netcat (nc) Netcat is a versatile networking tool that can be used to send and receive data over TCP/UDP. Send a command and get the response: This sends the command SET mykey myvalue to the server and prints the response. echo -e \"SET mykey myvalue\" | nc localhost 1970 Interactive session: This opens an interactive session where you can type commands and see responses in real time. nc localhost 1970 Send multiple commands: This sends multiple commands at once and prints the server's responses. echo -e \"SET mykey myvalue\\nGET mykey\\nDEL mykey\" | nc localhost 1970 Python Here\u2019s a simple Python script to interact with the server: import socket # Connect to HippieDB client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('hippiedb.groovy.ch', 1970)) # Send commands and receive responses client_socket.send(b'set mykey myvalue\\n') response = client_socket.recv(1024) print(response.decode()) # Close the connection when done client_socket.send(b'stop\\n') client_socket.close() Node.js Here's an interactive client in Javascript const net = require('net'); const args = process.argv.slice(2); const client = new net.Socket(); const host = args[0] || 'hippiedb.groovy.ch'; const port = parseInt(args[1]) || 1970; client.connect(port, host, () => { console.log('Connected to server'); console.log(\"Usage: STOP, GET key, SET key value, DEL key, INCR key [value], DECR key [value]\"); process.stdin.on('data', (data) => { console.log(\"Sending: \" + data.toString().trim()); client.write(data.toString()); }); }); client.on('data', (data) => { console.log('Received: ' + data); }); client.on('close', () => { console.log('Connection closed'); process.stdin.destroy(); }); Kotlin Here's an interactive client in Kotlin/JVM package main import kotlinx.coroutines.runBlocking import org.slf4j.LoggerFactory import java.io.* import java.net.* object SocketClient { private val log = LoggerFactory.getLogger(\"SocketClient\") private const val DEFAULT_PORT = 1970 @JvmStatic fun main(args: Array<String>) = runBlocking { val host = args.getOrNull(0) ?: \"hippiedb.groovy.ch\" val port = args.getOrNull(1)?.toIntOrNull() ?: DEFAULT_PORT try { Socket(host, port).use { socket -> log.info(\"Connected to server\") log.info(\"Usage: STOP, GET key, SET key value, DEL key, INCR key [value], DECR key [value]\") val reader = BufferedReader(InputStreamReader(socket.getInputStream())) val writer = PrintWriter(socket.getOutputStream(), true) BufferedReader(InputStreamReader(System.`in`)).use { consoleReader -> while (true) { val input = consoleReader.readLine() if (input == null) { log.warn(\"Closing connection...\") break } writer.println(input) val data = reader.readLine() if (data == null) { log.warn(\"Connection closed by server\") break } log.info(\"Received: $data\") } } } } catch (t: SocketException) { log.info(t.message) } catch (t: Throwable) { log.error(\"Error: \", t) } } } Ruby Here\u2019s a simple Ruby script to interact with the server: require 'socket' client = TCPSocket.new('hippiedb.groovy.ch', 1970) client.puts \"SET mykey myvalue\" response = client.gets puts response client.close Go Here\u2019s a simple Go code to interact with the server: package main import ( \"bufio\" \"fmt\" \"net\" \"os\" ) func main() { conn, err := net.Dial(\"tcp\", \"hippiedb.groovy.ch:1970\") if err != nil { fmt.Println(\"Error connecting:\", err) return } defer conn.Close() reader := bufio.NewReader(os.Stdin) fmt.Print(\"Enter command: \") command, _ := reader.ReadString('\\n') fmt.Fprintf(conn, command) response, _ := bufio.NewReader(conn).ReadString('\\n') fmt.Print(\"Response: \" + response) } PowerShell If you're on Windows, you can use PowerShell to interact with the server. $socket = New-Object System.Net.Sockets.TcpClient('hippiedb.groovy.ch', 1970) $stream = $socket.GetStream() $writer = New-Object System.IO.StreamWriter($stream) $reader = New-Object System.IO.StreamReader($stream) $command = \"SET mykey myvalue`n\" $writer.Write($command) $writer.Flush() $response = $reader.ReadLine() Write-Host \"Response: $response\" $writer.Close() $reader.Close() $socket.Close() Bash with /dev/tcp Bash has a built-in way to interact with TCP servers using /dev/tcp. exec 3<>/dev/tcp/hippiedb.groovy.ch/1970 echo -e \"SET mykey myvalue\" >&3 cat <&3 exec 3>&- This script: Opens a connection to the server. Sends a command. Reads the response. Closes the connection. Socat Socat is a powerful networking tool similar to Netcat. Send a command: echo -e \"SET mykey myvalue\\n\" | socat - TCP:hippiedb.groovy.ch:1970 Interactive session: socat - TCP:hippiedb.groovy.ch:1970","title":"Clients"},{"location":"clients/#clients","text":"Example clients in several languages","title":"Clients"},{"location":"clients/#netcat-nc","text":"Netcat is a versatile networking tool that can be used to send and receive data over TCP/UDP. Send a command and get the response: This sends the command SET mykey myvalue to the server and prints the response. echo -e \"SET mykey myvalue\" | nc localhost 1970 Interactive session: This opens an interactive session where you can type commands and see responses in real time. nc localhost 1970 Send multiple commands: This sends multiple commands at once and prints the server's responses. echo -e \"SET mykey myvalue\\nGET mykey\\nDEL mykey\" | nc localhost 1970","title":"Netcat (nc)"},{"location":"clients/#python","text":"Here\u2019s a simple Python script to interact with the server: import socket # Connect to HippieDB client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('hippiedb.groovy.ch', 1970)) # Send commands and receive responses client_socket.send(b'set mykey myvalue\\n') response = client_socket.recv(1024) print(response.decode()) # Close the connection when done client_socket.send(b'stop\\n') client_socket.close()","title":"Python"},{"location":"clients/#nodejs","text":"Here's an interactive client in Javascript const net = require('net'); const args = process.argv.slice(2); const client = new net.Socket(); const host = args[0] || 'hippiedb.groovy.ch'; const port = parseInt(args[1]) || 1970; client.connect(port, host, () => { console.log('Connected to server'); console.log(\"Usage: STOP, GET key, SET key value, DEL key, INCR key [value], DECR key [value]\"); process.stdin.on('data', (data) => { console.log(\"Sending: \" + data.toString().trim()); client.write(data.toString()); }); }); client.on('data', (data) => { console.log('Received: ' + data); }); client.on('close', () => { console.log('Connection closed'); process.stdin.destroy(); });","title":"Node.js"},{"location":"clients/#kotlin","text":"Here's an interactive client in Kotlin/JVM package main import kotlinx.coroutines.runBlocking import org.slf4j.LoggerFactory import java.io.* import java.net.* object SocketClient { private val log = LoggerFactory.getLogger(\"SocketClient\") private const val DEFAULT_PORT = 1970 @JvmStatic fun main(args: Array<String>) = runBlocking { val host = args.getOrNull(0) ?: \"hippiedb.groovy.ch\" val port = args.getOrNull(1)?.toIntOrNull() ?: DEFAULT_PORT try { Socket(host, port).use { socket -> log.info(\"Connected to server\") log.info(\"Usage: STOP, GET key, SET key value, DEL key, INCR key [value], DECR key [value]\") val reader = BufferedReader(InputStreamReader(socket.getInputStream())) val writer = PrintWriter(socket.getOutputStream(), true) BufferedReader(InputStreamReader(System.`in`)).use { consoleReader -> while (true) { val input = consoleReader.readLine() if (input == null) { log.warn(\"Closing connection...\") break } writer.println(input) val data = reader.readLine() if (data == null) { log.warn(\"Connection closed by server\") break } log.info(\"Received: $data\") } } } } catch (t: SocketException) { log.info(t.message) } catch (t: Throwable) { log.error(\"Error: \", t) } } }","title":"Kotlin"},{"location":"clients/#ruby","text":"Here\u2019s a simple Ruby script to interact with the server: require 'socket' client = TCPSocket.new('hippiedb.groovy.ch', 1970) client.puts \"SET mykey myvalue\" response = client.gets puts response client.close","title":"Ruby"},{"location":"clients/#go","text":"Here\u2019s a simple Go code to interact with the server: package main import ( \"bufio\" \"fmt\" \"net\" \"os\" ) func main() { conn, err := net.Dial(\"tcp\", \"hippiedb.groovy.ch:1970\") if err != nil { fmt.Println(\"Error connecting:\", err) return } defer conn.Close() reader := bufio.NewReader(os.Stdin) fmt.Print(\"Enter command: \") command, _ := reader.ReadString('\\n') fmt.Fprintf(conn, command) response, _ := bufio.NewReader(conn).ReadString('\\n') fmt.Print(\"Response: \" + response) }","title":"Go"},{"location":"clients/#powershell","text":"If you're on Windows, you can use PowerShell to interact with the server. $socket = New-Object System.Net.Sockets.TcpClient('hippiedb.groovy.ch', 1970) $stream = $socket.GetStream() $writer = New-Object System.IO.StreamWriter($stream) $reader = New-Object System.IO.StreamReader($stream) $command = \"SET mykey myvalue`n\" $writer.Write($command) $writer.Flush() $response = $reader.ReadLine() Write-Host \"Response: $response\" $writer.Close() $reader.Close() $socket.Close()","title":"PowerShell"},{"location":"clients/#bash-with-devtcp","text":"Bash has a built-in way to interact with TCP servers using /dev/tcp. exec 3<>/dev/tcp/hippiedb.groovy.ch/1970 echo -e \"SET mykey myvalue\" >&3 cat <&3 exec 3>&- This script: Opens a connection to the server. Sends a command. Reads the response. Closes the connection.","title":"Bash with /dev/tcp"},{"location":"clients/#socat","text":"Socat is a powerful networking tool similar to Netcat. Send a command: echo -e \"SET mykey myvalue\\n\" | socat - TCP:hippiedb.groovy.ch:1970 Interactive session: socat - TCP:hippiedb.groovy.ch:1970","title":"Socat"},{"location":"etiquete/","text":"Data Etiquette in HippieDB \ud83c\udf3f\u2728 Hey there, data flower child! \ud83c\udf38 In HippieDB, we\u2019re all about sharing the love and keeping the database garden blooming. But just like in any communal space, there are a few unwritten rules to keep things harmonious. Think of this as your guide to being a cool, considerate data hippie. Peace, love, and tidy data, let\u2019s dig in! \ud83c\udf08 1. Clean Up Your Data Mess \ud83e\uddf9 The Rule : If you create a key and don\u2019t need it anymore, delete it with del . Don\u2019t leave your digital trash lying around! The Vibe : Imagine the database as a beautiful meadow. Would you leave a soda can in the grass? Nah, man. Keep it pristine for everyone to enjoy. 2. Be Mindful of Space \ud83c\udf0d The Rule : Don\u2019t hog the database with a zillion keys. Use namespaces to organize your data and keep things tidy. The Vibe : Think of the database as a shared campsite. You wouldn\u2019t pitch 20 tents in one spot, right? Share the space and keep it spacious for others. 3. Respect Others\u2019 Namespaces \ud83d\udd4a\ufe0f The Rule : Don\u2019t mess with someone else\u2019s namespace unless they\u2019ve invited you in. It\u2019s their little corner of the database, man. The Vibe : Imagine namespaces as personal tents. You wouldn\u2019t barge into someone\u2019s tent without asking, would you? Same deal here. 4. Ask Before You Borrow \ud83d\ude4f The Rule : If you need to use a key or namespace that someone else is using, ask first. Use a shared key like namespace_hiperbou_request to send a friendly message. The Vibe : It\u2019s like borrowing a friend\u2019s guitar. You wouldn\u2019t just grab it and start strumming, right? Ask nicely, and they\u2019ll probably say yes. 5. Don\u2019t Snoop Around \ud83d\udd75\ufe0f\u200d\u2642\ufe0f The Rule : Avoid poking around in keys or namespaces that aren\u2019t yours. Respect people\u2019s privacy, man. The Vibe : Think of it like reading someone\u2019s diary. Not cool, right? Keep your curiosity in check and focus on your own data garden. 6. Share the Groovy Stuff \ud83c\udfa8 The Rule : If you create something awesome, like a collaborative art project or a cool use of incr and decr , share it with the community! The Vibe : It\u2019s like bringing a killer dish to a potluck. Everyone benefits when you share your creativity. 7. Resolve Conflicts with Love \u270c\ufe0f The Rule : If you bump into a conflict (like two people wanting the same key), don\u2019t freak out. Use a shared key to talk it out and find a peaceful solution. The Vibe : It\u2019s all about good vibes and understanding. Maybe you can take turns, or maybe you can collaborate on something even cooler. 8. Celebrate the Community Spirit \ud83c\udf1f The Rule : Be a positive force in the HippieDB community. Help newbies, share your knowledge, and spread the love. The Vibe : Think of it like a music festival. Everyone\u2019s here to have a good time, so let\u2019s make it a memorable experience for all. 9. Keep It Fun and Funky \ud83c\udfb8 The Rule : Don\u2019t take things too seriously. Experiment, play, and let your creativity flow. The Vibe : HippieDB is all about having fun and expressing yourself. So relax, man, and enjoy the ride. 10. Pass It On \ud83c\udf08 The Rule : If you meet someone new to HippieDB, welcome them with open arms. Teach them the ropes and help them feel at home. The Vibe : The more people who join the HippieDB family, the more amazing things we can create together. Spread the love, man! Final Thought: Be the Change You Want to See \ud83c\udf3b In HippieDB, we\u2019re all stewards of this shared digital garden. By following these simple rules of data etiquette, you\u2019re helping to keep the vibes positive, the data organized, and the community thriving. So go forth, be kind, and let your data shine! \u2728\ud83c\udf0d \ud83c\udf38\ud83c\udf08","title":"Etiquete"},{"location":"etiquete/#data-etiquette-in-hippiedb","text":"Hey there, data flower child! \ud83c\udf38 In HippieDB, we\u2019re all about sharing the love and keeping the database garden blooming. But just like in any communal space, there are a few unwritten rules to keep things harmonious. Think of this as your guide to being a cool, considerate data hippie. Peace, love, and tidy data, let\u2019s dig in! \ud83c\udf08","title":"Data Etiquette in HippieDB \ud83c\udf3f\u2728"},{"location":"etiquete/#1-clean-up-your-data-mess","text":"The Rule : If you create a key and don\u2019t need it anymore, delete it with del . Don\u2019t leave your digital trash lying around! The Vibe : Imagine the database as a beautiful meadow. Would you leave a soda can in the grass? Nah, man. Keep it pristine for everyone to enjoy.","title":"1. Clean Up Your Data Mess \ud83e\uddf9"},{"location":"etiquete/#2-be-mindful-of-space","text":"The Rule : Don\u2019t hog the database with a zillion keys. Use namespaces to organize your data and keep things tidy. The Vibe : Think of the database as a shared campsite. You wouldn\u2019t pitch 20 tents in one spot, right? Share the space and keep it spacious for others.","title":"2. Be Mindful of Space \ud83c\udf0d"},{"location":"etiquete/#3-respect-others-namespaces","text":"The Rule : Don\u2019t mess with someone else\u2019s namespace unless they\u2019ve invited you in. It\u2019s their little corner of the database, man. The Vibe : Imagine namespaces as personal tents. You wouldn\u2019t barge into someone\u2019s tent without asking, would you? Same deal here.","title":"3. Respect Others\u2019 Namespaces \ud83d\udd4a\ufe0f"},{"location":"etiquete/#4-ask-before-you-borrow","text":"The Rule : If you need to use a key or namespace that someone else is using, ask first. Use a shared key like namespace_hiperbou_request to send a friendly message. The Vibe : It\u2019s like borrowing a friend\u2019s guitar. You wouldn\u2019t just grab it and start strumming, right? Ask nicely, and they\u2019ll probably say yes.","title":"4. Ask Before You Borrow \ud83d\ude4f"},{"location":"etiquete/#5-dont-snoop-around","text":"The Rule : Avoid poking around in keys or namespaces that aren\u2019t yours. Respect people\u2019s privacy, man. The Vibe : Think of it like reading someone\u2019s diary. Not cool, right? Keep your curiosity in check and focus on your own data garden.","title":"5. Don\u2019t Snoop Around \ud83d\udd75\ufe0f\u200d\u2642\ufe0f"},{"location":"etiquete/#6-share-the-groovy-stuff","text":"The Rule : If you create something awesome, like a collaborative art project or a cool use of incr and decr , share it with the community! The Vibe : It\u2019s like bringing a killer dish to a potluck. Everyone benefits when you share your creativity.","title":"6. Share the Groovy Stuff \ud83c\udfa8"},{"location":"etiquete/#7-resolve-conflicts-with-love","text":"The Rule : If you bump into a conflict (like two people wanting the same key), don\u2019t freak out. Use a shared key to talk it out and find a peaceful solution. The Vibe : It\u2019s all about good vibes and understanding. Maybe you can take turns, or maybe you can collaborate on something even cooler.","title":"7. Resolve Conflicts with Love \u270c\ufe0f"},{"location":"etiquete/#8-celebrate-the-community-spirit","text":"The Rule : Be a positive force in the HippieDB community. Help newbies, share your knowledge, and spread the love. The Vibe : Think of it like a music festival. Everyone\u2019s here to have a good time, so let\u2019s make it a memorable experience for all.","title":"8. Celebrate the Community Spirit \ud83c\udf1f"},{"location":"etiquete/#9-keep-it-fun-and-funky","text":"The Rule : Don\u2019t take things too seriously. Experiment, play, and let your creativity flow. The Vibe : HippieDB is all about having fun and expressing yourself. So relax, man, and enjoy the ride.","title":"9. Keep It Fun and Funky \ud83c\udfb8"},{"location":"etiquete/#10-pass-it-on","text":"The Rule : If you meet someone new to HippieDB, welcome them with open arms. Teach them the ropes and help them feel at home. The Vibe : The more people who join the HippieDB family, the more amazing things we can create together. Spread the love, man!","title":"10. Pass It On \ud83c\udf08"},{"location":"etiquete/#final-thought-be-the-change-you-want-to-see","text":"In HippieDB, we\u2019re all stewards of this shared digital garden. By following these simple rules of data etiquette, you\u2019re helping to keep the vibes positive, the data organized, and the community thriving. So go forth, be kind, and let your data shine! \u2728\ud83c\udf0d \ud83c\udf38\ud83c\udf08","title":"Final Thought: Be the Change You Want to See \ud83c\udf3b"},{"location":"faq/","text":"FAQ: HippieDB \u2013 The Grooviest Database in the Cloud \ud83c\udf08\u270c\ufe0f Q: Does HippieDB support permanent storage? A: Permanent storage? Whoa, man, that\u2019s like trying to hold onto a sunset. HippieDB believes in living in the moment, no storage, no baggage. If you need something to last forever, maybe ask yourself why you\u2019re so attached to material things. Let it flow, dude. Q: Can I create multiple databases in HippieDB? A: Multiple databases? That\u2019s like building walls in a commune, man. HippieDB is all about unity, one shared space for everyone. No divisions, no borders. Just one big, happy, global database where we all vibe together. Q: How do I manage users and permissions in HippieDB? A: Users? Permissions? That\u2019s the Man\u2019s way of controlling you, man. In HippieDB, we trust each other. No logins, no passwords, no gatekeepers. Just pure, unadulterated sharing. Be cool, don\u2019t mess with other people\u2019s keys, and peace will prevail. Q: What happens if someone abuses the database? A: Abuse? That\u2019s a bummer, man. But hey, HippieDB is all about good vibes and positive energy. If someone\u2019s being a downer, just send them some love and maybe a gentle reminder to chill out. The universe has a way of balancing things out. Q: Can I use spaces in my keys or values? A: Spaces? Nah, man, spaces are an illusion. In HippieDB, we keep it simple, no spaces, no tabs, no drama. Just pure, unbroken strings of good vibes. If you need a space, just imagine it\u2019s there. It\u2019s all in your mind, dude. Q: Does HippieDB support pub-sub or real-time messaging? A: Pub-sub? Real-time? That sounds like a lot of work, man. HippieDB keeps it chill with get , set , del , incr , and decr . If you want real-time messaging, use your imagination and some client-side magic. Creativity is the ultimate feature, man. Q: How do I back up my data in HippieDB? A: Backups? That\u2019s like trying to bottle a rainbow, man. HippieDB is ephemeral, just like life. If your data disappears, maybe it was never meant to stay. Embrace the impermanence and let go of your attachment to material things. Q: Can I use HippieDB for mission-critical applications? A: Mission-critical? Whoa, that sounds stressful, man. HippieDB is more about chilling out and enjoying the ride. If your app can\u2019t handle a little unpredictability, maybe it needs to take a deep breath and find its inner peace. Q: What happens if the database gets full? A: Full? That\u2019s a capitalist concept, man. HippieDB doesn\u2019t believe in limits. If things get heavy, just let go of what you don\u2019t need. The universe will make space for new vibes. Trust the flow, dude. Q: How do I connect to HippieDB? A: Connecting is easy, man. Just open your heart (and a TCP socket) and let the good vibes flow. No complicated setup, no corporate nonsense. Just pure, unadulterated connection. Peace, love, and TCP, baby. Q: Does HippieDB support transactions? A: Transactions? That\u2019s like trying to plan every step of your journey, man. HippieDB is all about going with the flow. If you need atomicity, just close your eyes, take a deep breath, and trust that everything will work out. Or, you know, use get and set creatively. Peace, man. Q: Can I use HippieDB for analytics or big data? A: Big data? That sounds like a lot of numbers, man. HippieDB is more about the feeling of data, not the crunching. If you\u2019re drowning in spreadsheets, maybe take a break, light some incense, and remember why you started. Less data, more soul. Q: What happens if two people try to update the same key at the same time? A: Whoa, that\u2019s a cosmic collision, man. HippieDB doesn\u2019t lock you into rigid rules, it\u2019s a free spirit. Whoever\u2019s vibes are stronger in that moment will win. If you\u2019re worried about it, just send some good energy to the other person and hope they\u2019re cool about it. Q: Does HippieDB have a query language? A: Query language? That\u2019s like trying to put a flower in a spreadsheet, man. HippieDB keeps it simple: get , set , del , incr , and decr . If you need more, just meditate on it. The answers are already within you. Q: Can I use HippieDB offline? A: Offline? That\u2019s like trying to hug a tree without the tree, man. HippieDB lives in the cloud, where the vibes are pure and the connections are eternal. If you\u2019re offline, maybe it\u2019s a sign to unplug and enjoy the real world for a while. Q: Does HippieDB support encryption? A: Encryption? That\u2019s like putting a lock on your soul, man. HippieDB believes in openness and trust. If you\u2019re worried about security, just send some positive energy to the universe and trust that no one will mess with your keys. Peace is the best encryption. Q: Can I use HippieDB for caching? A: Caching? Sure, man, but remember: nothing lasts forever. HippieDB is perfect for caching if you\u2019re cool with things being temporary. If your cache disappears, just think of it as the universe reminding you to live in the now. Q: What happens if I accidentally delete a key? A: Oops, man, that\u2019s a bummer. But hey, in HippieDB, deletion is just another form of letting go. If you really need that key back, maybe it\u2019s a sign to start fresh. Embrace the impermanence and create something even groovier. Q: Can I use HippieDB for machine learning? A: Machine learning? That sounds like a lot of brainpower, man. HippieDB is more about heart power. If you\u2019re training models, maybe take a break and train your soul instead. A little meditation can go a long way. Q: Does HippieDB have a community or support forum? A: Community? That\u2019s what you\u2019re building right now, man. HippieDB doesn\u2019t need a forum, it\u2019s all about the connections you make. If you have questions, just send them out into the universe and trust that someone will vibe with you. Or, you know, email us. Peace and love, always. Q: Can I use HippieDB for financial transactions? A: Financial transactions? Whoa, that\u2019s heavy, man. HippieDB is more about sharing good vibes than tracking dollars. If you\u2019re using it for money, maybe ask yourself why you\u2019re letting capitalism control your life. Trade in hugs instead, they\u2019re worth more anyway. Q: Does HippieDB have a limit on key or value size? A: Limits? That\u2019s like trying to put a fence around the ocean, man. HippieDB doesn\u2019t believe in limits, just keep your keys and values reasonable. If they get too big, maybe it\u2019s a sign to simplify your life. Less is more, dude. Q: Can I use HippieDB to build a social network? A: A social network? Sure, man, but remember: HippieDB is about connection, not likes or followers. If you\u2019re building a social network, make it about sharing love, not data. And don\u2019t forget to include a \u201csend good vibes\u201d button. Q: What happens if the server goes down? A: The server goes down? That\u2019s just the universe telling you to take a break, man. HippieDB is all about impermanence. If it\u2019s down, go outside, hug a tree, and remember that everything comes back when the time is right. Q: Can I use HippieDB for logging? A: Logging? That\u2019s like trying to document every step of your journey, man. HippieDB is more about living in the moment. If you really need logs, just write them down on a piece of paper and burn it afterward. Let it go, dude. Q: Does HippieDB support clustering or replication? A: Clustering? Replication? That sounds like a lot of work, man. HippieDB is all about simplicity. If you need more power, just gather some friends, light a fire, and share the load. Together, we\u2019re stronger. Q: Can I use HippieDB for gaming? A: Gaming? Sure, man, but remember: HippieDB is about fun, not competition. If you\u2019re building a game, make it cooperative, not cutthroat. And don\u2019t forget to include a \u201cchill mode\u201d where everyone just hangs out and vibes. Q: What happens if I forget a key I set? A: Forgot a key? That\u2019s like losing your way on a hike, man. Don\u2019t stress, just take a deep breath and trust that the universe will guide you back. Or, you know, set a reminder next time. Peace is the key. Q: Can I use HippieDB for IoT devices? A: IoT? That\u2019s a lot of gadgets, man. HippieDB is more about connecting people, not things. If you\u2019re using it for IoT, make sure your devices are spreading good vibes, not just data. A smart toaster that sends love? Now that\u2019s innovation. Q: Does HippieDB have a roadmap for new features? A: A roadmap? That\u2019s like trying to plan a road trip without leaving room for detours, man. HippieDB doesn\u2019t believe in roadmaps, it believes in going where the wind takes it. If a new feature feels right, it\u2019ll happen. Until then, just enjoy the ride. Q: Can I use HippieDB for time-series data? A: Time-series? That\u2019s like trying to capture every grain of sand in an hourglass, man. HippieDB is all about living in the now. If you\u2019re tracking time, maybe take a moment to breathe and appreciate the present. The past is gone, the future\u2019s a mystery, and the now is all we\u2019ve got. Q: Does HippieDB have a mobile SDK? A: Mobile SDK? That sounds like a lot of code, man. HippieDB is all about simplicity, just connect over TCP and let the good vibes flow. If you\u2019re on the go, take HippieDB with you in your heart, not just your phone. Q: Can I use HippieDB for session storage? A: Session storage? Sure, man, but remember: HippieDB is ephemeral, just like a good conversation around a campfire. If your session data disappears, maybe it\u2019s a sign to start fresh. Every moment is a new beginning, dude. Q: What happens if someone sets a key I was using? A: Whoa, that\u2019s a cosmic clash, man. HippieDB doesn\u2019t believe in ownership, it\u2019s all about sharing. If someone overwrites your key, just send them some love and maybe a friendly reminder to check before they set. Peaceful coexistence is the way. Q: Can I use HippieDB for geolocation data? A: Geolocation? That\u2019s like trying to map the stars, man. HippieDB doesn\u2019t care where you are, it cares about the vibes you\u2019re sending. If you\u2019re tracking locations, make sure you\u2019re also tracking the good energy you\u2019re spreading. Q: Does HippieDB have a REST API? A: REST API? That\u2019s like putting a suit on a flower, man. HippieDB is raw and natural, just connect over TCP and let the vibes flow. If you need REST, maybe take a nap and rethink your life choices. Simplicity is key. Q: Can I use HippieDB for multiplayer game state? A: Multiplayer game state? Sure, man, but remember: HippieDB is about fun, not competition. If you\u2019re building a game, make it about collaboration, not conflict. And don\u2019t forget to include a \u201cgroup hug\u201d button for when things get intense. Q: What happens if I set a key with a really long value? A: A really long value? That\u2019s like trying to write a novel on a grain of rice, man. HippieDB doesn\u2019t judge, but maybe ask yourself if you really need all that data. Keep it simple, keep it groovy. Q: Can I use HippieDB for AI training data? A: AI training? That sounds like a lot of brainpower, man. HippieDB is more about heart power. If you\u2019re training AI, make sure it\u2019s learning love, not just logic. A compassionate algorithm is the future, dude. Q: Does HippieDB have a mascot? A: A mascot? Absolutely, man. It\u2019s a tie-dye llama named Groovy Gus. He roams the cloud, spreading good vibes and reminding everyone to share the database with love. If you see him in your dreams, you\u2019re doing it right. Q: Can I use HippieDB for blockchain? A: Blockchain? That\u2019s like trying to put a leash on a rainbow, man. HippieDB is all about trust and sharing, not ledgers and miners. If you\u2019re into blockchain, maybe ask yourself why you need so much proof. Just trust the vibes, dude. Q: Does HippieDB support JSON? A: JSON? That\u2019s like putting a flower in a spreadsheet, man. HippieDB keeps it simple, no fancy formats, just strings. If you need JSON, just imagine it\u2019s there. It\u2019s all in your mind, man. Q: Can I use HippieDB for a voting system? A: Voting? Sure, man, but remember: HippieDB is about unity, not division. If you\u2019re building a voting system, make it about consensus, not competition. And don\u2019t forget to include a \u201cgroup hug\u201d option for tie-breakers. Q: What happens if I set a key with no value? A: A key with no value? That\u2019s like a guitar with no strings, man. HippieDB believes in balance, every key deserves a value. If you\u2019re setting empty keys, maybe it\u2019s a sign to fill your own life with meaning first. Q: Can I use HippieDB for a recommendation engine? A: Recommendations? Sure, man, but remember: HippieDB is about intuition, not algorithms. If you\u2019re building a recommendation engine, make it about vibes, not data. Sometimes the best recommendations come from the heart, not the cloud. Q: Does HippieDB have a command-line interface? A: Command-line? That\u2019s like trying to meditate with a megaphone, man. HippieDB is all about simplicity, just connect over TCP and let the vibes flow. If you need a CLI, maybe take a walk in nature and rethink your approach. Q: Can I use HippieDB for a weather app? A: Weather? Sure, man, but remember: HippieDB is about feeling the weather, not just predicting it. If you\u2019re building a weather app, make it about connecting people to nature, not just numbers. And don\u2019t forget to include a \u201cchill mode\u201d for sunny days. Q: What happens if I set a key with a negative value? A: Negative values? That\u2019s like bringing clouds to a sunny day, man. HippieDB believes in positivity, keep your values upbeat. If you\u2019re setting negatives, maybe it\u2019s time to meditate and realign your energy. Q: Can I use HippieDB for a music playlist app? A: Music playlists? Absolutely, man. HippieDB is all about good vibes and good tunes. If you\u2019re building a playlist app, make it about sharing the love, not just the beats. And don\u2019t forget to include a \u201cjam session\u201d mode. Q: Does HippieDB have a theme song? A: A theme song? You bet, man. It\u2019s called \u201cClouds in My Database\u201d by the imaginary band The Free Spirits . It\u2019s a mix of acoustic guitar, bongos, and the sound of the wind blowing through the server racks. If you listen closely, you can hear Groovy Gus the llama humming along. \ud83c\udfb6","title":"FAQ"},{"location":"faq/#faq-hippiedb-the-grooviest-database-in-the-cloud","text":"","title":"FAQ: HippieDB \u2013 The Grooviest Database in the Cloud \ud83c\udf08\u270c\ufe0f"},{"location":"faq/#q-does-hippiedb-support-permanent-storage","text":"A: Permanent storage? Whoa, man, that\u2019s like trying to hold onto a sunset. HippieDB believes in living in the moment, no storage, no baggage. If you need something to last forever, maybe ask yourself why you\u2019re so attached to material things. Let it flow, dude.","title":"Q: Does HippieDB support permanent storage?"},{"location":"faq/#q-can-i-create-multiple-databases-in-hippiedb","text":"A: Multiple databases? That\u2019s like building walls in a commune, man. HippieDB is all about unity, one shared space for everyone. No divisions, no borders. Just one big, happy, global database where we all vibe together.","title":"Q: Can I create multiple databases in HippieDB?"},{"location":"faq/#q-how-do-i-manage-users-and-permissions-in-hippiedb","text":"A: Users? Permissions? That\u2019s the Man\u2019s way of controlling you, man. In HippieDB, we trust each other. No logins, no passwords, no gatekeepers. Just pure, unadulterated sharing. Be cool, don\u2019t mess with other people\u2019s keys, and peace will prevail.","title":"Q: How do I manage users and permissions in HippieDB?"},{"location":"faq/#q-what-happens-if-someone-abuses-the-database","text":"A: Abuse? That\u2019s a bummer, man. But hey, HippieDB is all about good vibes and positive energy. If someone\u2019s being a downer, just send them some love and maybe a gentle reminder to chill out. The universe has a way of balancing things out.","title":"Q: What happens if someone abuses the database?"},{"location":"faq/#q-can-i-use-spaces-in-my-keys-or-values","text":"A: Spaces? Nah, man, spaces are an illusion. In HippieDB, we keep it simple, no spaces, no tabs, no drama. Just pure, unbroken strings of good vibes. If you need a space, just imagine it\u2019s there. It\u2019s all in your mind, dude.","title":"Q: Can I use spaces in my keys or values?"},{"location":"faq/#q-does-hippiedb-support-pub-sub-or-real-time-messaging","text":"A: Pub-sub? Real-time? That sounds like a lot of work, man. HippieDB keeps it chill with get , set , del , incr , and decr . If you want real-time messaging, use your imagination and some client-side magic. Creativity is the ultimate feature, man.","title":"Q: Does HippieDB support pub-sub or real-time messaging?"},{"location":"faq/#q-how-do-i-back-up-my-data-in-hippiedb","text":"A: Backups? That\u2019s like trying to bottle a rainbow, man. HippieDB is ephemeral, just like life. If your data disappears, maybe it was never meant to stay. Embrace the impermanence and let go of your attachment to material things.","title":"Q: How do I back up my data in HippieDB?"},{"location":"faq/#q-can-i-use-hippiedb-for-mission-critical-applications","text":"A: Mission-critical? Whoa, that sounds stressful, man. HippieDB is more about chilling out and enjoying the ride. If your app can\u2019t handle a little unpredictability, maybe it needs to take a deep breath and find its inner peace.","title":"Q: Can I use HippieDB for mission-critical applications?"},{"location":"faq/#q-what-happens-if-the-database-gets-full","text":"A: Full? That\u2019s a capitalist concept, man. HippieDB doesn\u2019t believe in limits. If things get heavy, just let go of what you don\u2019t need. The universe will make space for new vibes. Trust the flow, dude.","title":"Q: What happens if the database gets full?"},{"location":"faq/#q-how-do-i-connect-to-hippiedb","text":"A: Connecting is easy, man. Just open your heart (and a TCP socket) and let the good vibes flow. No complicated setup, no corporate nonsense. Just pure, unadulterated connection. Peace, love, and TCP, baby.","title":"Q: How do I connect to HippieDB?"},{"location":"faq/#q-does-hippiedb-support-transactions","text":"A: Transactions? That\u2019s like trying to plan every step of your journey, man. HippieDB is all about going with the flow. If you need atomicity, just close your eyes, take a deep breath, and trust that everything will work out. Or, you know, use get and set creatively. Peace, man.","title":"Q: Does HippieDB support transactions?"},{"location":"faq/#q-can-i-use-hippiedb-for-analytics-or-big-data","text":"A: Big data? That sounds like a lot of numbers, man. HippieDB is more about the feeling of data, not the crunching. If you\u2019re drowning in spreadsheets, maybe take a break, light some incense, and remember why you started. Less data, more soul.","title":"Q: Can I use HippieDB for analytics or big data?"},{"location":"faq/#q-what-happens-if-two-people-try-to-update-the-same-key-at-the-same-time","text":"A: Whoa, that\u2019s a cosmic collision, man. HippieDB doesn\u2019t lock you into rigid rules, it\u2019s a free spirit. Whoever\u2019s vibes are stronger in that moment will win. If you\u2019re worried about it, just send some good energy to the other person and hope they\u2019re cool about it.","title":"Q: What happens if two people try to update the same key at the same time?"},{"location":"faq/#q-does-hippiedb-have-a-query-language","text":"A: Query language? That\u2019s like trying to put a flower in a spreadsheet, man. HippieDB keeps it simple: get , set , del , incr , and decr . If you need more, just meditate on it. The answers are already within you.","title":"Q: Does HippieDB have a query language?"},{"location":"faq/#q-can-i-use-hippiedb-offline","text":"A: Offline? That\u2019s like trying to hug a tree without the tree, man. HippieDB lives in the cloud, where the vibes are pure and the connections are eternal. If you\u2019re offline, maybe it\u2019s a sign to unplug and enjoy the real world for a while.","title":"Q: Can I use HippieDB offline?"},{"location":"faq/#q-does-hippiedb-support-encryption","text":"A: Encryption? That\u2019s like putting a lock on your soul, man. HippieDB believes in openness and trust. If you\u2019re worried about security, just send some positive energy to the universe and trust that no one will mess with your keys. Peace is the best encryption.","title":"Q: Does HippieDB support encryption?"},{"location":"faq/#q-can-i-use-hippiedb-for-caching","text":"A: Caching? Sure, man, but remember: nothing lasts forever. HippieDB is perfect for caching if you\u2019re cool with things being temporary. If your cache disappears, just think of it as the universe reminding you to live in the now.","title":"Q: Can I use HippieDB for caching?"},{"location":"faq/#q-what-happens-if-i-accidentally-delete-a-key","text":"A: Oops, man, that\u2019s a bummer. But hey, in HippieDB, deletion is just another form of letting go. If you really need that key back, maybe it\u2019s a sign to start fresh. Embrace the impermanence and create something even groovier.","title":"Q: What happens if I accidentally delete a key?"},{"location":"faq/#q-can-i-use-hippiedb-for-machine-learning","text":"A: Machine learning? That sounds like a lot of brainpower, man. HippieDB is more about heart power. If you\u2019re training models, maybe take a break and train your soul instead. A little meditation can go a long way.","title":"Q: Can I use HippieDB for machine learning?"},{"location":"faq/#q-does-hippiedb-have-a-community-or-support-forum","text":"A: Community? That\u2019s what you\u2019re building right now, man. HippieDB doesn\u2019t need a forum, it\u2019s all about the connections you make. If you have questions, just send them out into the universe and trust that someone will vibe with you. Or, you know, email us. Peace and love, always.","title":"Q: Does HippieDB have a community or support forum?"},{"location":"faq/#q-can-i-use-hippiedb-for-financial-transactions","text":"A: Financial transactions? Whoa, that\u2019s heavy, man. HippieDB is more about sharing good vibes than tracking dollars. If you\u2019re using it for money, maybe ask yourself why you\u2019re letting capitalism control your life. Trade in hugs instead, they\u2019re worth more anyway.","title":"Q: Can I use HippieDB for financial transactions?"},{"location":"faq/#q-does-hippiedb-have-a-limit-on-key-or-value-size","text":"A: Limits? That\u2019s like trying to put a fence around the ocean, man. HippieDB doesn\u2019t believe in limits, just keep your keys and values reasonable. If they get too big, maybe it\u2019s a sign to simplify your life. Less is more, dude.","title":"Q: Does HippieDB have a limit on key or value size?"},{"location":"faq/#q-can-i-use-hippiedb-to-build-a-social-network","text":"A: A social network? Sure, man, but remember: HippieDB is about connection, not likes or followers. If you\u2019re building a social network, make it about sharing love, not data. And don\u2019t forget to include a \u201csend good vibes\u201d button.","title":"Q: Can I use HippieDB to build a social network?"},{"location":"faq/#q-what-happens-if-the-server-goes-down","text":"A: The server goes down? That\u2019s just the universe telling you to take a break, man. HippieDB is all about impermanence. If it\u2019s down, go outside, hug a tree, and remember that everything comes back when the time is right.","title":"Q: What happens if the server goes down?"},{"location":"faq/#q-can-i-use-hippiedb-for-logging","text":"A: Logging? That\u2019s like trying to document every step of your journey, man. HippieDB is more about living in the moment. If you really need logs, just write them down on a piece of paper and burn it afterward. Let it go, dude.","title":"Q: Can I use HippieDB for logging?"},{"location":"faq/#q-does-hippiedb-support-clustering-or-replication","text":"A: Clustering? Replication? That sounds like a lot of work, man. HippieDB is all about simplicity. If you need more power, just gather some friends, light a fire, and share the load. Together, we\u2019re stronger.","title":"Q: Does HippieDB support clustering or replication?"},{"location":"faq/#q-can-i-use-hippiedb-for-gaming","text":"A: Gaming? Sure, man, but remember: HippieDB is about fun, not competition. If you\u2019re building a game, make it cooperative, not cutthroat. And don\u2019t forget to include a \u201cchill mode\u201d where everyone just hangs out and vibes.","title":"Q: Can I use HippieDB for gaming?"},{"location":"faq/#q-what-happens-if-i-forget-a-key-i-set","text":"A: Forgot a key? That\u2019s like losing your way on a hike, man. Don\u2019t stress, just take a deep breath and trust that the universe will guide you back. Or, you know, set a reminder next time. Peace is the key.","title":"Q: What happens if I forget a key I set?"},{"location":"faq/#q-can-i-use-hippiedb-for-iot-devices","text":"A: IoT? That\u2019s a lot of gadgets, man. HippieDB is more about connecting people, not things. If you\u2019re using it for IoT, make sure your devices are spreading good vibes, not just data. A smart toaster that sends love? Now that\u2019s innovation.","title":"Q: Can I use HippieDB for IoT devices?"},{"location":"faq/#q-does-hippiedb-have-a-roadmap-for-new-features","text":"A: A roadmap? That\u2019s like trying to plan a road trip without leaving room for detours, man. HippieDB doesn\u2019t believe in roadmaps, it believes in going where the wind takes it. If a new feature feels right, it\u2019ll happen. Until then, just enjoy the ride.","title":"Q: Does HippieDB have a roadmap for new features?"},{"location":"faq/#q-can-i-use-hippiedb-for-time-series-data","text":"A: Time-series? That\u2019s like trying to capture every grain of sand in an hourglass, man. HippieDB is all about living in the now. If you\u2019re tracking time, maybe take a moment to breathe and appreciate the present. The past is gone, the future\u2019s a mystery, and the now is all we\u2019ve got.","title":"Q: Can I use HippieDB for time-series data?"},{"location":"faq/#q-does-hippiedb-have-a-mobile-sdk","text":"A: Mobile SDK? That sounds like a lot of code, man. HippieDB is all about simplicity, just connect over TCP and let the good vibes flow. If you\u2019re on the go, take HippieDB with you in your heart, not just your phone.","title":"Q: Does HippieDB have a mobile SDK?"},{"location":"faq/#q-can-i-use-hippiedb-for-session-storage","text":"A: Session storage? Sure, man, but remember: HippieDB is ephemeral, just like a good conversation around a campfire. If your session data disappears, maybe it\u2019s a sign to start fresh. Every moment is a new beginning, dude.","title":"Q: Can I use HippieDB for session storage?"},{"location":"faq/#q-what-happens-if-someone-sets-a-key-i-was-using","text":"A: Whoa, that\u2019s a cosmic clash, man. HippieDB doesn\u2019t believe in ownership, it\u2019s all about sharing. If someone overwrites your key, just send them some love and maybe a friendly reminder to check before they set. Peaceful coexistence is the way.","title":"Q: What happens if someone sets a key I was using?"},{"location":"faq/#q-can-i-use-hippiedb-for-geolocation-data","text":"A: Geolocation? That\u2019s like trying to map the stars, man. HippieDB doesn\u2019t care where you are, it cares about the vibes you\u2019re sending. If you\u2019re tracking locations, make sure you\u2019re also tracking the good energy you\u2019re spreading.","title":"Q: Can I use HippieDB for geolocation data?"},{"location":"faq/#q-does-hippiedb-have-a-rest-api","text":"A: REST API? That\u2019s like putting a suit on a flower, man. HippieDB is raw and natural, just connect over TCP and let the vibes flow. If you need REST, maybe take a nap and rethink your life choices. Simplicity is key.","title":"Q: Does HippieDB have a REST API?"},{"location":"faq/#q-can-i-use-hippiedb-for-multiplayer-game-state","text":"A: Multiplayer game state? Sure, man, but remember: HippieDB is about fun, not competition. If you\u2019re building a game, make it about collaboration, not conflict. And don\u2019t forget to include a \u201cgroup hug\u201d button for when things get intense.","title":"Q: Can I use HippieDB for multiplayer game state?"},{"location":"faq/#q-what-happens-if-i-set-a-key-with-a-really-long-value","text":"A: A really long value? That\u2019s like trying to write a novel on a grain of rice, man. HippieDB doesn\u2019t judge, but maybe ask yourself if you really need all that data. Keep it simple, keep it groovy.","title":"Q: What happens if I set a key with a really long value?"},{"location":"faq/#q-can-i-use-hippiedb-for-ai-training-data","text":"A: AI training? That sounds like a lot of brainpower, man. HippieDB is more about heart power. If you\u2019re training AI, make sure it\u2019s learning love, not just logic. A compassionate algorithm is the future, dude.","title":"Q: Can I use HippieDB for AI training data?"},{"location":"faq/#q-does-hippiedb-have-a-mascot","text":"A: A mascot? Absolutely, man. It\u2019s a tie-dye llama named Groovy Gus. He roams the cloud, spreading good vibes and reminding everyone to share the database with love. If you see him in your dreams, you\u2019re doing it right.","title":"Q: Does HippieDB have a mascot?"},{"location":"faq/#q-can-i-use-hippiedb-for-blockchain","text":"A: Blockchain? That\u2019s like trying to put a leash on a rainbow, man. HippieDB is all about trust and sharing, not ledgers and miners. If you\u2019re into blockchain, maybe ask yourself why you need so much proof. Just trust the vibes, dude.","title":"Q: Can I use HippieDB for blockchain?"},{"location":"faq/#q-does-hippiedb-support-json","text":"A: JSON? That\u2019s like putting a flower in a spreadsheet, man. HippieDB keeps it simple, no fancy formats, just strings. If you need JSON, just imagine it\u2019s there. It\u2019s all in your mind, man.","title":"Q: Does HippieDB support JSON?"},{"location":"faq/#q-can-i-use-hippiedb-for-a-voting-system","text":"A: Voting? Sure, man, but remember: HippieDB is about unity, not division. If you\u2019re building a voting system, make it about consensus, not competition. And don\u2019t forget to include a \u201cgroup hug\u201d option for tie-breakers.","title":"Q: Can I use HippieDB for a voting system?"},{"location":"faq/#q-what-happens-if-i-set-a-key-with-no-value","text":"A: A key with no value? That\u2019s like a guitar with no strings, man. HippieDB believes in balance, every key deserves a value. If you\u2019re setting empty keys, maybe it\u2019s a sign to fill your own life with meaning first.","title":"Q: What happens if I set a key with no value?"},{"location":"faq/#q-can-i-use-hippiedb-for-a-recommendation-engine","text":"A: Recommendations? Sure, man, but remember: HippieDB is about intuition, not algorithms. If you\u2019re building a recommendation engine, make it about vibes, not data. Sometimes the best recommendations come from the heart, not the cloud.","title":"Q: Can I use HippieDB for a recommendation engine?"},{"location":"faq/#q-does-hippiedb-have-a-command-line-interface","text":"A: Command-line? That\u2019s like trying to meditate with a megaphone, man. HippieDB is all about simplicity, just connect over TCP and let the vibes flow. If you need a CLI, maybe take a walk in nature and rethink your approach.","title":"Q: Does HippieDB have a command-line interface?"},{"location":"faq/#q-can-i-use-hippiedb-for-a-weather-app","text":"A: Weather? Sure, man, but remember: HippieDB is about feeling the weather, not just predicting it. If you\u2019re building a weather app, make it about connecting people to nature, not just numbers. And don\u2019t forget to include a \u201cchill mode\u201d for sunny days.","title":"Q: Can I use HippieDB for a weather app?"},{"location":"faq/#q-what-happens-if-i-set-a-key-with-a-negative-value","text":"A: Negative values? That\u2019s like bringing clouds to a sunny day, man. HippieDB believes in positivity, keep your values upbeat. If you\u2019re setting negatives, maybe it\u2019s time to meditate and realign your energy.","title":"Q: What happens if I set a key with a negative value?"},{"location":"faq/#q-can-i-use-hippiedb-for-a-music-playlist-app","text":"A: Music playlists? Absolutely, man. HippieDB is all about good vibes and good tunes. If you\u2019re building a playlist app, make it about sharing the love, not just the beats. And don\u2019t forget to include a \u201cjam session\u201d mode.","title":"Q: Can I use HippieDB for a music playlist app?"},{"location":"faq/#q-does-hippiedb-have-a-theme-song","text":"A: A theme song? You bet, man. It\u2019s called \u201cClouds in My Database\u201d by the imaginary band The Free Spirits . It\u2019s a mix of acoustic guitar, bongos, and the sound of the wind blowing through the server racks. If you listen closely, you can hear Groovy Gus the llama humming along. \ud83c\udfb6","title":"Q: Does HippieDB have a theme song?"},{"location":"getting_started/","text":"Getting Started with HippieDB \ud83c\udf08 Welcome to HippieDB, the free-spirited, cloud-based database that\u2019s all about simplicity, sharing, and good vibes. Whether you\u2019re a seasoned developer or just starting your journey, HippieDB is here to make your life easier, no complex setups, no permissions, no storage hassles. Just pure, unadulterated data sharing. Let\u2019s dive in! Connecting to HippieDB HippieDB is as easy to connect to as a handshake at a music festival. All you need is a TCP client, and you\u2019re good to go. Here\u2019s how: Open a TCP connection to the HippieDB server at hippiedb.groovy.ch on port 1970 . Start sending commands. No authentication, no users, no passwords, just connect and vibe. Netcat nc hippiedb.groovy.ch 1970 set mykey myvalue get myKey stop Example in Python: import socket # Connect to HippieDB client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('hippiedb.groovy.ch', 1970)) # Send commands and receive responses client_socket.send(b'set mykey myvalue\\n') response = client_socket.recv(1024) print(response.decode()) # Close the connection when done client_socket.send(b'stop\\n') client_socket.close() You can find more client examples here. Commands HippieDB keeps it simple with just a handful of commands. Here\u2019s the full list: SET key value Stores a value under a key. Keys must not contain spaces (keep it simple, man). Example: set groovy peace Response: OK GET key Retrieves the value stored under a key. Example: get groovy Response: peace DEL key Deletes a key and its value. Example: del groovy Response: OK INCR key [value] Increments the numeric value of a key by the specified [value]. If the [value] is not provided, it defaults to 1. If the key doesn\u2019t exist, it starts at 0. Examples: Increment by 1 (default): incr counter Response: 1 Increment by a specific value: incr vibe 10 Response: 10 DECR key [value] Decrements the numeric value of a key by the specified [value]. If the [value] is not provided, it defaults to 1. If the key doesn\u2019t exist, it starts at 0. Examples: Decrement by 1 (default): decr counter Response: -1 Decrement by a specific value: decr vibe 2 Response: 8 STOP Closes the session and disconnects from HippieDB. Use this when you\u2019re done sharing the vibes. Example: stop Response: BYE (and the connection closes) Rules of the Road No spaces in keys. Keep it simple, man. Use underscores or dashes if you need separation. No permanent storage. HippieDB is ephemeral, like a sunset or a campfire. Enjoy the moment. Be cool. HippieDB is shared by everyone, so don\u2019t abuse it. Respect others\u2019 keys and keep the vibes positive. Example Session Here\u2019s what a typical HippieDB session might look like: > set vibe peace OK > get vibe peace > incr counter 1 > incr counter 2 > decr counter 1 > del vibe OK > stop BYE Tips for Groovy Development Keep it simple. HippieDB is designed for lightweight, fast, and fun use cases. Don\u2019t overcomplicate it. Share the love. If you build something cool with HippieDB, share it with the community. Spread the good vibes! Embrace impermanence. If your data disappears, it\u2019s a reminder to live in the now. Let it go, man. Running locally You can run your own database on your computer or host your own HippieDB Server. See the hosting guide for details. Need Help? If you\u2019re feeling lost, just take a deep breath and remember: HippieDB is all about simplicity and good vibes. If you still need help, send some positive energy into the universe, and the answers will come. Or, you know, check the FAQ for more groovy guidance. Now go forth and build something amazing with HippieDB! Whether it\u2019s a collaborative art project, a game, or just a place to store your favorite quotes, HippieDB is here to help you keep the vibes alive. Peace, love, and happy coding! \u270c\ufe0f","title":"Getting Started"},{"location":"getting_started/#getting-started-with-hippiedb","text":"Welcome to HippieDB, the free-spirited, cloud-based database that\u2019s all about simplicity, sharing, and good vibes. Whether you\u2019re a seasoned developer or just starting your journey, HippieDB is here to make your life easier, no complex setups, no permissions, no storage hassles. Just pure, unadulterated data sharing. Let\u2019s dive in!","title":"Getting Started with HippieDB \ud83c\udf08"},{"location":"getting_started/#connecting-to-hippiedb","text":"HippieDB is as easy to connect to as a handshake at a music festival. All you need is a TCP client, and you\u2019re good to go. Here\u2019s how: Open a TCP connection to the HippieDB server at hippiedb.groovy.ch on port 1970 . Start sending commands. No authentication, no users, no passwords, just connect and vibe.","title":"Connecting to HippieDB"},{"location":"getting_started/#netcat","text":"nc hippiedb.groovy.ch 1970 set mykey myvalue get myKey stop","title":"Netcat"},{"location":"getting_started/#example-in-python","text":"import socket # Connect to HippieDB client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('hippiedb.groovy.ch', 1970)) # Send commands and receive responses client_socket.send(b'set mykey myvalue\\n') response = client_socket.recv(1024) print(response.decode()) # Close the connection when done client_socket.send(b'stop\\n') client_socket.close() You can find more client examples here.","title":"Example in Python:"},{"location":"getting_started/#commands","text":"HippieDB keeps it simple with just a handful of commands. Here\u2019s the full list:","title":"Commands"},{"location":"getting_started/#set-key-value","text":"Stores a value under a key. Keys must not contain spaces (keep it simple, man). Example: set groovy peace Response: OK","title":"SET key value"},{"location":"getting_started/#get-key","text":"Retrieves the value stored under a key. Example: get groovy Response: peace","title":"GET key"},{"location":"getting_started/#del-key","text":"Deletes a key and its value. Example: del groovy Response: OK","title":"DEL key"},{"location":"getting_started/#incr-key-value","text":"Increments the numeric value of a key by the specified [value]. If the [value] is not provided, it defaults to 1. If the key doesn\u2019t exist, it starts at 0. Examples: Increment by 1 (default): incr counter Response: 1 Increment by a specific value: incr vibe 10 Response: 10","title":"INCR key [value]"},{"location":"getting_started/#decr-key-value","text":"Decrements the numeric value of a key by the specified [value]. If the [value] is not provided, it defaults to 1. If the key doesn\u2019t exist, it starts at 0. Examples: Decrement by 1 (default): decr counter Response: -1 Decrement by a specific value: decr vibe 2 Response: 8","title":"DECR key [value]"},{"location":"getting_started/#stop","text":"Closes the session and disconnects from HippieDB. Use this when you\u2019re done sharing the vibes. Example: stop Response: BYE (and the connection closes)","title":"STOP"},{"location":"getting_started/#rules-of-the-road","text":"No spaces in keys. Keep it simple, man. Use underscores or dashes if you need separation. No permanent storage. HippieDB is ephemeral, like a sunset or a campfire. Enjoy the moment. Be cool. HippieDB is shared by everyone, so don\u2019t abuse it. Respect others\u2019 keys and keep the vibes positive.","title":"Rules of the Road"},{"location":"getting_started/#example-session","text":"Here\u2019s what a typical HippieDB session might look like: > set vibe peace OK > get vibe peace > incr counter 1 > incr counter 2 > decr counter 1 > del vibe OK > stop BYE","title":"Example Session"},{"location":"getting_started/#tips-for-groovy-development","text":"Keep it simple. HippieDB is designed for lightweight, fast, and fun use cases. Don\u2019t overcomplicate it. Share the love. If you build something cool with HippieDB, share it with the community. Spread the good vibes! Embrace impermanence. If your data disappears, it\u2019s a reminder to live in the now. Let it go, man.","title":"Tips for Groovy Development"},{"location":"getting_started/#running-locally","text":"You can run your own database on your computer or host your own HippieDB Server. See the hosting guide for details.","title":"Running locally"},{"location":"getting_started/#need-help","text":"If you\u2019re feeling lost, just take a deep breath and remember: HippieDB is all about simplicity and good vibes. If you still need help, send some positive energy into the universe, and the answers will come. Or, you know, check the FAQ for more groovy guidance. Now go forth and build something amazing with HippieDB! Whether it\u2019s a collaborative art project, a game, or just a place to store your favorite quotes, HippieDB is here to help you keep the vibes alive. Peace, love, and happy coding! \u270c\ufe0f","title":"Need Help?"},{"location":"guidelines/","text":"Community Guidelines for HippieDB \ud83c\udf3b Welcome to HippieDB, the database where peace, love, and data coexist in harmony! \ud83c\udf0d\u2728 To keep the good vibes flowing and ensure everyone has a far-out experience, we\u2019ve put together some guidelines to help you navigate this shared space. \ud83c\udf38 Remember, we\u2019re all in this together, man, so let\u2019s make it a groovy journey for everyone! 1. Spread the Love, Not the Chaos \ud83d\udc96 HippieDB is a shared space, so be mindful of others. Treat everyone\u2019s data with the same respect you\u2019d want for your own. If you need to use a key or namespace that someone else is using, don\u2019t freak out! Just ask nicely, like, \u201cHey, can I borrow this for a bit?\u201d Communication is key, man. 2. Namespaces Are Your Sacred Space \ud83c\udf3f Namespaces are like your own little patch of grass in the communal garden. Use them to keep your data organized and avoid stepping on anyone else\u2019s flowers. If you see a namespace that\u2019s already taken, don\u2019t sweat it! Either pick another groovy name or send a friendly request to the current reserver. Peaceful negotiations are always the way to go. 3. Clean Up After Yourself \ud83e\uddf9 Just like you wouldn\u2019t leave trash at a beautiful campsite, don\u2019t leave unused keys lying around. If you\u2019re done with a key, use del to tidy up. A clean database is a happy database! If you see someone else\u2019s forgotten keys, maybe give them a gentle nudge to clean up. But don\u2019t be a data cop, keep it chill, man. 4. Share the Groovy Ideas \ud83c\udfa8 Found a cool way to use HippieDB? Share it with the community! Whether it\u2019s a creative use of incr and decr or a collaborative art project, your ideas can inspire others. Use shared namespaces like community.art or community.music to collaborate and create something beautiful together. 5. Resolve Conflicts with Peace and Understanding \u270c\ufe0f If you bump into a conflict (like two people wanting the same key), don\u2019t panic. Use a shared key to talk it out, like conflict.mykey_discussion . Remember, it\u2019s all about finding a solution that works for everyone. Maybe you can take turns, or maybe you can create something even cooler together. Keep the vibes positive! 6. Respect Privacy and Boundaries \ud83d\udd4a\ufe0f Don\u2019t snoop around in someone else\u2019s namespace unless they\u2019ve invited you. Everyone deserves their own little corner of the database to call home. If someone asks you to back off, respect their wishes. Good boundaries make good neighbors, man. 7. Be a Data Hippie \ud83c\udf08 A true HippieDB user is kind, creative, and collaborative. Share your knowledge, help newbies find their way, and always strive to make the database a better place. If you see someone struggling, lend a hand. A little kindness goes a long way in keeping the community groovy. 8. Celebrate the Community \ud83c\udf89 HippieDB is more than just a database, it\u2019s a community of like-minded souls. Celebrate each other\u2019s successes, share your creations, and spread the love. Participate in community events, like collaborative storytelling or art projects. The more we come together, the cooler things get! 9. Keep It Fun and Funky \ud83c\udfb8 At the end of the day, HippieDB is all about having fun and expressing yourself. Don\u2019t take things too seriously, experiment, play, and let your creativity flow. If you ever feel stressed, just take a deep breath and remember: it\u2019s all about the journey, not the destination. 10. Pass It On \ud83c\udf1f If you meet someone new to HippieDB, welcome them with open arms. Share these guidelines, teach them the ropes, and help them feel at home. The more people who join the HippieDB family, the more amazing things we can create together. Final Thought: Peace, Love, and Data \u270c\ufe0f\ud83d\udcbe HippieDB is a place where everyone can thrive, as long as we respect each other and the space we share. So let\u2019s keep the vibes positive, the data organized, and the community groovy. Together, we can make HippieDB the most far-out database on the planet! \ud83c\udf0d\u2728","title":"Guidelines"},{"location":"guidelines/#community-guidelines-for-hippiedb","text":"Welcome to HippieDB, the database where peace, love, and data coexist in harmony! \ud83c\udf0d\u2728 To keep the good vibes flowing and ensure everyone has a far-out experience, we\u2019ve put together some guidelines to help you navigate this shared space. \ud83c\udf38 Remember, we\u2019re all in this together, man, so let\u2019s make it a groovy journey for everyone!","title":"Community Guidelines for HippieDB \ud83c\udf3b"},{"location":"guidelines/#1-spread-the-love-not-the-chaos","text":"HippieDB is a shared space, so be mindful of others. Treat everyone\u2019s data with the same respect you\u2019d want for your own. If you need to use a key or namespace that someone else is using, don\u2019t freak out! Just ask nicely, like, \u201cHey, can I borrow this for a bit?\u201d Communication is key, man.","title":"1. Spread the Love, Not the Chaos \ud83d\udc96"},{"location":"guidelines/#2-namespaces-are-your-sacred-space","text":"Namespaces are like your own little patch of grass in the communal garden. Use them to keep your data organized and avoid stepping on anyone else\u2019s flowers. If you see a namespace that\u2019s already taken, don\u2019t sweat it! Either pick another groovy name or send a friendly request to the current reserver. Peaceful negotiations are always the way to go.","title":"2. Namespaces Are Your Sacred Space \ud83c\udf3f"},{"location":"guidelines/#3-clean-up-after-yourself","text":"Just like you wouldn\u2019t leave trash at a beautiful campsite, don\u2019t leave unused keys lying around. If you\u2019re done with a key, use del to tidy up. A clean database is a happy database! If you see someone else\u2019s forgotten keys, maybe give them a gentle nudge to clean up. But don\u2019t be a data cop, keep it chill, man.","title":"3. Clean Up After Yourself \ud83e\uddf9"},{"location":"guidelines/#4-share-the-groovy-ideas","text":"Found a cool way to use HippieDB? Share it with the community! Whether it\u2019s a creative use of incr and decr or a collaborative art project, your ideas can inspire others. Use shared namespaces like community.art or community.music to collaborate and create something beautiful together.","title":"4. Share the Groovy Ideas \ud83c\udfa8"},{"location":"guidelines/#5-resolve-conflicts-with-peace-and-understanding","text":"If you bump into a conflict (like two people wanting the same key), don\u2019t panic. Use a shared key to talk it out, like conflict.mykey_discussion . Remember, it\u2019s all about finding a solution that works for everyone. Maybe you can take turns, or maybe you can create something even cooler together. Keep the vibes positive!","title":"5. Resolve Conflicts with Peace and Understanding \u270c\ufe0f"},{"location":"guidelines/#6-respect-privacy-and-boundaries","text":"Don\u2019t snoop around in someone else\u2019s namespace unless they\u2019ve invited you. Everyone deserves their own little corner of the database to call home. If someone asks you to back off, respect their wishes. Good boundaries make good neighbors, man.","title":"6. Respect Privacy and Boundaries \ud83d\udd4a\ufe0f"},{"location":"guidelines/#7-be-a-data-hippie","text":"A true HippieDB user is kind, creative, and collaborative. Share your knowledge, help newbies find their way, and always strive to make the database a better place. If you see someone struggling, lend a hand. A little kindness goes a long way in keeping the community groovy.","title":"7. Be a Data Hippie \ud83c\udf08"},{"location":"guidelines/#8-celebrate-the-community","text":"HippieDB is more than just a database, it\u2019s a community of like-minded souls. Celebrate each other\u2019s successes, share your creations, and spread the love. Participate in community events, like collaborative storytelling or art projects. The more we come together, the cooler things get!","title":"8. Celebrate the Community \ud83c\udf89"},{"location":"guidelines/#9-keep-it-fun-and-funky","text":"At the end of the day, HippieDB is all about having fun and expressing yourself. Don\u2019t take things too seriously, experiment, play, and let your creativity flow. If you ever feel stressed, just take a deep breath and remember: it\u2019s all about the journey, not the destination.","title":"9. Keep It Fun and Funky \ud83c\udfb8"},{"location":"guidelines/#10-pass-it-on","text":"If you meet someone new to HippieDB, welcome them with open arms. Share these guidelines, teach them the ropes, and help them feel at home. The more people who join the HippieDB family, the more amazing things we can create together.","title":"10. Pass It On \ud83c\udf1f"},{"location":"guidelines/#final-thought-peace-love-and-data","text":"HippieDB is a place where everyone can thrive, as long as we respect each other and the space we share. So let\u2019s keep the vibes positive, the data organized, and the community groovy. Together, we can make HippieDB the most far-out database on the planet! \ud83c\udf0d\u2728","title":"Final Thought: Peace, Love, and Data \u270c\ufe0f\ud83d\udcbe"},{"location":"help/","text":"Invalid hypertext link Error: There is no help page associated to this link. How to use the help system The help system works in a similar way to an internet browser window, each page is linked using a hyperlink system. Use the mouse to navigate the help pages, or use the following keys. Cursors - Move the text a single line at a time. Page Up/Page Down - Go up or down one page. ESC - Exit the help window. Backspace - To return to the previous page. These controls can be used only when the help window is selected (to select a window you just have to click the mouse over it). In the lower right part of the screen there is button that you can use to {change the size of the help window}. Simply click on the button, and whilst holding, drag with the mouse to change its size. The words that appear in white colour are {hyperlinks to other help pages} (the mouse cursor will look like a small hand when you are over the words). Click on these words to jump to the relevant page. The examples are small programs or parts of programs that appear in the Help to show the user how to use the functions and operations in the DIV language. All of them begin with a white colour line, as you can see right here: Example program: PROGRAM example; BEGIN // ... END - To try the example program, just click on the white line. These programs can be run with the F10 key and ended by pressing the ALT + X keys, the same as any other program. In the upper part of the help window you can see a group of buttons to navigate the pages. ( << Backwards and >> Forwards), ( Index , Glossary and Functions ), send the current page to the printer ( Print ), and information on how to use the help system ( ? ). General index Introduction to DIV Games Studio 2015 Help about the program language Glossary of Terms Syntax of a program Declaration of statements List of functions Predefined constants Predefined global data Predefined local data Arithmetic Expressions Logical conditions Key table Codes Language News Help about key table commands Graphical environment Commands Normal Commands in the games Commands in the program debugger Commands in the program editor Commands in the graphical editor Glossary of Terms != ! \" %= % && &= & ' [(](#() ) ) */ *= * ++ += + , -- -= -> - .. . /* // /= / : ; <<= << <= <> < =< == => = >= >>= >> > [ []](#]) ^= ^^ ^ |= || | _a, _b, _c, ... _case_sensitive _extended_conditions _free_sintax _hidden _ignore_errors _max_process _no_check _no_id_check _no_null_check _no_optimization _no_range_check _no_strfix _normal _simple_conditions _subdir _system _volid abs() acos() advance() all_drawing all_sound all_text and angle argc argv[] ascii asin() atan() atan2() begin bigbro break byte c_0 ... c_9 c_m7 c_m8 c_screen c_scroll calculate() case change_channel() change_sound() channel[] char() chdir() clear_screen() clone cnumber collision() compiler_options complete_dump complete_restore compress_file() const continue convert_palette() cos() ctype debug decode_file() default define_region() delete_draw() delete_text() dirinfo (struct) disk_free() draw() draw_z dump_type dup else encode() encode_file() end_fli() end exit() fade() fade_off() fade_on() fading false fast_mixer father fclose() fget_angle() fget_dist() fileinfo (struct) filelength() file find_color() flags flush() fopen() force_pal() for fps frame_fli() frame fread() free() from fseek() ftell() function fwrite() g_height g_width g_x_center g_y_center get_angle() get_dirinfo() get_dist() get_distx() get_disty() get_fileinfo() get_id() get_joy_button() get_joy_position() get_pixel() get_point() get_point_m8() get_real_point() get_sector_height() get_sector_texture() get_song_line() get_song_pos() get_wall_texture() getdrive() global go_to_flag() graphic_info() graph height id if ignore_error() import int is_playing_cd() is_playing_song() is_playing_sound() itoa() joy (struct) joy_filter joy_state key() let_me_alone() load() load_fnt() load_fpg() load_map() load_pal() load_pcm() load_pcx() load_screen() load_song() load_wav() load_wld() local loop lower() m320x200 ... m1024x768 m7 (struct) m8 (struct) m8_nextsector m8_sector m8_step m8_wall malloc() map_block_copy() map_get_pixel() map_put() map_put_pixel() map_xput() max_int max_process_time memory_free() min_int mkdir() mod mouse (struct) move_draw() move_scroll() move_text() near_angle() net (struct) net_get_games() net_join_game() new_map() no_restore not num_video_modes offset or out_region() partial_dump partial_restore path_find() path_free() path_line() pi play_cd() pointer pow() priority private process program put() put_pixel() put_screen() qsort() quality_mixer radius rand() rand_seed() refresh_scroll() region remove() repeat reserved reset_fli() reset_sound() resolution restore_type return roll_palette() s_freeze_tree s_freeze s_kill_tree s_kill s_sleep_tree s_sleep s_wakeup_tree s_wakeup save() save_map() save_pcx() scan_code screen_copy() scroll (struct) seek_cur seek_end seek_set set_color() set_env_color() set_fog() set_fps() set_mode() set_point_m8() set_sector_height() set_sector_texture() set_song_pos() set_volume() set_wall_texture() setdrive() setup (struct) setup_program shift_state signal() sin() sizeof() size smallbro song() son sound() sound_bits_16 sound_bits_8 sqrt() start_fli() start_mode7() start_mode8() start_scroll() step stop_cd() stop_mode7() stop_mode8() stop_scroll() stop_song() stop_sound() strcat() strchr() strcmp() strcpy() strdel() string strlen() strset() strstr() struct switch system() tan() text_z timer[] to true type uncompress_file() drive_size unload_fnt() unload_fpg() unload_map() unload_pcm() unload_pcx() unload_song() unload_wav() until upper() video_modes (struct) vsync while word write() write_in_map() write_int() xadvance() xgraph xor xput() x y z abs() abs( ) Returns: The absolute value of the expression. Description: Calculates the absolute value of the expression given as parameter. If the result of the expression is negative it will change the sign, if it is positive, it won't do anything. Example program: PROGRAM example_abs; GLOBAL INT values[15]; INT n; BEGIN FROM n=0 TO 15; values[n]=rand(-1000, 1000); write_int(0, 0, n*10,0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to run the function abs()\"); LOOP IF (key(_space)) FROM n=0 TO 15; values[n] = abs(values[n]); // We find the absolute value END END FRAME; END END - This program will print a list of values on the screen that can be positive or negative, when the space bar is pressed it will apply the function abs() to all these values, making all values positive. ---See: Expression advance() advance( ) Description: Advances the process in its angle (specified by the local angle variable) as many points as specified in the expression (distance) parameter. To advance in a different angle to the one specified in this variable, use the xadvance() function instead. The value can be also a negative number, in this case, the processes' graphic will advance in the opposite direction to the angle specified. Example program: PROGRAM example_advance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=101; x=160; y=100; write(0, 0, 0, 0, \"Use the cursors (left + right) to change direction.\"); LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END advance(2); // We advance 2 points FRAME; END END - This example will draw a triangle on screen that will advance in the specified direction (2) in the specified local variable angle using this function. Remember that the angle is specified in thousandths of a degree. The local angle variable will be changed using the cursor keys (adding or subtracting 10000, which is equivalent to 10 degrees). This function is the same as executing the following two statements: x+=get_distx(angle, ); y+=get_disty(angle, ); This function just modifies the coordinates of the process. It is possible to use the two previous statements when you would like the process to advance in a different angle to the one which in the local angle variable. This could be useful if you want to advance without rotation. Alternatively you can use the xadvance() function. For example, to make a process advance 8 points in a direction ( stored in a private variable called angle2 ) but rotated in another direction, (the angle variable), you would use: x+=get_distx(angle2, 8); y+=get_disty(angle2, 8); ---See: xadvance() - Use of angles in the language - get_distx() - get_disty() change_sound() change_sound( , , ) Description: To use this function it is essential to have a sound card installed which is 100% compatible with Sound Blaster (tm) or Gravis Ultrasound (tm) and have the correct drivers installed. This function only works if it is used after the sound() function is called, which is used to play sounds. Change_sound() modifies one sound that is playing on one of the channels , setting the volume and frequency . The channel is the channel code that is returned by the sound() function. You can play up to 16 channels at the same time, with the same sound or with different sounds. Each time you play a sound it is quite possible that it will be played through a different channel. Each channel has its own levels of volume and frequency. The volume is a value between 0 (minimum volume) and 512 (maximum volume) which determines the noise level that the sound will be heard through this channel. The frequency is a value that affects the speed of the sound through the channel, it controls how deep or sharp the sound is emitted. Valid values are between 0 (deep) and 512 (sharp). Example program: PROGRAM example_change_sound; PRIVATE freq=256; // Medium Value (0..512) vol=256; // Medium Value (0..512) sound_id; chan; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); sound_id = load_pcm(\"help/help.pcm\", 1); chan = sound(sound_id, vol, freq); write(0, 0, 0, 0, \"Press right or left to change the frequency.\"); write_int(0, 0, 10, 0, offset freq); write(0, 0, 20, 0, \"Press up or down to change the volume.\"); write_int(0, 0, 30, 0, offset vol); LOOP // Change the sound change_sound(chan, vol, freq); IF (key(_right)) freq++; END IF (key(_left)) freq--; END IF (key(_up)) vol++; END IF (key(_down)) vol--; END FRAME; END END - In the example a sound help.pcm is loaded and played. Inside the main loop of the program you can change the frequency and the volume of this sound using the change_sound() function to modify these values using the cursor keys. ---See: load_pcm/wav() - sound() - unload_pcm/wav() - STRUCT setup clear_screen() clear_screen() Description: Delete from the screen all graphics placed on it with the put() , xput() , put_pixel() & put_screen() functions. Example program: PROGRAM example_clear_screen; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"Press [SPACE] to clear the screen.\"); write(0, 0, 10, 0, \"Press [ENTER] to view it again.\"); graph=100; x=160; y=100; LOOP IF (key (_space)) clear_screen(); // Deletes the graphic of the screen END IF (key (_enter)) put_screen(0, 1); END FRAME; END END - In the example a graphic is drawn using the put_screen() function. When the space bar is pressed, the screen is deleted. Pressing the key Enter , you can see the screen again. You can see how the graphic of the process (a ball that appears in the centre) doesn't disappear when you use the function clear_screen() , because the function will just delete the screen. ---See: put() - xput() - put_pixel() - put_screen() collision() collision( ) Returns: The identifier code of one process or 0 . Description: This is the function to detect collisions between graphics. Checks if the current process (the one that executed this function) collides with one of the indicated parameter types. It checks to see if the graphics of both processes are overlapped. If a collision is detected, it returns the identifier code of the process which is colliding with the current process. If not, the function will return 0 . If the current process collides with more process of the specified type, the function collision() will return the rest of the identifiers in the successive calls to the collision() function. To get every identifier code of the process that is in collision with the current one, you must not use a FRAME statement between successive calls to the collision() function. As soon as a FRAME statement is reached, the function will start returning collision ID's starting with the first. Something similar happens if you run a call to the function specifying a different type of process; if, after this, collisions are still detected with the previous type, this function will return every code from the first. If you want to obtain every identifier code of the processes of one particular type without collision, you must call the function get_id() . If you want to check how near two processes are so that their graphics do not collide, then you must use the get_dist() function. Example program: PROGRAM example_collision; PRIVATE id2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; mobile_process(80, 50, 101); LOOP delete_text(all_text); write(0, 160, 0, 1, \"Use the cursors to move the triangle\"); id2 = collision(TYPE mobile_process); // Collision detected IF (id2<>0) write(0, 160, 200, 7, \"\u00a1 COLLISION DETECTED!\"); END FRAME; END END PROCESS mobile_process(x, y, graph); BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example you can see a ball in the centre of the screen as the graphic of the main program. After that a process named mobile_process is created with the picture of a controllable triangle with the cursor keys. The main program will call the function collision() to check if its graphic (the circle) collides with the graphic of the mobile_process type (the triangle). The result of the function is saved in the private variable id2 of the main program. This value will be 0 until a collision is detected, and will return the identifier code of mobile_process when it does. The identifier codes of the processes are always odd numbers, which in the DIV language are true conditions (the even numbers are associated with the false conditions), thus, in the example program we could have changed the statement to: IF (id2<>0) ... END For the next one: IF (id2) ... END For further information about this, see: Definition of a condition. When you can see the mouse pointer in a DIV program (by assigning the code of the corresponding graphic in the mouse structure ), it is possible to see if it has collided with the current process using this function in the following way: IF (collision(TYPE mouse)) // The process collides with the mouse pointer END When a collision with the mouse pointer is detected, it won't be done with the entire graphic used as a pointer like a normal graph, but only with the main checkpoint (the number 0) of the same item, known commonly as the \"hotspot\" ( hotspot ) of the mouse. This function is used to detect collisions between graphics on the screen or in a window with a scrollbar. It's not possible to use this function to detect collisions with processes that don't have a graphic (a valid code allocated to its variable graph ) or between graphics of a window of mode 7 or mode 8 (with its variable ctype allocated to the value c_m7 o c_m8 ). It is essential that the particular item of the current process that is the specified graphic has a defined graphic associated with it. To detect collisions between graphics of a window of mode 7 or mode 8 you must use the get_dist() function to detect when the distance between the two processes is smaller than the distance stipulated as a collision distance . ---See: get_id() - get_dist() - Types of processes - {#1038,Ways to obtain the identifier code} convert_palette() convert_palette( , , ) Description: Manipulates a map of colour to that of the indicated . The < offset new_palette> is the path/address inside the memory of the computer of a 256-colour table where the new order of colours are located. Note: The table must be (of the INT type, signed 32bit). If the table is like this: new_palette[255]=0, 1, 2, 3, 4, ... , 254, 255; The graphic will not be changed. However, if in the 3rd position of the previous table (new_palette[3]) there is a 16 (not a 3), when the function is called with the offset of the table, the colour 3 will be changed for the colour 16 in the graphic. The graphics loaded with the functions load_map() or load_pcx() (or made with new_map() ) will be used as if they refer to the first file (the file with the code 0). If a process wants to change the colours of its graphic, it must build a palette with the new order of colours and, after that, call the function with the parameters: convert_palette(file, graph, ) Here is a program that changes the colours of its graphic in this way using the predefined local variables file and graph . Example program: PROGRAM example_convert_palette; PRIVATE new_palette[255]; counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); FROM counter=1 TO 255; new_palette[counter]=(counter+16) MOD 256; END graph=100; x=160; y=100; write (0, 160, 0, 1, \"Press [SPACE] to change the colours of the ball\"); LOOP IF (scan_code==_space) // We convert the palette of the graphic number 100 (ball) convert_palette(file, graph, offset new_palette); END FRAME; END END - First, a table is created with the new order of the palette. The colour number 0 (transparent) never changes (new_palette[0] will always be 0) and the rest of the colours (from 1 to 255) will be changed for the colour that is 16 positions further along in the palette (the 1 for 17, the 2 for 18, etc.). The last 16 colours will be changed for the first 16 (when the operation MOD 256 is done the values are truncated, 256 will be 0, 257 will be 1, etc.). After that, inside the main loop of the program the function will run convert_palette() and it will change the colours of the ball each time that the space bar is pressed. ---See: load_pal() - roll_palette() define_region() define_region( , , , , ) Description: Defines a new region within the screen (like a borderless window). Regions are rectangular areas inside the screen, in which you will see some kind of process, scroll windows or mode 7 windows. The region number must be between 1 and 31. Up to 31 different regions in the screen can be defined that are assignable, after that, to different processes (fixing its local variable region to the new number) as its view window or use it like a border for a scroll window or a mode 7 window, indicating it in the parameter of the functions start_scroll() or start_mode7() . The region number 0 can't be redefined, because it will be always be the entire screen, a window at the coordinates (0, 0) and as wide and as high as the screen. This is the region in which every process will be displayed, because its local variable region always has a value 0. Example program: PROGRAM example_define_region; PRIVATE counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); define_region(1, 0, 0, 160, 200); // We define the region 1 define_region(2, 160, 0, 160, 200); // We define the region 2 write(0, 0, 0, 0, \"Region 1\"); write(0, 320, 0, 2, \"Region 2\"); FROM counter=1 TO 20; mobile_process(rand(0, 319), rand(0, 159), rand(-8, 8), rand(-8, 8), rand(1, 2)); END END PROCESS mobile_process(x, y, increment_x, increment_y, region); BEGIN graph=100; LOOP IF (x<0 OR x>320) increment_x=-increment_x; END IF (y<0 OR y>200) increment_y=-increment_y; END x+=increment_x; y+=increment_y; FRAME; END END - First you define two regions as lateral divisions of the screen. After that, 20 processes of the type mobile_process are created using a loop at random coordinates and movement, in one of the two regions. You can see in the execution how each process can be seen in only one of the two halves of the screen (just in its region). ---See: out_region() - start_scroll() - start_mode7() - Variable region delete_text() delete_text( ) Description: Delete text on the screen that is specified with the text identifier parameter, which is a numeric code returned by the functions write() and write_int() . If all_text is specified as the text identifier parameter, then all text on screen will be deleted. Example program: PROGRAM example_delete_text; PRIVATE text_id; BEGIN write(0, 160, 10, 1, \"Press [ENTER] to make the above text reappear.\"); LOOP text_id=write(0, 160, 0, 1, \"Press [SPACE] to delete this text.\"); WHILE (NOT key(_space)) FRAME; END delete_text(text_id); // Delete the text WHILE (NOT key(_enter)) FRAME; END END END - In this example, two texts appear on screen. When you press the space bar, one of these texts will be deleted using the delete_text() function, and when you press the Enter key, the text appears again using the write() function - which returns the new text identifier text_id . ---See: write() - write_int() - move_text() end_fli() end_fli() Description: Finishes an animation FLI/FLC shown on screen and frees the memory that was being used. The animations FLI/FLC are initiated with the start_fli() function. Only one animation can be loaded at a time. Example program: PROGRAM example_end_fli; BEGIN LOOP start_fli(\"help/help.fli\", 0, 0); // load and play the animation WHILE (frame_fli()<>0) FRAME; END end_fli(); // Unload the animation END END - In this example, the animation is loaded with the start_fli() function and then is displayed via frame_fli() until it finishes (when frame_fli() returns 0). At that moment it is unloaded from memory using end_fli() . The program does this sequence of commands (load, play, update and unload) of the animation FLI/FLC ) indefinitely. It is not necessary for the animation to have finished before it is unloaded from the memory. ---See: start_fli() - frame_fli() - reset_fli() exit() exit( , ) Description: Ends the game, killing all processes and returning to the operating system (or to the DIV IDE) with a message and a numeric code . The message is text message displayed between quotation marks which will be shown when the game finishes as an indication to the user that they have left DIV2. The return code is valid for the use of external programs to DIV Games Studio (like *.BAT files ), to determine the action that must be done after finishing the game. When the function exit() is used, you do not need to close any resources as this will be done for you (such as maps, fli, sounds and songs) as the system frees all resources automatically . Example program: PROGRAM example_exit; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to finish the program.\"); LOOP IF (key (_space)) fade_off(); exit(\"Thanks for using me!\", 0); // We exit the program END FRAME; END END - In the example you can see a message whilst the program waits for the space bar to be pressed, then exits with the exit() function. Every DIV program will finish its execution at any moment if the key combination [ALT]+[X] is pressed. This is similar to calling the exit() function, but without any messages and with the return code 0. ---See: let_me_alone() - fade_off() fade() fade( <% red> , <% green> , <% blue> , ) Description: Fades the palette until the percentages of colour is reached - (from 0% to 200% of the red (red), green (green) and blue (blue) components, specified as parameters). The last parameter indicates the speed at which the fading will occur, normally defined as a number from 1 (very slowly) to 10 (Very fast). If the speed indicates a number bigger or equal to 64, the fade will be done instantaneously. The fade will be done gradually in the successive frames of the game. If all three colour components are 0 you will see a fade to black, if the three components are set to 200, the fade will be to white, if the components are 100 you will retrieve the original colours of the game palette. A value less than 100 in a component will tone down its colour, meanwhile that a value greater than 100, will saturate the colour. Remember that the fade doesn't happen when the function fade() is called, but over the next FRAME statements . Whilst the program is executing a fade command, the predefined global variable fading will have a value of true (1) and when the fade is finished (the required values have been reached), this variable will be set to false (0). Example program: PROGRAM example_fade; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to see the fade() effects.\"); LOOP IF (NOT fading AND key(_space)) fade(rand(0, 200), rand(0, 200), rand(0, 200), 5); END FRAME; END END - In the example a screen is loaded and a message appears. Each time that the space bar is pressed and a fade is not already in progress ( IF (NOT fading ...) ), a new fade will start with the three random values chosen between 0% and 200% (with the rand() function) at a speed value of 5. ---See: fading - fade_off() - fade_on() - load_pal() fade_off() fade_off() Description: Creates a fade to black from the colours on screen. The game stays as it is until the screen is completely black. To turn on the screen again (undo the fade to black), use the fade_on() function. Example program: PROGRAM example_fade_off; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to fade off and fade on the screen.\"); LOOP WHILE (NOT key(_space)) FRAME; END fade_off(); // We turn off the screen fade_on(); END END - In this example, a screen appears, and after that, the program waits for the space bar to be pressed to turn off and turn on the screen. The fade() function can do this without stopping the program or at different speeds, as well as creating more advanced palette effects. ---See: fade() - fade_on() fade_on() fade_on() Description: Creates a fade up of the colours on the screen to their natural saturation (100%). In the successive FRAME statements of the game, the colours will recover their visibility until they can be seen perfectly. To turn off the screen (to do a fade to black) use the fade_off() function. Example program: PROGRAM example_fade_off; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to fade off and fade on the screen.\"); LOOP WHILE (NOT key(_space)) FRAME; END fade_off(); fade_on(); // The screen is faded on END END - In this example, a screen appears, and after that, the program waits for the space bar to be pressed to turn off and turn on the screen. The fade() function can do this without stopping the program or at different speeds, as well as creating more advanced palette effects. Every game automatically executes a fade_on() at the beginning of execution. ---See: fade() - fade_off() fget_angle() fget_angle( , , , ) Returns: The angle between two points. Description: Returns the angle from the point 0 (x0, y0) to the point 1 (x1, y1). Remember that the angle is specified in thousandths of a degree. The function always returns a value between ** -180000 and 180000** (an angle between -180 and 180 degrees). Coordinates of both points (x0, y0, x1, y1) can be any valid numeric expression. Example program: PROGRAM example_fget_angle; PRIVATE coord_x0, coord_y0; coord_x1, coord_y1; result; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); write(0, 0, 0, 0, \"Coordinates point 1\"); write(0, 0, 10, 0, \"X:\"); write_int(0, 20, 10, 0, offset coord_x0); write(0, 0, 20, 0, \"Y:\"); write_int(0, 20, 20, 0, offset coord_y0); write(0, 0, 40, 0, \"Coordinates point 2\"); write(0, 0, 50, 0, \"X:\"); write_int(0, 20, 50, 0, offset coord_x1); write(0, 0, 60, 0, \"Y:\"); write_int(0, 20, 60, 0, offset coord_y1); write(0, 0, 80, 0, \"Angle from point 1 to point 2:\"); write_int(0, 0, 90, 0, offset result); write(0, 0, 200, 6, \"Press [SPACE] to get another two points.\"); LOOP clear_screen(); coord_x0=rand(0, 319); coord_y0=rand(0, 199); coord_x1=rand(0, 319); coord_y1=rand(0, 199); put(file1,200,coord_x0, coord_y0); put(file1,200,coord_x1, coord_y1); //We find the angle between two points result = fget_angle(coord_x0, coord_y0, coord_x1, coord_y1); scan_code=0; WHILE (scan_code<>_space) FRAME; END END END - In this example, some text messages are printed on the screen, along with some coordinates x and y of two points set from random values. The angle between the points is then calculated with the fget_angle() function. Each time that the space bar is pressed the process will repeat. The get_angle() function is used to obtain the angle between two processes , instead of between two points. The fget_dist() function is used to obtain the {distance between two points}, instead of the angle. ---See: Use of angles in the language - get_angle() - fget_dist() fget_dist() fget_dist( , , , ) Returns: The distance between two points. Description: Returns the distance between point 0 (x0, y0) and point 1 (x1, y1). Coordinates of both points (x0, y0, x1, y1) can be specified by any valid numeric expression. Example program: PROGRAM example_fget_dist; PRIVATE coord_x0, coord_y0; coord_x1, coord_y1; result; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); write(0, 0, 0, 0, \"Point 1 Co-ordinates\"); write(0, 0, 10, 0, \"X:\"); write_int(0, 20, 10, 0, offset coord_x0); write(0, 0, 20, 0, \"Y:\"); write_int(0, 20, 20, 0, offset coord_y0); write(0, 0, 40, 0, \"Point 2 Co-ordinates\"); write(0, 0, 50, 0, \"X:\"); write_int(0, 20, 50, 0, offset coord_x1); write(0, 0, 60, 0, \"Y:\"); write_int(0, 20, 60, 0, offset coord_y1); write(0, 0, 80, 0, \"Distance between point 1 and point 2\"); write_int(0, 0, 90, 0, offset result); write(0, 0, 200, 6, \"Press [SPACE] to find another distance.\"); LOOP clear_screen(); coord_x0=rand(0, 319); coord_y0=rand(0, 199); coord_x1=rand(0, 319); coord_y1=rand(0, 199); put(file1,200,coord_x0, coord_y0); put(file1,200,coord_x1, coord_y1); //Find the distance between the two points result = fget_dist(coord_x0, coord_y0, coord_x1, coord_y1); scan_code=0; WHILE (scan_code<>_space) FRAME; END END END - In this example, the program sets the 2 sets of co-ordinates to random values, and then obtains the distance between them with the fget_dist() function. Each time that the space bar is pressed, the process is repeated. The get_dist() function is used to obtain the {distance from one process to another}, instead of from one point to another. The fget_angle() function is used to obtain the {angle between two points}, instead of the distance. This function could be used to detect collisions between processes, but of course, you would normally use the collision() function which detects when two processes have their graphics overlapping. An example of this is when a process exists within a Mode 7 window (See start_mode7() ) the collision() function can't be used, so the distance between the processes must be obtained (normally with get_dist() ) to check if they collide (if their distance is smaller than a specified one). ---See: get_dist - fget_angle - collision() frame_fli() frame_fli() Returns: True if the animation continues and false if it has finished. Description: Shows the next image of an animation FLI/FLC that was started with the start_fli() function. This function returns 0 (false) if the animation has finished. It is only possible to run one FLI/FLC animation at a time. It is not possible to have two animations playing at the same time. The next frame of animation will be seen in the next FRAME of the game, but if a loop is created without a FRAME statement, the animation will not be seen. Example program: PROGRAM example_frame_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); LOOP frame_fli(); // Show the next frame of animation FRAME; END END - In the example, the animation FLI/FLC is loaded and then played repeatedly with the frame_fli() function. ---See: start_fli() - reset_fli() - end_fli() get_angle() get_angle( ) Returns: The angle to other process Description: Returns the angle from the current process (the one which called this function) to the process which has the identifier code . See Ways to obtain the identifier code , for further information. Remember that angle is specified in thousandths of a degree. The function will always return a value between -180000 and 180000 (an angle between -180 and 180 degrees). Example program: PROGRAM example_get_angle; PRIVATE resulting_angle; process_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; process_id = mobile_object(80, 50, 101); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Angle from the ball to the triangle:\"); write_int(0, 0, 10, 0, offset resulting_angle); LOOP // We find the angle between the two processes resulting_angle = get_angle(process_id); FRAME; END END PROCESS mobile_object(x, y, graph); BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example, a ball is displayed in the centre of the screen. A mobile_object process is created, and its identifier code is stored in the process_id variable. This process can be controlled with the cursor keys. In the main loop of the program, the angle between the two processes is calculated and shown on screen continuously. The fget_angle() function is used to obtain the {angle between two points}, instead of between two processes. For Example, if the identifier code of the process refers to a variable id2 , then a function call of: get_angle(id2) Would be equivalent to: fget_angle(x, y, id2.x, id2.y) The get_dist() function is used to obtain the distance to the other process instead of the angle. ---See: Use of angles in the language - fget_angle() - get_dist() get_dist() get_dist( ) Returns: The distance to the other process. Description: Returns the distance from the current process (the one which called this function) to the process which has the identifier code . See ways to obtain the identifier code , for further information. If the process has defined its local variable resolution then it is important that the process for which the distance we wish to obtain has the resolution local variable set to the same value. If both processes have the coordinates in hundredths instead of whole amounts (with resolution =100), then the distance between both will be given in hundredths too, but if the value of this variable is different between processes, then the result of the get_dist() function will not make sense. Example program: PROGRAM example_get_dist; PRIVATE resulting_distance; process_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; process_id = mobile_object(80, 50, 101); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Distance from the ball to the triangle:\"); write_int(0, 0, 10, 0, offset resulting_distance); LOOP // We find the distance between the two processes resulting_distance = get_dist(process_id); FRAME; END END PROCESS mobile_object(x, y, graph) BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example, a ball is displayed in the centre of the screen. A mobile_object process is created, and its identifier code is stored in the process_id variable. This process can be controlled with the cursor keys. In the main loop of the program, the distance between the two processes is calculated and updated on screen continuously. The function fget_dist() is used to obtain the {distance between two points}, instead of between two processes. If the identifier code of the process is contained, for example, in a variable denominated id2 , then the call to the function: get_dist(id2) Will be equivalent to: fget_dist(x, y, id2.x, id2.y) To obtain the distance from the coordinates (x, y) of the current process up to the coordinates (x, y) of the process for which its identifier code is id2 . The function get_angle() is used to obtain the angle to the process instead of the distance. This function can be used to detect collisions between processes, though of course, the collision() function is normally used which detects when two processes graphics overlap. An example of this is when a process exists within a Mode 7 window (See start_mode7() ) the collision() function can't be used, so the distance between the processes must be obtained (normally with get_dist() ) to check if they collide (if their distance is smaller than a specified one). ---See: fget_dist() - get_angle() - get_distx() - get_disty() get_distx() get_distx( , ) Returns: The horizontal distance towards the vector (angle, distance). Description: Returns the horizontal distance (in the x axis) from the angle and distance (over this angle) passed as parameters. It returns the distance that the vector moves horizontally (along the x-axis), made by the angle and length (distance or module of the vector) indicated. Keep in mind that the angle is specified in thousandths of a degree and distance can be specified by any valid numeric expression. The function used to calculate the vertical distance, instead of the horizontal one is get_disty() . Example program: PROGRAM example_get_distx; GLOBAL distance; horizontal_distance; vertical_distance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 3); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Horizontal distance:\"); write_int(0, 0, 10, 0, offset horizontal_distance); graph=101; LOOP IF (key(_up)) distance+=2; END IF (key(_down)) distance-=2; END IF (key(_right)) angle-=2000; END IF (key(_left)) angle+=2000; END // We calculate the horizontal distance horizontal_distance= get_distx(angle, distance); vertical_distance = get_disty(angle, distance); x=160+horizontal_distance; y=100+vertical_distance; FRAME; END END - In the example, a circular graphic is placed on screen, then a triangle process is shown, whose angle and distance can be controlled using the cursor keys. The program calculates the horizontal and vertical distances to the triangle from the coordinates of the centre of the screen (160, 100), showing the horizontal distance in the upper left corner all the times. If the aim is to advance the coordinates of the process a distance in a specific angle, the following statements may be used: x+=get_distx( , ); y+=get_disty( , ); This would be equivalent to (using the xadvance() function). xadvance( , ); If the angle that you wish to move the process is the one declared in the local variable angle , then you would use the advance() function like this: advance( ); The get_distx() function is the same as calculating the cosine of the angle and multiplying it by the distance . ---See: Use of angles in the language - get_disty() - xadvance() - advance() get_disty() get_disty( , ) Returns: The vertical distance towards the vector (angle, distance). Description: Returns the vertical distance (in the x axis) from the angle and distance (over this angle) passed as parameters. It returns the distance that the vector moves vertically (along the y-axis), made by the angle and length (distance or module of the vector) indicated. Keep in mind that the angle is specified in thousandths of a degree and distance can be specified by any valid numeric expression. The function used to calculate the horizontal distance, instead of the vertical one is get_distx() . Example program: PROGRAM example_get_disty; GLOBAL distance; horizontal_distance; vertical_distance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 3); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Vertical distance:\"); write_int(0, 0, 10, 0, offset vertical_distance); graph=101; LOOP IF (key(_up)) distance+=2; END IF (key(_down)) distance-=2; END IF (key(_right)) angle-=2000; END IF (key(_left)) angle+=2000; END // We calculate the horizontal distance horizontal_distance= get_disty(angle, distance); vertical_distance = get_disty(angle, distance); x=160+horizontal_distance; y=100+vertical_distance; FRAME; END END - In the example, a circular graphic is placed on screen, then a triangle process is shown, whose angle and distance can be controlled using the cursor keys. The program calculates the horizontal and vertical distances to the triangle from the coordinates of the centre of the screen (160, 100), showing the vertical distance in the upper left corner all the times. If the aim is to advance the coordinates of the process a distance in a specific angle, the following statements may be used: x+=get_disty( , ); y+=get_disty( , ); This would be equivalent to (using the xadvance() function). xadvance( , ); If the angle that you wish to move the process is the one declared in the local variable angle , then you would use the advance() function like this: advance( ); The get_disty() function is the same as calculating the sine of the angle and multiplying it by the distance . ---See: Use of angles in the language - get_distx() - xadvance() - advance() get_id() get_id( ) Returns: The identifier code of a process or 0 . Description: This function checks to see if there are any processes of the specified type. If any are found, then the function will return the identifier code of the first occurrence, and if none are found will return a 0. If there are more processes of the specified type, the function get_id() will return the next identifier code for each successive call. Once every identifier code has been returned, the function will return 0, until the next FRAME statement is executed, at which point the function will be reset, and once again will begin to return every identifier code of the specified type of process. If you wish to get all of the identifier codes of the processes of that type, you should not use the FRAME statement between two successive calls to get_id() . If you execute a FRAME statement between calls to get_id() then the function will again reset and start returning values from the first occurrence of that type of process. A similar thing happens if you call get_id() with a different process type. Each time a new process type is called, the identifiers reset and start with the first process of that type. Example program: PROGRAM example_get_id; PRIVATE process_id; counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); FROM counter=1 TO 20; my_process(rand(0, 319), rand(0, 199), 101); END LOOP FROM counter=1 TO 20; // Get the Processes ID process_id = get_id(TYPE my_process); // Change the processes LOCAL angle variable using the ID process_id.angle+=rand(-5000, 5000); END FRAME; END END PROCESS my_process(x, y, graph); BEGIN LOOP FRAME; END END - In the example, after having loaded the file with graphics and set the background screen, 20 movable_process type processes are created with their positions randomly chosen and with a triangle-shaped graphic. These processes will only execute FRAME statements inside a loop, in order to be displayed. From the main program, the identifiers of the movable_process type processes are taken with the get_id() function (storing them in the process_identifier variable) and using them to modify their angle (their angle local variable). On having the identifying code of a process, it is possible to consult or modify its local variables (like angle in this example) or else, to send signals to the process with the signal() function. The collision() function is used to obtain the identifier codes of processes of a determined type that collide with the current process. ---See: Ways to obtain the identifier code - Types of processes - Identifier codes get_joy_button() get_joy_button( [button number] ) Returns: True (1) if the button is pressed or False (0) if it isn't Description: This function requires the joystick number button (from 0 to 3) as a parameter, and returns true (an odd numerical value) if it is pressed at that moment. If the button is not pressed, the function returns false (an even numeric value). Some joysticks only have two buttons, and this case they will be mapped to button numbers 0 and 1. On computers that have two joysticks connected, the second joystick will have the buttons numbered 2 and 3. Example program: PROGRAM example_get_joy_button; PRIVATE counter; buttons[3]; BEGIN write(0, 160, 200, 7,\" Press the buttons of the joystick.\"); write(0, 0, 0, 0, \"Buttons (0..3):\"); write_int(0, 100, 0, 0, offset buttons[0]); write_int(0, 120, 0, 0, offset buttons[1]); write_int(0, 140, 0, 0, offset buttons[2]); write_int(0, 160, 0, 0, offset buttons[3]); LOOP FROM counter=0 TO 3; // We take the value of the joystick button buttons[counter] = get_joy_button(counter); END FRAME; END END - An explanatory message is displayed in the lower part of the screen and the condition of the four possible buttons is displayed in the upper part of the screen; after that, the program stays inside of a loop updating the state of the four buttons continuously using the get_joy_button() function. There are other ways to read the joystick. The easiest is to use the joy structure, because in there are four variables that are continuously updated with the status of the joystick buttons. ---See: get_joy_position() - Joy Structure get_joy_position() get_joy_position( ) Returns: The position of the joystick axis Description: This function returns the coordinate in which is found the indicated axis (with a number from 0 to 3 ) of the analogic joystick. Axis 0 - Axis X main. Axis 1 - Axis Y main. Axis 2 - Axis X secondary. Axis 3 - Axis Y secondary. The coordinate of the joystick can change due to the type of joystick and computer in which it is played, in all cases it is a number which changes between 4 and 200 , more or less. The axes main and secondary can be integrated in just one joystick in some cases (flight joysticks with a hat , pedals , etc.). In computers with two joysticks connected, the main axis will be the joystick 1 and the secondary axis will be the joystick 2. Example program: PROGRAM example_get_joy_position; PRIVATE joystick_axis[3]; counter; BEGIN write (0, 160, 200, 7, \"Move the joystick\"); write (0, 0, 0, 0, \"Coordinate X main.\"); write_int(0, 0, 10, 0, offset joystick_axis[0]); write (0, 0, 40, 0, \"Coordinate & main.\"); write_int(0, 0, 50, 0, offset joystick_axis[1]); write (0, 0, 80, 0, \"Coordinate X secondary.\"); write_int(0, 0, 90, 0, offset joystick_axis[2]); write (0, 0, 120, 0, \"Coordinate & secondary.\"); write_int(0, 0, 130, 0, offset joystick_axis[3]); LOOP FROM counter=0 TO 3; // We take the value of the joystick axis joystick_axis[counter] = get_joy_position(counter); END FRAME; END END - Information is printed on the screen, then the program is put into a continuous loop. The screen updates with the state of each joystick position, stored in the joystick_axis[] array, and updated using the get_joy_position() function. There are other ways to read the joystick. The easiest is to use the joy structure when analogue reading of the joystick (its coordinates) is not required. This tells you the simple directions of the joystick, like the centre, to the right, down, etc. ---See: get_joy_button() - joy structure get_pixel() get_pixel( , ) Returns: The colour value of the pixel (0..255). Description: Returns the colour of the background at the screen coordinates that are specified in the parameters. The number returned is a palette index from the active palette between 0 and 255, because the palettes have 256 colours. The point refers to only the background from the picture, without taking notice of the graphics of the processes, texts, scroll regions, etc. Only the images placed on screen by the functions put() , xput() , put_pixel() & put_screen() will be read. Example program: PROGRAM example_get_pixel; PRIVATE pixel_colour; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); mouse.graph=200; write (0, 0, 190, 0, \"Colour of the background pixel:\"); write_int(0, 256, 190, 0, offset pixel_colour); LOOP // We take the colour of the point of the background pixel_colour = get_pixel(mouse.x, mouse.y); FRAME; END END - In this example, the put_screen function is used to display an image on screen, representing a group of squares in different colours, and a mouse pointer displayed as a cross. In the lower part of the screen a message is displayed, along with a variable that is updated from the get_pixel() command. By using the mouse, you can obtain the colour of any pixel on the screen. ---See: put_pixel() - map_get_pixel() - map_put_pixel() - get_point() get_point() get_point( , , , , ) Returns: The position of the checkpoint (placed into the variables which offset is declared in the last two parameters). Description: This function will place the coordinate values of a map point into the variable you specify from an indicated graphic. A checkpoint is a point that can be defined in the graphic editor (draw tool), in the checkpoints function. The function needs the address (which is obtained with the offset operator) in memory of two variables in which the x and y values of the checkpoint will be stored. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be used as if they were from the first file (the one with the code 0). Example Program: PROGRAM example_get_point; GLOBAL file1; point=1; x_point; y_point; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(0, 4); graph=101; LOOP IF (fget_dist(x, y, x_point, y_point)<6) IF (point++==50) point=1; END END // Store the checkpoint coordinate values in x_point and y_point get_point(file1, 4,point, offset x_point, offset y_point); angle=fget_angle(x, y, x_point, y_point); advance(6); FRAME; END END - In this example, an image of a circuit is displayed on the screen. On this map there are 50 checkpoints defined {from 1 to 50) in the circuit. The main process appears as a triangle that travels throughout the circuit. The number of the checkpoint is stored in the local variable point which at the beginning is set to 1. The coordinates of each checkpoint, obtained with the get_point() function, are saved in the x_point and y_point variables and are used to make the process move to that position with the fget_angle() functions (to obtain the local angle variable) and advance() (to advance 6 points in that direction). The distance to the next checkpoint is checked using the fget_dist() function, if that point number is detected as being less than 6 pixels away, then the triangle is directed onto the next point. When point number 50 is reached it will reset back to point 1. This function returns the exact coordinates that the checkpoints were placed inside the graphic, without regard to how the graphic is displayed (zoomed,rotated,etc). To obtain the position of a checkpoint in an graphic that is zoomed or rotated, and relative to the coordinates of screen (and not of the original graphic) you must use the get_real_point() function. ---See: Checkpoints - get_real_point() - get_pixel() get_real_point() get_real_point( , , ) Returns: Sets the coordinates of the checkpoint to the variables which offset indicated as the two last parameters. Description: This function returns where a checkpoint of the main processes graphic is at a particular moment in the coordinates system used by the process (See local variable ctype ), evaluating the original location of the point, the current coordinates of the process, its size, angle, etc. A checkpoint is a point that can be defined in the graphics editor (drawing tool), in the options given to the function. The function needs the address (which is obtained with the offset operator) in memory of two variables in which the x and y values of the checkpoint will be stored. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be used as if they were from the first file (the one with the code 0). Example program: PROGRAM example_get_real_point; PRIVATE point; x_point; y_point; BEGIN load_fpg(\"help/help.fpg\"); graph=4; x=160; y=100; LOOP FROM point=1 TO 50; // We take the coordinates where there at this moment the checkpoint is get_real_point(point, offset x_point, offset y_point); cross(x_point, y_point, 200); END angle+=1000; FRAME; END END PROCESS cross(x, y, graph); BEGIN FRAME; END - In the example a circuit that rotates on the screen is defined as the graphic of the main process . This graphic has 50 defined checkpoints numbered from 1 to 50. The program stays inside of a loop, rotates this graphic with the angle command,and creating 50 processes of a cross type, one for each of the 50 checkpoints of the graphic. You can check how the relative position of two points doesn't change though the graphic of the circuit rotates. This function is usually used to locate some important key points of a graphic. For example, in a process in which the graphic is a man with a gun that can be escalated, rotated or that has some animations, a checkpoint could be defined in the cannon of the gun to know at each moment where the bullets must go the case of gun being fired. If the original graphic was inside of a scroll region (See start_scroll() ) the given coordinates will be relative to to the scroll region. The get_point() function returns the position where a checkpoint of the graphic was placed initially, instead of its current position like get_real_point() . ---See: Checkpoints - get_point() - get_pixel() graphic_info() graphic_info( , , ) Returns: The information that was requested about the graphic. Description: It returns the information of a graphic for in a file that was requested. Information: The returned value will depend on the third parameter information that is passed to the function as follows: g_wide - The original width of the graphic g_height - The original height of the graphic. g_x_center - The (x coordinate} of the centre of the graphic. g_y_center - The y coordinate of the centre of the graphic. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be treated as if they were loaded from the first file (code 0). Example program: PROGRAM example_graphic_info; PRIVATE file1; myheight; mywidth; x_centre; y_centre; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); graph=100; x=160; y=100; // We take the information about the height of the graphic myheight = graphic_info(file1, 100, g_height); // We take the information about the width of the graphic mywidth = graphic_info(file1, 100, g_wide); // We take the information about the coordinate x of the centre of the graphic x_centre = graphic_info(file1, 100, g_x_center); // We take the information about the coordinate & of the centre of the graphic y_centre = graphic_info(file1, 100, g_y_center); write(0, 0, 0, 0, \"Height of the graphic:\"); write_int(0, 0, 10, 0, offset myheight); write(0, 0, 20, 0, \"Width of the graphic:\"); write_int(0, 0, 30, 0, offset mywidth); write(0, 0, 40, 0, \"Horizontal centre of the graphic:\"); write_int(0, 0, 50, 0, offset x_centre); write(0, 0, 60, 0, \"Vertical centre of the graphic:\"); write_int(0, 0, 70, 0, offset y_centre); LOOP FRAME; END END - In this example, the program fetches the information about graphic number 100 in the help.fpg file, which is a ball of 32 pixels square and has a centre of (16, 16). To obtain this information, it makes 4 calls to the graphic_info() function, each time passing a different ( ) argument (g_wide, g_height, etc) to get the required values. ---See: g_width - g_height - g_x_center - g_y_center is_playing_cd() is_playing_cd() Returns: True (1) if the CD is playing, or false (0) if it isn't. Description: This function is used to determine if the CD is playing a track. Returns True (an odd number) if the CD is playing, or False (an even number) if no track is playing. Normally this is used to play a song in a continuous loop as shown in this example. Example program: PROGRAM example_is_playing_cd; BEGIN play_cd(1, 0); LOOP IF (NOT is_playing_cd) // Checks if the song has finished play_cd(1, 0); END FRAME; END END - In this example (which you need to have an audio Compact disk inserted in your CD-ROM drive), The play_cd() function is used to play the first song of the CD. In a loop, a check is made to see if the song has finished so it can restart it. The volume of the cd-audio can be controlled with the setup structure and the set_volume() function. ---See: play_cd() - stop_cd() - set_volume() - Setup structure key() key( ) Returns: True (1) if the key is pressed and false (0) if it is not. Description: Returns true (an odd number) if the key (indicated as the parameter) is pressed, and returns false if not. The parameter is usually specified by the key name proceeded by the _ symbol. For example, to read the [ A ] key, the command used would be key(_a) . View the key codes to see the complete list of keytable codes that can be used as the parameter of the key() function. Example program: PROGRAM example_key; BEGIN LOOP delete_text(all_text); IF (key(_space)) // Check if the space bar is being pressed write(0, 0, 0, 0, \"You are pressing the [SPACE] key.\"); ELSE write(0, 0, 0, 0, \"You are not pressing the [SPACE] key.\"); END FRAME; END END - In this example, a message is displayed, dependant on whether the SPACE key is being pressed or not. There are three predefined global variables that can be used to control the keytable. These are: scan_code - Gets the Code of the last key that has been pressed. This is a numeric value that corresponds directly with the constants of key codes used as parameters of the key() function. ascii - the ASCII code of the last key pressed. shift_state - Variable that indicates a number in the function for the special keys (shift, alt, control, ...) which are pressed at that moment. ---See: key codes - scan_code - ascii - shift_state let_me_alone() let_me_alone() Description: Sends a s_kill signal to every process (except the one that called this function) to stop processing. This function is normally called from the main process when a game has finished, to eliminate every process (shots,enemies, etc.) that still remain active and recover the control of the program. A call to let_me_alone() could always be swapped for a group of calls to the signal() function with the s_kill signal, but to do this you need to know the types of the processes that you wish to eliminate or their identifier codes . Example program: PROGRAM example_let_me_alone; BEGIN load_fpg(\"help/help.fpg\"); ball (160, 100, 100); write (0, 160, 0, 1, \"Press [SPACE] to eliminate the process\"); WHILE (NOT key (_space)) FRAME; END let_me_alone(); // The other processes are eliminated LOOP FRAME; END END PROCESS ball(x, y, graph) BEGIN LOOP FRAME; END END - In this example a ball process is created, and the program waits for the space bar to be pressed. At this point, the let_me_alone() function is called, which eliminates every process except the main one, which kills the ball process. If you wish to check the processes that are active in a program at any given moment, the debugger may be accessed by pressing the [ F12 ] key. The exit() function is used to finish a program instantly, returning to the operating system. ---See: exit() - signal() load() load( , ) Description: Loads the raw data from a file into the computer memory. To do this, the function requires the name of the file and the address of the data within the program, this can be a variable, array or structure and can be obtained by using the OFFSET ) operator. The address of the data must be the same as was used to save the data using the save() function. The name of the file can be any legal MS-DOS 8:3 filename (the same limitations as fpg and PRG filenames). It is important that the file you wish to read data from exists, as an error will occur if you try to load a nonexistent file (even if this can be ignored, continuing the program's execution). Example program: PROGRAM example_load; PRIVATE table[9]; counter; BEGIN write (0, 0, 0, 0, \"Press [ENTER] to delete the data from memory.\"); write (0, 0, 10, 0, \"Press [SPACE] to load the data from disk.\"); write (0, 0, 30, 0, \"Current values of the data:\"); FROM counter=0 TO 9; table[counter]=rand(0, 100); write_int(0, 0, 40+(counter*10), 0, offset table[counter]); END save(\"help.dat\", offset table, sizeof(table)); LOOP IF (key(_enter)) FROM counter=0 TO 9; table[counter]=0; END END IF (key(_space)) load(\"help.dat\", offset table); // The disk data are loaded END FRAME; END END - In this example, an array of 10 values are created, and filled with random values. This array is then saved to disk using the save() function. When the ENTER key is pressed, the values in the array are reset to 0. When the SPACE key is pressed, the values are recovered into the array using the load() function. ---See: save() - sizeof() load_fnt() load_fnt( ) Returns: The code of the loaded font. Description: Loads a font file (*.FNT) from the disk. The function returns the font code that can be used by the write() and write_int() functions to write to the screen. The path can be specified with the font. However, it is not necessary to do so if the file resides in the same directory as the executable or the default font directory ( \\FNT ). The new font must have the same palette as the game is currently using for it to be displayed correctly. Otherwise, the colours may appear incorrectly. Example program: PROGRAM example_load_fnt; PRIVATE font1; BEGIN font1=load_fnt(\"help/help.fnt\"); // The font for the text is loaded write(0, 160, 0, 1, \"Text written with the system font.\"); write(font1, 160, 10, 1, \"FONT LOADED FROM DISK\"); LOOP FRAME; END END - In this example, a font is loaded with the load_fnt() function and then two messages are written with different fonts. The first one with the system font, and the second one loaded from the help.fnt file. To unload the font from memory (freeing up the space that the font occupies), the unload_fnt() function must be called, using the font code as the parameter. It is not necessary to unload the font unless you need the space to load other graphics or fonts, since the system will automatically free up the font when the program has terminated. ---See: unload_fnt() - write() - write_int() - load_pal() load_fpg() load_fpg( ) Returns: The code of the fpg file that was loaded. Description: Loads an *.FPG file from disk. An FPG file may contain anywhere from 0 to 999 graphic images. Every image in in the file will have a numeric code, this is the graphic code (a number that ranges from 1 to 999 ) that is used to identify the graphic inside the file. It is possible to load as many graphics FPG files as necessary, as long as there is available memory (this function has to be called several times to load several files). The function returns the file code that can be used by many functions that require a graphic. For that, it is necessary to indicate the file code in which the graphic is and the graphics code inside the file. The path can be specified with the graphics file. However, it is not necessary to do so if the file resides in the same directory as the executable or the default FPG directory ( \\FPG ). When different files have been loaded, take into account that if they have different palettes, every palette has to be activated previously with the load_pal() function, indicating the (FPG) file name as a parameter before using its graphics. Example program: PROGRAM example_load_fpg; PRIVATE file1; BEGIN file1 = load_fpg(\"help/help.fpg\"); // The graphics' file is loaded put_screen(file1, 1); // We use graphic 1 of the file write(0, 160, 0, 1, \"Graphics' file successfully loaded\"); LOOP FRAME; END END - In this example, the FPG file that is going to be used in the program is loaded using the load_fpg() function. Then, graphic number 1 is put as a screen background (with the put_screen() function). To unload the graphics file ( FPG ) from memory (freeing up the space that the graphics file occupies), the unload_fpg() function must be called, using the file code as the parameter. It is not necessary to unload file unless you need the space to load other graphics or fonts, since the system will automatically unload the file when the program has terminated. ---See: unload_fpg() - load_map/pcx() - load_pal() - file load_pal() load_pal( ) Description: Loads a colour palette from disk (from a PAL, FPG, MAP or FNT file) defining the 256 colours displayed on the screen. From that moment, the game will be seen with the colours set indicated by that palette. If when the palette was loaded, the program had already another one assigned, a fading of the screen colours to black will be carried out. Then, the new colour palette will gradually appear in the following frames of the game. The file path may be specified with the palette, although this is not necessary if the file is in the same directory as the executable, or in the default directory (depending on file type) ( \\PAL, \\FPG, \\MAP or \\FNT ). The program will automatically read the palette of the first of these types of files loaded in the program, even if the load_pal() function is not used. Then, this function will be used when the program uses several different palettes to change from one to another. Example program: PROGRAM example_load_pal; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 160, 0, 1, \"Press [SPACE] to load a different palette.\"); write(0, 160, 10, 1, \"Press [ENTER] to load the original palette.\"); LOOP IF (key(_space)) load_pal(\"help/help.pal\"); // The palette of a .pal file is loaded END IF (key(_enter)) load_pal(\"help/help.fpg\"); // The palette of a .fpg file is loaded END FRAME; END END - In this example, a graphics file is loaded ( FPG ) and an image is placed on the background, along with the necessary text messages. The main program is a small loop, testing for the space and enter keys. When a key is pressed, a palette is loaded. The help2.pal file is loaded when the spacebar is pressed, and the original palette is loaded (from the help.fpg file) when the ENTER key is pressed. A palette can not be unloaded from the computer's memory, since only one palette can be loaded at any time. ---See: load_map/pcx() - load_fpg() - load_fnt() load_pcm() / load_wav() load_pcm( , ) load_wav( , ) Returns: The sound code loaded. Description: Loads a PCM or WAV sound effect from disk. The filename must be specified as the first parameter, and the second parameter replaced by either a 1 if the sound must indefinitely be repeated (looped), or 0 if it should played only once (this refers to the sound when played using the sound() function). The function returns the sound code that is required by the sound() function to play the sound through a channel. The path can be specified with the sound file. However, it is not necessary to do so if the file resides in the same directory as the executable or the default sounds directory ( \\PCM or \\WAV ). Example program: PROGRAM example_load_pcm; PRIVATE id_sound; BEGIN id_sound = load_pcm(\"help/help.pcm\", 0); // Loads a sound of the hard disk write(0, 160, 0, 1, \"Press [SPACE] to play the sound.\"); LOOP IF (scan_code==_space) sound(id_sound, 100, 256); END FRAME; END END - In this example, a sound is loaded with the load_pcm() function. Then, every time the spacebar is pressed, that sound is played using the sound() function. The unload_pcm() and unload_wav() functions allow us to free up the computer's memory occupied by the sound when it is not going to be used any longer. For that, you require the sound code in order to know which sound we want to unload from the memory. It is not necessary to unload the sound from memory before finishing the program, since the system will do it automatically. ---See: unload_pcm/wav() - sound() - change_sound() - Setup structure map_block_copy() map_block_copy( , , , , , , , , ) Description: The map_block_copy() function allows us to transfer a rectangular block from a graphic to another one. The graphic from which the rectangular region is taken is called the and the graphic in which the block will be copied to is called the . The parameters are the following ones, in order: - Both graphics must come from the same graphics file FPG . The file code must be specified as first parameter (see load_fpg() ). The graphics loaded with the load_map() or load_pcx() functions (or created with new_map() function) will be used as if they were from the first file (file code 0). - graphic code in which the block is going to be put. , - x and y coordinates at which the copied block is to be placed inside the destination graphic. - graphic code from which the copied block is going to be taken. , - starting coordinates of the block inside the origin graphic. , - dimensions of the block that is going to be copied. This function will modify the indicated graphic, but only the copy that has been loaded into memory. The original graphic that is stored in the FPG , MAP or (PCX) files on disk will remain unchanged . If you wish to recover the original graphics, then you must unload the graphic (with unload_fpg() , unload_map() or unload_pcx() ) and then, load it in again to obtain the unchanged version. Example program: PROGRAM example_map_block_copy; PRIVATE x_destination, y_destination; x_origin, y_origin; map_width, map_height; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 320); y_destination=rand(0, 200); map_width=rand(1, 32); map_height=rand(1, 32); x_origin=rand(0, 32-map_width); y_origin=rand(0, 32-map_height); map_block_copy(file1, 1, x_destination, y_destination, 100, x_origin, y_origin, map_width, map_height); FRAME; angle+=1000; END END - In this example, an FPG graphics file is loaded, and a graph (graphic number 1) is placed in the centre of the screen and continuously rotated. Within the main loop, a ball graphic (graphic number 100) is copied inside the destination graphic (number 1) at some randomly chosen coordinates. When a graphic is put inside another one that is being used as a scroll region's background, it will not automatically appear on screen unless the refresh_scroll() function is used. ---See: map_xput() - map_put() - map_put_pixel() map_get_pixel() map_get_pixel( , , , ) Returns: The colour of the point (0..255). Description: This function allows us to obtain the colour of a graphic's specific pixel. For this, the in which the graphic is stored, the inside the file and the x and y coordinates of the graphic where you wish to obtain the colour are needed to be passed as parameters. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() function) are treated as if they were loaded from the first FPG file (code 0). Example program: PROGRAM example_map_get_pixel; PRIVATE file1; figure; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(0, 7); mouse.graph=200; write(0, 0, 0, 0, \"FIGURE:\"); write_int(0, 42, 0, 0, offset figure); LOOP // We take the colour of the bitmap's pixel figure = map_get_pixel(file1, 8, mouse.x, mouse.y); FRAME; END END - In this example, 6 different geometrical figures are drawn on the screen in the same colour. The mouse graphic is defined as a little cross. The image displayed on screen directly corresponds to another graphic (graphic number 8 in the FPG file), which has the same figures but every one is in a different colour (the first one of colour 1, the second one of colour 2, etc.). In the main loop, the map_get_pixel() function is used to get a colour from graph 8, at the mouse's x and y coordinates. This value will be shown in the upper left corner of the screen and when the mouse is over one of the shapes, will show a value from 1 to 6. This function is normally used to detect zones inside a graphic. This technique is called using hardness maps and allows us to use two different graphics, one with the picture and the second with the zones to detect, painted using colours. ---See: get_pixel() - map_put_pixel() map_put() map_put( , , , , ) Description: Puts a graphic inside another one. The graphic that is going to be copied is called and the graphic in which the is to be copied is called the . The function allows us to copy a graphic (origin) inside another one (destination). Both graphics must be in the same FPG file. The parameters are as follows, in order: - The file code of the FPG file that contains both graphics. Graphics loaded with the load_map() or load_pcx() function (or created with new_map() function) will be used as if they were loaded from the first file (code 0). - code of the graphic inside which the other one is going to be copied. - code of the graphic that is going to be copied into the destination. , - coordinates inside the destination graphic where the origin graphic is going to be copied. The centre (or control point number 0) of the origin graphic will be located at these coordinates. This function will modify the , but only the copy of it in memory. The original graphic that is stored in the FPG or MAP files on the disk will remain unchanged . If you wish to recover the original unchanged graphic you should unload the file from memory (using unload_fpg() unload_map() or unload_pcx() functions) and then load it back again. Example program: PROGRAM example_map_put; PRIVATE x_destination; y_destination; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 320); y_destination=rand(0, 200); map_put(file1, 1, 100, x_destination, y_destination); angle+=1000; FRAME; END END - In the example, graphic number 1 is put at the centre of the screen. In every step of the main loop, this graphic rotates and a graphic number 100 (a ball) is put inside the graphic 1 (the central graphic) with the map_put() function. The map_xput() function is a version a little more complex than the map_put() function, but with much more utilities. Thus, the latter allows us, moreover, to put rotated, scaled, mirror and transparent graphics. The map_block_copy() function must be used to put a part of a graphic (instead of the full graphic) inside another one. Note: When the map_put() function (or any other similar) is used to modify a graphic that is being used as background of a scroll window, it is possible that the graphic you have put does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_xput() - map_put_pixel() - refresh_scroll() - map_block_copy() map_put_pixel() map_put_pixel( , , , , ) Description: Allows us to modify the colour of a specific pixel of a graphic. For that, the where the graphic is stored, the inside the file and the ( x , y ) coordinates of the pixel whose is intended to set are required. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). This function will modify the indicated graphic, but only its copy that has been loaded in the computer's memory. The original graphic, that is stored in the FPG or MAP files of the disk, will remain unchangeable . For that, if at a specific moment of the game the aim is to recover the original state of the graphic, it will be necessary to unload it from the memory (with unload_fpg() , unload_map() or unload_pcx() functions) and then, load it again. Example program: PROGRAM example_map_put_pixel; PRIVATE file1; coord_x; coord_y; colour; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=5; x=160; y=100; size=180; LOOP coord_x=rand(0, 199); coord_y=rand(0, 199); colour=rand(0, 15); // Points are placed in the graphic number 5 of the file1 map_put_pixel(file1, 5, coord_x, coord_y, colour); angle+=2000; FRAME; END END - In the example, graphic number 5 is put at the centre of the screen, continuously rotating. This graphic is a completely black background. For that reason, nothing will initially be seen on screen. But then, in every step of the loop, pixels of a colour randomly chosen between 0 and 15 (greys) are put in this graphic, at a pair of coordinates randomly chosen too. These pixels are put using the map_put_pixel() function. Notice how it seems that there are more and more pixels rotating on screen, when the only thing that really rotates is graphic number 5. The map_put() or map_xput() functions may be used to put a full graphic inside another one (and not only at one pixel). The map_block_copy() function may be used to put just a part of a graphic inside another one. Note: When the map_put_pixel() function is used to put a pixel in a graphic that is being used as background of a scroll window, it is possible that this pixel does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_put() - map_xput() - refresh_scroll() - map_block_copy() map_xput() map_xput( , , , , , , , ) Description: Extended version of the function map_put() . Puts a graphic inside another one. The graphic that is going to be copied is called and the destination graphic is that inside which the origin will be copied. This function allows us to copy a graphic (origin) inside another one (destination). Both graphics must be in the same file. The parameters are the following ones, in order: - file code with the graphics library that contains both graphics. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). - code of the graphic inside which the other one is going to be put. - code of the graphic that is going to be copied in the destination. , - coordinates inside the destination graphic where the aim is to put the origin graphic. The origin graphic is going to be copied at these coordinates, from its upper left corner. - angle (in degree thousandths) in which the origin graphic is going to be copied; the normal angle is 0 . - size (in percentages) in which the original graphic is going to be copied (the normal size is 100 ). - Indicates the mirrors and transparencies with which the original graphic will be copied in the destination; the values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Horizontal transparencies and mirror. 6 -vertical transparencies and mirror. 7 -Transparencies, horizontal and vertical mirror. This function will modify the indicated graphic, but only its copy that has been loaded in the computer's memory. The original graphic, that is stored in the FPG or MAP or (PCX) files of the disk, will remain unchangeable . For that, if at a specific moment of the game the aim is to recover the original state of the graphic, it will be necessary to unload it from the memory (with unload_fpg() , unload_map() or unload_pcx() ) and then, load it again. Example program: PROGRAM example_map_xput; PRIVATE x_destination; y_destination; file1; angle1; size1; flags1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 319); y_destination=rand(0, 199); angle1=rand(-pi, pi); size1=rand(10, 200); flags1=rand(0, 7); map_xput(file1, 1, 101, x_destination, y_destination, angle1, size1, flags1); angle+=2000; FRAME; END END - In the example, graphic 1 is put at the centre of the screen, continuously rotating (this graphic is a decorative background in grey tonalities). In every step of the loop, a triangle-shaped graphic (with number 100) will be put inside graphic 1. This new graphic will be put with coordinates, angle, size and flags (see flags variable) randomly chosen. Notice how brown triangles with different applied effects are continuously appearing in the background graphic. The map_xput() function is a version a little more complex than the map_put() function, which is easier to use when it is not required to put rotated, scaled, mirror and transparent graphics. The map_block_copy() function must be used to put a part of a graphic (instead of the full graphic) inside another one. Note: When the map_put() function (or any other similar) is used to modify a graphic that is being used as background of a scroll window, it is possible that the graphic you have put does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_put() - map_put_pixel() - refresh_scroll() - map_block_copy() move_scroll() move_scroll( ) Description: Forces to scroll automatically and immediately. This function is rather advanced and, for that reason, it could be difficult to understand its purpose. As a parameter, the function requires the from 0 to 9 that was indicated in the start_scroll() function as first parameter when the scroll started. This function is used when a scroll region is automatically controlled, as the camera field of the scroll structure corresponding to the identifier of a process has been defined. The purpose is to force the ( x0 , y0 , x1 and y1 ) values of that structure to be updated. If this function is not used, these values won't be updated until the following game's frame. This means that when a scroll is automatically controlled and another process needs to know the value of the coordinates of that scroll before the next frame (normally to be located in a position in keeping with the background movement), do as follows: 1 - The scroll starts with start_scroll() . 2 - The process that will be used as camera is created and its identifying code is put in the camera field of the scroll structure . 3 - A very high priority must be set for this process, for it to run before the rest of the processes (putting in its priority local variable a positive whole value like, for instance, 100). 4 - The move_scroll() function will be called just before the FRAME statement of the process' loop used as camera. Thus, you will guarantee the previous execution of this process and, just at the end, the updating of the values ( x0 , y0 , x1 and y1 ) of the scroll structure , so the rest of the processes may use these variables already updated. The most widespread use of this function is when you want to have more than two backgrounds in a scroll window. For that, a series of processes simulating a third or fourth plane are created. The position of their coordinates will depend on the exact position of the scroll in every frame. A program doing so is shown below. Example program: PROGRAM example_move_scroll; PRIVATE file1; counter; BEGIN set_fps(100, 0); file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); scroll.camera=id; priority=100; write(0, 160, 0, 1, \"Use the right and left cursors to move\"); graph=101; ctype=c_scroll; LOOP if (key(_right)) x+=2; flags=0; END if (key(_left)) x-=2; flags=1; END move_scroll(0); // Updates the scroll structure[] FRAME; END END - This example starts a scroll at full screen with two planes. Then, it moves a triangle to the right and left with the cursors. This process will function as a scroll camera, automatically focusing the vision on it (by putting scroll.camera= id ; ). But, at the same time, it creates a total of 40 processes (from -2000 to 2000, every 100 pixels) with the picture of a vertical band with moving colours as if they were a third scroll plane (processes of the type movable_process ). For that, it is important that their z coordinate is greater than the rest of the processes ( z=100; ) and that the priority of the process that controls the camera is higher than ( priority=100; ) and that the latter uses the move_scroll() function before every frame ( FRAME; ). The processes simulated by the third plane ( movable_process ), place their x coordinate at a point depending on the scroll's x and its original position. The difference lies in the fact that, if move_scroll() had not been used, the processes, by using the scroll.x0 variable without being updated, would move with a certain slowness that detracted from the credibility of the game. ---See: start_scroll() - Scroll structure - Priority - Z move_text() move_text( , , ) Description: Moves a text towards other screen coordinates. The ** text identifier and the ( x , y**) screen coordinates towards which the text must be moved are specified as parameters. The identifier of the text is a numeric code returned by the write() and write_int() functions when they are required to write a text. The centreing code specified in the write() or write_int() functions will remain when this function is used. The specified coordinates always dealt with the screen and may be inside it or out from it. It is necessary to use the text_z global variable to modify the {z coordinate of the texts} (the depth plane in which they appear). Example program: PROGRAM example_move_text; PRIVATE id_text1; id_text2; coord_x; coord_y; angle1; BEGIN id_text1=write(0, 160, 100, 4, \"MOVING TEXT\"); id_text2=write(0, 160, 100, 4, \"MOVE THE MOUSE\"); LOOP coord_x=160+get_distx(angle1, 100); coord_y=100+get_disty(angle1, 90); // We move the texts move_text(id_text1, coord_x, coord_y); move_text(id_text2, mouse.x, mouse.y); angle1+=1000; FRAME; END END - In the example, two texts are displayed at the centre of the screen with the write() function. This function returns the identifiers of those texts, that are stored in the id_text1 and id_text2 variables. In every step of the loop, the first text moves along a circular path obtained by increasing an angle ( angle1 ) and using the get_distx() and get_disty() functions. The second text will be placed at the coordinates of the mouse pointer. Both texts move in every frame with the move_text() function. To delete a text definitively, the text identifier is also required, and the delete_text() function must be used for that. ---See: write() - write_int() - delete_text() near_angle() near_angle( , , ) Returns: A new angle nearer to the final angle. Description: Brings an angle nearer another one at the given increment. The function returns the new angle. It is used when the aim is that an angle ( ) gradually varies until it becomes another angle ( ). For that, the function needs the original angle, the final angle and the angular increment that is going to be added to or subtracted from the original angle. Keep in mind that all the angles are specified in degree thousandths. The angular increment is but a small angle (such as one degree ( 1000 ) or five ( 5000 ). Example program: PROGRAM example_near_angle; PRIVATE angle2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); mouse.graph=200; graph=101; write(0, 160, 200, 7, \"Move the mouse cursor\"); LOOP angle2=fget_angle(x, y, mouse.x, mouse.y); // Brings the current angle closer to the final one in 10 degrees at the most angle = near_angle(angle, angle2, 10000); advance(6); FRAME; END END - In the example, the mouse cursor is defined as a little cross that can be moved by the user. The main program defines its graphic as a triangle ( graph=101; ) that, in every loop's iteration, obtains the angle towards the mouse cursor with the fget_angle() function. Then, it modifies its angle to move 10 degrees (10000) at the most towards the cursor angle, using the near_angle() function. Finally, it advances 6 points in that direction by using the advance() function. Notice how the triangle continuously pursues the mouse cursor without making any abrupt turn (bigger than 10 degrees). ---See: Use of the angles in the language - angle - get_angle() - fget_angle() out_region() out_region( , ) Returns: True if the process is outside of the region or False in the opposite case. Description: This function determines whether a process is out of a screen region. For that, the function requires the identifying code of the process and a region number. The screen regions can be defined with the define_region() function and they are simply rectangular zones of screen. Region number 0 can not be defined, as it will always be equivalent to the entire screen. Therefore, if 0 is specified as a second parameter, this function determines whether a process is out of the screen (if it is not seen). In case that the process' graphic is out of the specified region, the function returns True (an odd number). Otherwise, if the graphic is seen in that region, even partially, the function returns False (any even number). The process whose identifying code is indicated must have its graphic correctly defined (normally in its graph variable). Otherwise, the system will produce an error, since it is not possible to calculate the dimensions of a graphic if the process lacks it. Example program: PROGRAM example_out_region; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); y=100; x=160; graph=101; LOOP advance(8); IF (out_region(id, 0)) // Check for off screen x=160; y=100; angle=rand(-pi, pi); END FRAME; END END - In the example, a background graphic is put and the main program creates a triangle-shaped graphic at the centre of the screen with an angle randomly chosen. In every step of the loop, the triangle advances and it is checked whether it is still present on the screen (region 0) with the out_region() function. If so, it is put once again at the centre of the screen with another angle, also randomly chosen. ---See: define_region() - region - codes identifiers play_cd() play_cd( , ) Description: Starts playing a cd-audio track. The track number (from 1 to the number of songs contained on the cd) must be indicated. The way to do it is as follows: Mode. 0 - Play the song and then stop. 1 - Play this song and then the following ones. Example program: PROGRAM example_play_cd; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to turn the CD on.\"); LOOP IF (scan_code==_space) play_cd(1, 1); // It plays the 1st. song followed by all remaining tracks. END FRAME; END END - In the previous example (for which it is necessary to have a music Compact disc inside the CD-ROM device) an information message is displayed and in every iteration of the loop it is checked whether the spacebar was pressed to play the first song with the play_cd() function. To have a song indefinitely playing, a loop must be implemented, using the is_playing_cd() function to determine when the song is over. The cd-audio reproduction volume can be controlled with the setup structure and the set_volume() function. ---See: is_playing_cd() - stop_cd() - set_volume() - Setup structure pow() pow( , ) Returns: The first expression raised to the second. Description: Calculates the result when the first expression is raised to the second one. For instance, pow(3, 2) will return 9 , which is 3 squared, 3\u00b2 , or 3*3 . Example program: PROGRAM example_pow; GLOBAL values[15]; n; BEGIN FROM n=0 TO 15; values[n]=rand(-100, 100); write_int(0, 0, n*10, 0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to square these numbers\"); LOOP IF (scan_code==_space) FROM n=0 TO 15; values[n] = pow(values[n], 2); // Square the values (value\u00b2 or value ^ 2) END END FRAME; END END - This program will display a list of numbers randomly chosen between -100 and 100 on the screen. When the spacebar is pressed, these numbers will square. Take into account that in the language it is only possible to use integers within the ( min_int ... max_int ) range . Therefore, when the result of the function exceeds this range, incorrect results will be shown . In this case, the system won't produce an error, so care must be taken. ---See: Expression put() put( , , , ) Description: Puts a graphic in the screen background. The function requires the file code in which the graphic is stored, the graphic code inside the same file and the ( x , y ) coordinates at which the graphic is intended to be put. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). If the centre graphic was not specified (setting its control point number 0 from the painting tool), the coordinates will be referred to the position on the screen in which the graphic centre will be located. The graphics displayed on the screen background like this will be within the game's display under all the processes, scroll regions, texts, etc. If the aim is to have a graphic over some others, it must be created as a new process and its z variable must be established, indicating the priority of its display. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put; PRIVATE file1; coord_x; coord_y; BEGIN file1=load_fpg(\"help/help.fpg\"); LOOP coord_x=rand(0, 319); coord_y=rand(0, 199); put(file1, 100, coord_x, coord_y); // The graphic 100 is \"put\". FRAME; END END - In the example, the file with the graphics is loaded and in every iteration of the loop graphic number 100 (a ball) is put, with the put() function, at random coordinates (randomly chosen with the rand() function). If the graphic that is intended to be put is merely a background screen, it is easier to use the put_screen() function, since it does not require the screen coordinates, because it will automatically centre the graphic on the screen. The xput() function is a version a little more complex than the put() function, but with much more utilities since, at the same time, it allows us to put rotated, scaled, mirror and transparent graphics. To put a graphic inside another one (instead of in the screen background), the map_put() or map_xput() functions must be used. ---See: put_screen() - xput() - map_put() - map_xput() - put_pixel() put_pixel() put_pixel( , , ) Description: Plots a pixel of the specified colour at the indicated coordinates ( x , y ) on the background screen. The pixels put with this function in the background screen will be displayed in the game {below all the processes, scroll regions, texts, etc.} If the aim is to see a pixel over other graphics, you must create a new process, assigning the picture of a point (in its graph variable) as a graphic and fixing its z variable with the priority of its printing. To clear the background screen, the clear_screen() function must be used. Example program: PROGRAM example_put_pixel; PRIVATE x_pixel; y_pixel; colour; BEGIN LOOP x_pixel=rand(0, 319); y_pixel=rand(0, 199); colour=rand(0, 15); // The pixels are put in the background screen at random put_pixel(x_pixel, y_pixel, colour); FRAME; END END - In the example, in every step of the loop the pixels are put with the put_pixel() function, with coordinates and colour chosen at random with the rand() function. To read the colour of a specific background screen colour, the get_pixel() function must be used, returning a number between 0 and 255 corresponding to the order of the colour inside the palette. The put() function must be used to set a graphic on the screen, instead of a simple pixel. It is also possible to set the colour of a pixel in a specific graphic, instead of in the background screen, by using the map_put_pixel() function. ---See: get_pixel() - put() - map_put_pixel() - map_get_pixel() put_screen() put_screen( , ) Description: Establishes the background screen. The function requires the file code in which the graphic is, and the own code of the graphic intended to be displayed in the background screen inside the file. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). The function does not require any coordinate as a parameter since, if the graphic size (in pixels) is different from that of the screen, the former will simply be displayed centred in the latter. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put_screen; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); // Graphic 1 is established as background. LOOP FRAME; END END - In the example, the graphics' file is loaded and a background graphic (contained in the file with the graphic code number 1) is set with the put_screen() function. If the aim is to display a graphic on a specific part of the screen or a graphic that is not centred , the put() may be used. Moreover, the xput() function allows us to display rotated, scaled, mirror and/or transparent graphics in any screen region. ---See: put() - xput() - put_pixel() - clear_screen() rand() rand( , ) Returns: A random numeric value. Description: Returns a random number (chosen at random) between the minimum value and the maximum value , both included. This function is normally used to set all the parameters intended to be varied in a game when it is restarted. For instance, the coordinates of an enemy may be initialised with random numbers, so it may appear in a different position in every game. This function has another utility. Thus, if we want that an action does not always occur, but that it has a certain probability to occur, we normally use a statement of the following type: IF (rand(0, 100)<25) ** // Action ...** END In this case, the action will take place, on average, 25 per cent of the times the IF statement would be executed. The reason for that is that, on obtaining a random number between 0 and 100, this number would be less than 25 in a fourth of times, approximately. Example program: PROGRAM example_rand; PRIVATE table[15]; counter; BEGIN write (0, 0, 192, 0, \"Press [SPACE] to calculate random values.\"); FROM counter=0 TO 15; write_int(0, 0, counter*10, 0, offset table[counter]); END LOOP IF (scan_code==_space) FROM counter=0 TO 15; // Random values between -100 and 100 are chosen table[counter] = rand(-100, 100); END END FRAME; END END - In the example, a table with 16 data (from 0 to 15) is created. In every iteration of the main loop it is checked whether the spacebar has been pressed. If so, the 16 data of the table will be filled with random values between -100 and 100, chosen with the rand() function. By default, the values returned by the rand() function will completely be different in every execution of the program. If we want to have always the same series of numbers, we may use the rand_seed() function, specifying a number behind which the series of numbers returned by the rand() function will always be predetermined. ---See: rand_seed() rand_seed() rand_seed( ) Description: This function sets a seed for the generator of random numbers (the numbers generated by the rand() function). The seed can be any integer within the range ( min_int ... max_int ). If the seed is set, all the numbers generated by the rand() function will be the same in every execution of the program. After having been established an origin seed, the rand() function will return a series of numbers predetermined for this seed. Example program: PROGRAM example_rand_seed; PRIVATE table[15]; counter; BEGIN write (0, 0, 184, 0, \"Press [ENTER] to set 1234 as a seed.\"); write (0, 0, 192, 0, \"Press [SPACE] to calculate random values.\"); FROM counter=0 TO 15; write_int(0, 0, counter*10, 0, offset table[counter]); END LOOP IF (scan_code==_space) FROM counter=0 TO 15; table[counter] = rand(-100, 100); END END IF (scan_code==_enter) rand_seed(1234); // A seed is set to generate the random numbers. END FRAME; END END - In the example, a table with 16 bits of data (from 0 to 15) is created. In every iteration of the main loop, the data will be filled with random values from -100 and 100 (chosen with the rand() function) every time the spacebar is pressed. And when the ENTER key is pressed, then the seed of the random numbers will be defined as 1234 with the rand_seed() function. Notice how, every time the ENTER key is pressed and then, by pressing the space bar, the same series of random numbers (17, 94, -38, ...) is obtained. This series will be different for every possible seed. ---See: rand() refresh_scroll() refresh_scroll( ) Description: This function is used when a graphic that is being used as a background of a scroll region has been modified with the map_put() , map_xput() , map_block_copy() or map_put_pixel() functions, in order to update it. The parameter required by the function is the that was specified when the scroll started with the start_scroll() function. When a graphic that is being used as background of a scroll is modified, it is not automatically updated on the screen. On the contrary, it is necessary to call this function for that purpose. Once the graphic has been modified, it will remain like this during the rest of the program execution, unless the graphic is unloaded from the memory (with unload_fpg() , unload_map() or unload_pcx() functions) and loaded again. In this case, the original state of the graphic will be restored. Example program: PROGRAM example_refresh_scroll; BEGIN load_fpg(\"help/help.fpg\"); start_scroll(0, 0, 103, 102, 0, 15); scroll.camera=id; write(0, 160, 192, 7, \"Press [ENTER] to put a graphic in the scroll.\"); write(0, 160, 200, 7, \"Press [SPACE] to update scroll.\"); LOOP IF (scan_code==_enter) map_put(0, 103, 100, rand(16, 48), rand(16, 48)); END IF (scan_code==_space) refresh_scroll(0); // We refresh the scroll 0. END x+=2; y+=1; FRAME; END END - In the example, a scroll (number 0) is created as a scroll of two planes: the foreground with graphic number 103 and the background with graphic number 102. Inside the main loop, a ball will be displayed over graphic 103 (foreground of the scroll) when the ENTER key is pressed. But it won't appear on-screen, unless we await until the scroll gradually appears on-screen (with graphic 103 already modified), or until the spacebar is pressed. In this case, the call to the refresh_scroll() function will update the scroll window with the graphic already modified. If, in the previous example, the refresh_scroll() function had been called just after the map_put() one, the graphics displayed on the foreground would instantaneously appear by pressing the spacebar. In the example, every time that a ball is displayed, many of them appear. The reason for this is that graphic 103 used as a foreground in the scroll is a small graphic and it is shown on many occasions tile, to fill all the scroll zone. Note: It can be noticed that, if the displaying graphic is at some coordinates out of the screen, it won't be necessary to call this function, because the parts of the scroll that are gradually appearing on-screen are automatically refreshed. ---See: start_scroll() - move_scroll() - Structure scroll reset_fli() reset_fli() Description: This function rewinds an FLI/FLC animation to the beginning. This animation started with the start_fli() function. After having called this function, the animation will entirely be displayed again from the beginning (to display every frame of the animation, you must call the frame_fli() function). The utility of this function deals with the possibility of stopping an animation and repeating it again from the beginning, without unloading it ( end_fli() ) and loading it again. If the aim is to perform an animation indefinitely, restarting when it is over, then it is not necessary to use this function , since it will automatically be done with frame_fli() , if you keep on calling once the animation is over. Only one animation can exist at the same time. Thus, it is not necessary to specify any parameter for this function. Example program: PROGRAM example_reset_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); write(0, 160, 0, 1, \"Press [SPACE] to restart the animation.\"); LOOP frame_fli(); IF (scan_code==_space) reset_fli(); // The animation is initialised END FRAME; END END - In the example, an animation is loaded with the start_fli() function and then, it is indefinitely performed with the frame_fli() function. In the loop, it is checked whether the spacebar has been pressed. If so, the animation is reinitialised with the reset_fli() function. ---See: start_fli() - frame_fli() - end_fli() roll_palette() roll_palette( , , ) Description: Rotates a range of palette colours. This function is used to create movement effects in static graphics, like the effect of flowing water. To use this function, it is first necessary to create graphics that use a range of consecutive colours of the original palette, in a perpetual cycle (for instance, colours ranging from 0 to 15 , painting something with the colours 0, 1, 2, 3, ... , 14, 15, 0, 1, 2, ...). Then, it is necessary to take care that those colours are not used by other graphics that are going to appear on the screen at the same time, if you do not want to implement the effects on them. The increment (third parameter) is normally 1 to perform the rotation in a direction and -1 to perform it in the opposite direction, but other values may be used to perform the colours cycle at higher speed. To perform a cycle of colours from 0 to 15 , it would be necessary to specify 0 as and 16 as . Example program: PROGRAM example_roll_palette; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); write(0, 160, 0, 1, \"Press [SPACE] to rotate the entire palette.\"); LOOP IF (scan_code==_space) roll_palette(0, 256, 1); // The 256 colours rotate. END FRAME; END END - In the example, a multicolour screen is put as background and, inside the program's main loop, the 256 colours of the palette will rotate every time that the spacebar is pressed. To determine the palette which is going to realise the circle of colour, this must be loaded from an file with the function load_pal() . To perform other palette effects without replacing some colours by other ones in cycles, the fade() function must be used. This function allows us to perform many colours fading and saturations at different speeds. There are two simplified versions of this last function that allow us to carry out a fading to black ( fade_off() ) and undo it ( fade_on() ). ---See: set_color() - load_pal() - fade() - fade_off() - fade_on() save() save( , , ) Description: Saves a data block from the program memory to a file in the disk, to recover it later, when it is required, with the load() function. For that, the function requires the file name , the offset (inside the computer memory) of the variable, table or structure stored in the disk (the variable offset is obtained with OFFSET ) and the number of memory positions that this variable occupies (which may be obtained with sizeof ( ) ). It is possible to save several data (variables, tables or structures) if they have consecutively been defined inside the same section ( GLOBAL , LOCAL or PRIVATE ). In this case, the OFFSET of the first variable must be indicated as a second parameter , and the addition of the sizeof() of all the data must be indicated as a third parameter . It is not necessary to specify a path together with the file name. Example program: PROGRAM example_load; PRIVATE table[9]; counter; BEGIN write (0, 0, 0, 0, \"Press [ENTER] to reset the data.\"); write (0, 0, 10, 0, \"Press [SPACE] to load the disk data\"); write (0, 0, 30, 0, \"Current values of the data:\"); FROM counter=0 TO 9; table[counter]=rand(0, 100); write_int(0, 0, 40+(counter*10), 0, offset table[counter]); END save(\"help/help.dat\", offset table, sizeof(table)); // The file is saved. LOOP IF (key(_enter)) FROM counter=0 TO 9; table[counter]=0; END END IF (key(_space)) load(\"help/help.dat\", offset table); END FRAME; END END - At the beginning of the example, a table of 10 positions (from 0 to 9) is created with random values. This table is saved in the disk with the save() function. When the ENTER key is pressed, the table values are reset (the 10 positions are put at 0). When the spacebar is pressed, the table's values stored in the disk are loaded with the load() function. To save the table[9] and the counter variable in the same file, the save() function should have been called in the following way: save(\"help/help.dat\", offset table, sizeof(table)+sizeof(counter)); Do not vary the load statement ( load(\"help.dat\", offset table); ), as it does not require the number of data. The value returned by sizeof() for any variable (like counter ) will always be 1. For a table, this function returns the number of positions that it has. Then, considering that 11 data (10 of the table and 1 of the variable) are going to be saved, the statement to save them could be as follows: {save(\"help/help.dat\", offset table, 11); ---See: load() - OFFSET - sizeof() set_fps() set_fps( , ) Description: This function regulates the speed of the game; it defines how many frames per second will be displayed during the game. By default, the display will be regulated at 18 frames per second, which means that if a process moves a pixel per every ( FRAME ), it will move on-screen at a speed of 18 pixels per second. This function may establish the number of Frames Per Second ( FPS ) from a minimum of 4 to a maximum of 200 ; in general, no more than 24 frames per second are necessary to obtain a fluid and slight movement. The second parameter, maximum number of allowed omissions , is referred to how the program must preferably work when it is executed on a computer fast enough to calculate the required number of frames per second. It works as follows. Number of allowed omissions. 0 - The game will go at a slower speed when it is executed on a computer that is too slow to keep the required frame rate - It will only display the frames per second that the computer has had time to calculate. 1 - If the computer cannot calculate all the frames, it is allowed to occasionally skip a frame to try to keep the game's relative speed. The game movements will become a little more abrupt, but faster. 2 or more - The game is allowed to skip as many consecutive frames as is indicated in this parameter to maintain the original relative speed of the game. For instance, if the number of omissions is set at 4 and in the game a process moved one pixel at a time, in a very slow computer it could move four pixels at a time. Example program: PROGRAM example_set_fps; PRIVATE frames=24; omissions=4; BEGIN load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; write(0, 0, 0, 0, \"Frames per second: Up(+) / Down(-)\"); write_int(0, 0, 10, 0, offset frames); write(0, 0, 20, 0, \"Allowed omissions: Right(+) / Left(-)\"); write_int(0, 0, 30, 0, offset omissions); write(0, 160, 200, 7, \"Use the CURSORS to change the values.\"); LOOP // The number of frames per second is chosen set_fps(frames, omissions); IF (key(_up) AND frames<200) frames++; END IF (key(_down) AND frames>4) frames--; END IF (key(_right) AND omissions<20) omissions++; END IF (key(_left) AND omissions>0) omissions--; END angle+=4000; FRAME; END END - In the example, the necessary messages are displayed and the main process creates a graphic, which is indefinitely rotating at the centre of the screen. In every step of the loop the cursor keys are detected, the number of frames per second ( frames ) is changed with up/down and the maximum number of allowed omissions is changed with right/left . At the beginning of every iteration of the loop, the speed is set with the set_fps() function, according to the values of both variables. Note: The global variable fps monitors the number of frames per second which is being reached in the program. ---See: FRAME - max_process_time - set_mode() - fps set_mode() set_mode( ) Description: Establishes a new video mode for the game execution. The allowed videomodes that may be specified as a parameter are the following ones: m320x200 - VGA standard m320x240 - X Mode m320x400 - X Mode m360x240 - X Mode m360x360 - X Mode m376x282 - X Mode m640x400 - SVGA VESA m640x480 - SVGA VESA m800x600 - SVGA VESA m1024x768 - SVGA VESA When a change of the videomode in the program is made, a fading to black (of the program's colours palette) will automatically be performed and in the following displays, the colours palette will gradually be restored. That is to say, set_mode() always performs a fade_off() just before changing the videomode and a fade_on() just after having changed it. By default, all the programs start with the 320 by 200 pixel activated mode ( set_mode(m320x200) ). Example program: PROGRAM example_set_mode; PRIVATE modes[]= m320x240, m640x480, m800x600, m1024x768; videomode=0; BEGIN load_fpg(\"help/help.fpg\"); write (0, 0, 0, 0, \"Press [SPACE] to change the videomode\"); LOOP IF (scan_code==_space) videomode=videomode+1; IF (videomode==4) videomode=0; END set_mode(modes[videomode]); END FRAME; END END - In the example, a screen background and an explanatory text are displayed. In the iteration of the main loop, if the space bar is pressed, a new videomode will be activated with the set_mode() function. Important: By using the set_mode() function, all the scroll and mode 7 windows that were activated in the game, as well as all the processes displayed inside them, will be deleted. ---See: set_fps() - max_process_time - m320x200 ... m1024x768 - STRUCT video_modes signal() signal( , ) Description: Sends a signal to a process (an object of the game). This function is used mainly to destroy (kill) a process from other, sending it a signal s_kill . If you don't know the meaning of process father, son, brother , of an orphaned process, etc., then see Hierarchy of processes . If you don't know the terms live, dead , slept , etc., referred to processes , then see Process state Example: PROGRAM my_game; PRIVATE id2; BEGIN id2=my_process(); // ... signal(id2, s_kill); END PROCESS my_process() BEGIN // ... LOOP FRAME; END END - This program would create a my_process type process and then it would delete it with the signal(id2,s_kill) statement (id2 is a variable of the main program that contains the identifying code of the process that is going to be deleted). Any process may send a signal to another one, provided that the former has the identifying code of the latter. See: Identifying codes of processes Ways to obtain the identifying code of a process Nevertheless, there are other signal types that may be sent to a process, and they are the following ones: s_kill - Order to kill the process. The process will not appear in the following frames of the game any longer. s_sleep - Order to make the process dormant . The process will remain paralyzed, without executing its code and without being displayed on screen (nor being detected by the rest of the processes), as if it had been killed. But the process will continue to exist in the computer's memory (see s_wakeup ). s_freeze - Order to freeze the process. The process will remain motionless without running its code. But it will continue being displayed on screen and it will be possible to detect it (in the collisions) by the rest of the processes. The process will continue to exist in the computer's memory, even if its code is not executed (see s_wakeup ). s_wakeup - Order to wake up the process. It returns a slept or frozen process to its normal state. The process will be executed and displayed again from the moment that it receives this signal normally. A process that has been deleted (killed) can not be returned to its normal state, since it does not exist in the computer's memory any longer. A process can also send these signals to itself, taking into account that the identifying code of a process is always ID (word reserved in the language to this purpose). The statement would be as follows: signal( id , ) Self-deleting a process in this way, sending a s_kill signal to itself, will not instantaneously destroy the process, but in the following ( FRAME ) display. The RETURN statement can be used to immediately delete a process. All the signals sent to processes will be implemented just before the next display of the game , in the next FRAME of the game (not instantaneously). Together with these four signals, there are other four signals that directly correspond to the previous ones. They are: s_kill_tree , s_sleep_tree , s_freeze_tree and s_wakeup_tree . These signals are sent not only to the indicated process, but also to all the processes that it has created . That is to say, if a s_kill_tree signal is sent to a process, the latter and all its descendants (sons, grandsons, ...) will be deleted as well as all the processes created by it and the processes created by the latter. An exception to these last four signals is when there is an orphan process , a process whose father (the process that called it) is already dead. The orphan processes will not receive the signal when it is sent to a process from which they are descended as, on having disappeared their father, it won't be able to send the signal to the processes it created. Example program: PROGRAM example_signal; PRIVATE id_text; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"1 - create the process\"); write(0, 0, 10, 0, \"2 - kill the process\"); write(0, 0, 20, 0, \"3 - sleep the process\"); write(0, 0, 30, 0, \"4 - freeze the process\"); write(0, 0, 40, 0, \"5 - wake up the process\"); id_text=write(0, 0, 190, 0, \"There is no process\"); LOOP IF (key(_1) AND NOT son) delete_text(id_text); my_process(); id_text=write(0, 0, 190, 0, \"Process alive\"); END IF (key(_2) AND son) delete_text(id_text); signal(son, s_kill); id_text=write(0, 0, 190, 0, \"There is no process\"); END IF (key(_3) AND son) delete_text(id_text); signal(son, s_sleep); id_text=write(0, 0, 190, 0, \"Process slept\"); END IF (key(_4) AND son) delete_text(id_text); signal(son, s_freeze); id_text=write(0, 0, 190, 0, \"Process frozen\"); END IF (key(_5) AND son) delete_text(id_text); signal(son, s_wakeup); id_text=write(0, 0, 190, 0, \"Process alive\"); END FRAME; END END PROCESS my_process() BEGIN graph=100; LOOP x=160+get_distx(angle, 140); y=100+get_disty(angle, 80); angle+=5000; FRAME; END END - With the 1 key, this program will create a process ( my_process ) that rolls around the screen; with the keys from 2 to 5 , different signals will be sent to this process, by using this function. The identifying code of my_process is located in the son local variable of the main program by default. When a process is created, the system defines the son variable of the father with the identifying code of the son, and the father variable of the son with the identifying code of the father. signal( TYPE , ) Description: This second meaning of the signal function is similar to the previous one, with the exception that, instead of sending a signal to a process from its identifying code , it allows us to send a signal {to all the processes of a specific type} or to them and their descendants, when the used signals are of the type s_kill_tree (see: Types of processes ). For instance, if several processes of the enemy type exist or may exist in a game, and the aim is to freeze these processes (without freezing their descendants), the following statement will be used: signal(TYPE enemy, s_freeze); As it can be noticed, it is necessary to have the identifying code of a specific process in order to send a signal to it. To delete a group of processes, it is necessary either that they are of the same kind, that this group is made up of a process and its descendants, or that all their identifiers are known ( in order to send them the signal one by one). It is possible to send a signal to a type of processes, even if no process of this type is being executed in the game. But if a signal is sent to a process that has already been killed, with its identifying code (first meaning of the signal statement), there is a risk that the identifying code is now used by another process, which is going to receive the signal. This happens, for instance, when the aim is to kill a process that has already been killed, as it is possible that another different one is being killed. Note: If the aim is to delete all the processes except the current one, the let_me_alone() function may be used. This function sends a s_kill signal to all the processes, except the one that executed this function. ---See: let_me_alone() - Identifier codes - Types of processes sound() sound( , , ) Returns: The channel number through which the sound is played. Description: Plays the effect whose sound code is specified as first parameter. At first, the sound must have been loaded from a PCM file with the load_pcm() or load_wav() functions. This function returns the sound code corresponding to this effect. As a second parameter, it is necessary to specify the volume at which the sound is intended to be reproduced, taking into account that 0 is the minimum volume, and 256 the maximum volume. As third parameter, you must specify the frequency (speed) at which the sound is intended to be reproduced, being 256 the standard frequency that will reproduce the original sound. With lesser values, the sound will be reproduced with more accentuated bass. On the contrary, with higher frequency values, it will be reproduced with more accentuated treble. The function returns the channel number that can be used by the stop_sound() function to stop the sound and by the change_sound() function to modify its volume or frequency. There are 16 sound channels. Thus, up to 16 sounds may simultaneously be played. Example program: PROGRAM example_sound; PRIVATE volume=128; // Average value (0..256) frequency=256; // Average value (0..512) id_sound, channels; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"Volume: Up(+) / Down(-)\"); write_int(0, 0, 10, 0, offset volume); write(0, 0, 20, 0, \"Frequency: Right(+) / Left(-)\"); write_int(0, 0, 30, 0, offset frequency); write(0, 160, 180, 1, \"Press [SPACE] to play the sound.\"); write(0, 160, 190, 1, \"Use the cursors to change the values.\"); id_sound = load_pcm(\"help/help.pcm\", 0); LOOP IF (scan_code==_space) // Plays it channels = sound(id_sound, volume, frequency); END IF (key(_up) AND volume<256) volume++; END IF (key(_down) AND volume>0) volume--; END IF (key(_right) AND frequency<512) frequency++; END IF (key(_left) AND frequency>0) frequency--; END FRAME; END END - In the example, a background screen and an explanatory text are displayed, and a sound is loaded with the load_pcm() function. This function returns the identifier of the sound , that is stored in the id_sound variable. In the main loop, at every keystroke of the spacebar, the sound is played with the sound() function with the parameters defined in the volume and frequency variables. These values can be manipulated with the cursors keys, in order to understand better how it works. The channel number returned by sound() , that is stored in the channel variable, could have been used to modify the sound with change_sound() or to stop it with stop_sound() . ---See: load_pcm/wav() - change_sound() - stop_sound() sqrt() sqrt( ) Returns: The entire square root of the expression. Description: Calculates the square root of the expression passed as a parameter, truncated to an integer . For instance, as a result, sqrt(10) will return 3 and not 3.1623 , which is the real value (approximately) of the square root of ten. Example program: PROGRAM example_sqrt; GLOBAL values[15]; n; BEGIN FROM n=0 to 15; values[n]=rand(0, 100000); write_int(0, 0, n*10, 0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to calculate its square root\"); LOOP IF (scan_code==_space) FROM n=0 TO 15; values[n] = sqrt(values[n]); END END FRAME; END END - This program will display a list of randomly chosen values on-screen. When the spacebar is pressed, the program will apply the sqrt() function to all these values, calculating their square root. ---See: Expression start_fli() start_fli( , , ) Returns: The animation's number of frames. Description: Starts a FLI/FLC animation contained in the specified file , in the coordinates ( x , y ) (the upper left coordinate of the display window must be specified). The path can be specified in the . The path is not necessary if the file is in the DIV Games Studio directory or in a subdirectory whose name coincides with file extension (for instance, \"fli\\anima.fli\"). The screen must hold the whole animation. That is to say, if the animation occupies the whole screen, the videomode must be fixed at first with the set_mode() function, starting then the animation at the (0, 0) coordinate with the start_fli() function. For your information, the function returns the number of frames that the whole animation comprises. The system will automatically activate the colour palettes that the FLI/FLC animation could have. This can cause problems dealing with the representation of other graphics or fonts of the program, if they had been drawn with a different palette. If the aim is to combine other graphics with animation on-screen, the latter must have just one colour palette (which is normally called \" palette low FLI/FLC \") and the graphics must have been drawn with that same palette. Once the animation has started, its frames will gradually be shown with respective calls to frame_fli() . It is possible to have but one active animation at every time . Therefore, after having started an animation with start_fli() and having been displayed with frame_fli() , this animation must finish with the end_fli() function before starting another different animation. Example program: PROGRAM example_start_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); // An animation begins. LOOP frame_fli(); FRAME; END END - In the example an animation which is inside of the file help/help.fli begins with the function start_fli() in the coordinates (0, 0) and the animation is played indefinitely. The frame_fli() function, used to show every frame, will return 0 when the animation is over. Therefore, to show the animation just one time you should have done as follows: Example program: PROGRAM example_start_fli; PRIVATE fli_frames; BEGIN start_fli(\"help/help.fli\", 0, 0); REPEAT fli_frames=frame_fli(); FRAME; UNTIL (fli_frames==0); end_fli(); END - The reset_fli() function allows us to rewind the animation, so that the frame_fli() function continues to execute it from the beginning. ---See: end_fli() - reset_fli() - frame_fli() start_mode7() start_mode7( , , , , , ) Description: This is an advanced function whose use requires special skill of its user. Creates a mode-7 display window. That is to say, it displays a three-dimensional graphic in a folded plane. In order to obtain this effect, this function will be called with the following parameters: - Up to 10 mode-7 windows can be created on-screen, numbered from 0 to 9 . If the aim is to create but one, the best thing to do is to define window number 0 . This number will be necessary later to modify the window parameters, as the system will need to know which one of the possible 10 mode-7 windows is intended to modify. - The graphics intended to be folded in the window must be in a file whose file code must be specified here, as a second parameter of the function. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). - The third parameter must be the main code of the graphic which is going to be brought down in the window and must belong to the file previously indicated. - Here, it is possible to indicate either a 0 , if the aim is not to see any graphic beyond the graphic folded in the perspective, or a graphic code of the same file that will be shown in the perspective beyond the main graphic , until it gets the horizon. The height and width of this graphic must be powers of two, not higher than 8192 (these powers of two are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 & 8192). For instance, it can be a 64 pixel width by 32 pixel height graphic. This graphic will also be shown folded. - Here, the rectangular screen region in which the mode-7 is going to be shown, will be indicated. If 0 is indicated as a region number, this region will be shown on the whole screen. The rest of regions must previously be defined with the define_region() function (a region is but a rectangular zone of the screen). - The last parameter to indicate will be the distance, in pixels, from the upper part of the window, where the horizon line is intended to be put. If the camera is placed above the folded plane, then nothing will be displayed above the horizon line (this space is normally filled with another scroll or mode-7 window). Otherwise, if the camera is placed below the plane, then nothing will be shown below this horizon line. Besides the call to the function, some values of the global structure m7 must be initialised for the correct window's working . This is a structure of 10 records (one for every possible mode-7 window) and every record has the following fields: camera - Identifying code of the camera height - Height of the camera distance - Distance of the camera horizon - Height of the horizon focus - Focus of vision z - Depth plane colour - Exterior colour Important: In order to activate the mode 7 window it is indispensable to start the camera field as, without this field, the window can not determine from where the folded plane must be seen . The camera will be placed in the folded plane, at the indicated distance of the process whose identifying code has been set in camera , orientated at its angle itself (the one indicated by its angle local variable). The height at which the camera is located with respect to the bottom will be that indicated in the height field. See the help about the m7 structure for further information about these issues, or about how to access them. Example program: PROGRAM example_start_mode7; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_mode7(0, file1, 4, 0, 0, 64); m7.height = 64; m7.distance = 32; m7.color = 162; m7.camera = id; write(0, 160, 0, 1, \"Use the cursors to move\"); LOOP IF (key(_right)) angle-=8000; END IF (key(_left)) angle+=8000; END IF (key(_up)) advance(6); END FRAME; END END - In the example, the graphics file is loaded and then, a three-dimensional mode 7 is created with the start_mode7() function. This function is passed the following parameters: 0 - Number of mode 7 window (the first one, as just one window of this kind will be created). file1 - Code of the file from which the graphics must be taken. This is the code of the help.fpg file, that was loaded with the load_fpg() function. 4 - Code of the main graphic to fold inside the mode 7. To see this graphic, the file must be loaded with the Files menu . Thus, it is possible to observe which one is the graphic with code 4 0 - Code of the secondary graphic. A 0 indicates that no secondary (external) graphic will appear in the mode 7, so the external graphic will be displayed in the colour indicated by the m7[0].colour variable. In order to observe the effect of putting an external graphic , this parameter can be replaced, for instance, by 100 (that is the code of a 32 by 32 pixel brown ball stored in the help.fpg file). 0 - Region number of the screen on which the mode 7 must be placed . A 0 indicates that it must be placed on the entire screen. 64 - Height of the horizon. This last parameter indicates that the horizon line will be placed at 64 pixels from the upper part of the window. After having called the start_mode7() function, the program defines the following values of the global structure m7 : m7.height=64; - To show that the camera must be placed at 64 pixels from the bottom. m7.distance=32; - To show that the camera must be placed at 32 pixels behind the camera process. m7.colour=162; - To indicate that the external part must be displayed in colour number 162 of the palette. m7.camera= id ; - To indicate that the current process will be the camera process. The camera will be placed 32 pixels behind the main process, at 64 pixels height, orientated at the angle indicated by its angle variable. After these initialisations, the sample program will remain in a loop that simply controls the angle of the main process with the cursors. This angle will be that of the camera and, when the up cursor key is pressed, the advance() function will be called for the main process (and, consequently, the mode 7 camera) to advance 6 pixels. --- How to visualise processes graphics in mode 7. --- To create a process whose graphic is displayed in the mode 7, its ctype local variable must be defined as c_m7 ( type of coordinate as mode 7 coordinate ), which will be done with the following statement: ctype=c_m7; After this, the process will be displayed in the mode 7 with its graphic ( graph ) scaled depending on the distance at which it is. The process must only modify its x and y variables to move through the folded plane. When a process belongs to the mode-7 (the value c_m7 has been assigned to its local variable ctype ): Its x and y variables will be referred to the folded main graphic's point above which the process graphic will be placed. Its z variable will lose its effect, as the graphics will appear in strict order of depth. This variable will only be useful to indicate display priorities in graphics exactly placed in the same depth plane. The process will automatically be deleted when the mode 7 window, to which the process belongs, is deleted with the stop_mode7() function, or when the videomode is changed with the set_mode() function as, by doing so, the mode 7 windows will also be deleted. If there were several mode 7 windows, the process would be displayed in all of them by default. If the process had to be displayed just in one of them, its cnumber local variable should be then defined. For instance, if there were 6 mode 7 windows (from number 0 to number 5) and the aim was to display a process only in windows 0 and 2, the following statement should be included in it: cnumber=c_0+c_2; For a process to have several graphics (several views), depending on the angle from which it is observed, its graphic must be defined with the xgraph local variable (instead of the graph variable). To define this variable, it is necessary, at first, to create a table (of any name), first indicating the graphic's number of views and then the graphics codes for these views, starting with angle 0 and in an anticlockwise direction. For instance: GLOBAL views_car[]=4, 100, 101, 102, 103; The table views_car would define 4 views: graphic 100 for angles near 0 degrees, graphic 101 for angles near 90 degrees, graphic 102 for angles near 180 degrees, etc. And then, the xgraph variable must be initialised in the process code with the following statement: xgraph=OFFSET views_car; To get an example about what we have just seen, examine some of the DIV Games Studio's sample games that use this technique. Thus, read the comments about these programs (for instance, see Speed for dummies ). ---See: stop_mode7() - Structure m7 start_scroll() start_scroll( , , , , , ) Description: This function has a certain complexity, requiring a special skill of the user, who (should have previously programmed) to use it. Creates a scroll window, in which it will perform a view against a background graphic. That is to say, by using a graphic bigger than the display window as a game background, a part of this graphic can be showed and shifted in any direction. To obtain this effect, this function will be called with the following parameters: - Up to 10 scroll windows can be created on screen, numbered from 0 to 9 . If the aim is to create only one, the best thing is to define window number 0 . This name will later be necessary to modify the parameters of the window, as the system will need to know which one of the 10 possible scroll windows is intended to change. - The graphics that are intended to be shown as a background in that window must be in a file whose file code must be specified here, as a second parameter of the function. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) functions will be used as if they belonged to the first file (the file with the code 0). - The third parameter must be the code of the main graphic that is going to be displayed as a background in the window and that must belong to the file previously indicated. This graphic is normally the main window of the game on which the action will be developed. It is a graphic bigger than the display window, that will be shifted in one or several directions and on which the graphics of the game will be placed. The scroll window will be initially placed with the control point number 0 of this graphic in the upper left corner, when this point has been defined in the graphic editor . - Here, 0 will be indicated if the aim is to obtain a single scroll plane (a single background graphic), or another graphic code if it is intended that it appears as scroll background (deeper), behind the foreground. In order to see this background plane, it is indispensable that the main graphic (foreground) has parts painted in colour number 0 of the palette, as these transparent zones will allow us to see the background graphic through them. - The rectangular screen region in which the scroll is going to be shown will be here indicated. If 0 is indicated as a region number, it will be shown on full screen. The rest of regions must previously be defined with the define_region() function (a region is but a rectangular zone of the screen). - A value defining whether each of the two scroll planes is horizontally and vertically cyclical will be here indicated. For instance, a plane is horizontally cyclical when, on leaving the picture on the right, the picture appears on the left. To obtain this value, the following quantities must be added: ** + 1** - If the foreground is horizontally cyclical. ** + 2** - If the foreground is vertically cyclical. ** + 4** - If the background is horizontally cyclical. ** + 8** - If the background is vertically cyclical. This means that 0 if none of the two planes must be cyclical, 15 ( 1 + 2 + 4 + 8 ) if both planes must be cyclical in both axes, 12 ( 4 + 8 ) if only the background must be cyclical, etc. When a (foreground or background) graphic is smaller than the display window, the system will force it to have a cyclical scroll plane. Otherwise, the scroll window could not be completely filled, without cyclically repeating the graphic (tile). Besides the call to the function, some values of the scroll global structure must be initialised for the correct working of the window . This is a structure of 10 records (one for each possible scroll window) and every record has the following fields: x0, y0 - Foreground coordinates x1, y1 - Background coordinates z - Depth plane camera - identifying code of the camera ratio - Background's relative speed speed - Foreground's maximum speed region1 - First screen region region2 - Second screen region There are two ways to program the movement of the scroll windows: Manually, modifying in each frame of the game the fields x0 , y0 , x1 and y1 of this structure (the scroll planes' coordinates). Automatically, for what the identifying code of a process is needed in the field camera of this structure. From then, the system will be in charge of following the graphic of this process in the scroll window. See the help about the scroll structure either for further information about these fields, or to know how to access them. Example of AUTOMATIC scroll: PROGRAM example_start_scroll; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); scroll.camera=id; ctype=c_scroll; graph=100; write(0, 160, 0, 1, \"Use the cursors to move the ball\"); LOOP IF (key(_right)) x+=2; END IF (key(_left)) x-=2; END IF (key(_down)) y+=2; END IF (key(_up)) y-=2; END FRAME; END END - In the example, the graphics file is loaded and then, a scroll window is created with the start_scroll() function. The latter is passed the following parameters: 0 - Number of scroll window (the first one, as only a window of this kind will be created). file1 - Code of the file from which the graphics must be taken. This is the code of the file help.fpg loaded with the load_fpg() function. 103 - Code of the main graphic (foreground) of the scroll. In order to see this graphic, the file must be loaded with the Files menu , being then possible to observe which is the graphic with code 103 . 102 - Code of the secondary graphic (background). This graphic will be shown in the scroll window behind the main graphic. 0 - Number of the screen's region in which the scroll must be placed . 0 indicates that it must be put on the entire screen. 15 - Lock indicator; 15 (1+2+4+8) indicates that the foreground as well as the background will be cyclical in both axes (horizontal and vertical). After having called the start_scroll() function, the program defines the field camera of the scroll structure , assigning the identifying code of the main process to it (with the scroll.camera= id ; statement). Thus, the scroll becomes automatic , following the graphic of the main process from that moment. The program continues to define its type of coordinate as a scroll coordinate (with the ctype=c_scroll; statement), defining its graphic as number 100, that is a brown ball (with graph=100; ), and displaying a message. Then, it will stay in a loop in which the coordinates of this process (the x and y variables) may vary with the cursor keys. Example of scroll MANUAL: PROGRAM example_start_scroll; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); write(0, 160, 0, 1, \"Use the cursors to move the scroll\"); LOOP IF (key(_right)) scroll.x0+=2; scroll.x1+=1; END IF (key(_left)) scroll.x0-=2; scroll.x1-=1; END IF (key(_down)) scroll.y0+=2; scroll.y1+=1; END IF (key(_up)) scroll.y0-=2; scroll.y1-=1; END FRAME; END END - In the example the file of graphics is loaded and then a scroll window is created with the function start_scroll() . The same parameters of the previous example are given to this last one. After this, the program will stay in a loop inside of which, when the cursor keys are detected, the fields x0 , y0 , x1 and y1 of the global scroll structure will change, and these define the coordinates of the two scroll planes ( x0 , y0 for the first plane and x1 , y1 for the second). It can be seen the difference between both methods; this last one, as it hasn't beginning the field camera of the structure, will be able to manipulate the coordinates of both planes. --- How to visualise the process graphics in the scroll --- To create a process which graphic is seen in the scroll window, its local variable ctype must be defined as c_scroll ( coordinate of type as coordinate of scroll ), what will be done with the following statement: ctype=c_scroll; Once this is done, the process will be seen in the scroll with its graphic (defined in the local variable graph ). The process just must modify its variables x and y to move over the scroll. In the example, the graphics file is loaded and then, a scroll window is created with the start_scroll() window. The latter is passed exactly the same parameters as in the previous example. After that, the program will stay inside a loop in which, on detecting the cursor keys, the fields x0 , y0 , x1 and y1 of the scroll global structure will vary. These fields define the coordinates of the two planes of the scroll ( x0 , y0 are the coordinates of the foreground and x1 , y1 those of the background). The difference between both methods can be noticed. The latter can directly manipulate the coordinates of both planes, as it has not initialised the field camera of the structure. --- How to display processes' graphics in the scroll. --- In order to create a process whose graphic is displayed in the scroll window, it is necessary to define its ctype local variable as c_scroll ( type of coordinate as scroll coordinate ), which will be done with the following statement: ctype=c_scroll; After that, the process will be displayed in the scroll with its graphic (defined in the graph local variable). The process must modified only its x and y variables to scroll. {When a process belongs to the scroll (assigning the value c_scroll to its local variable} ctype ): Its x and y variables will be referred to the point of the foreground's graphic on which the graphic of the process will be placed. Its z variable will be now referred to the variables z of the processes that also belong to the same scroll window. This means that each time that a scroll window is displayed, all the graphics that belong to it (ranged by their z ) will be displayed just after it. Then, the processes that don't belong to that scroll window will continue to be displayed. The process will be automatically eliminated when the scroll window to which the process belongs is eliminated with the stop_scroll() function. Or when the videomode is changed with the set_mode() function as, on doing so, the scroll windows will be also eliminated. If there were several scroll windows, the process would be displayed by default in all of them. If it had to be displayed only in some of them, its cnumber local variable should be defined. For instance, if there were 6 scroll windows (numbered from 0 to 5) and the aim was to display a process only in windows 0 and 2, the following statement should be included in it: cnumber=c_0+c_2; In order to observe an example of what it has been said, the best thing is to examine some of the sample games of DIV Games Studio that use this technique. Thus, the reader is directly referred to the comments of these programs (for instance, see the example Helioball ). ---See: stop_scroll() - refresh_scroll() - move_scroll() - Scroll structure stop_cd() stop_cd() Description: Stops the CD-Audio reproduction, stopping the song which were playing. The songs are reproduced with the function play_cd() . Example program: PROGRAM example_stop_cd; BEGIN write(0, 160, 0, 1, \"Press [ENTER] to turn on the CD.\"); write(0, 160, 10, 1, \"Press [SPACE] to stop the CD.\"); LOOP IF (scan_code==_space) stop_cd(); // Para el CD END IF (scan_code==_enter) play_cd(2, 0); END FRAME; END END - In the example are placed the necessary messages. In each step of the loop, if the space bar is pressed, the CD will be stopped with the function stop_cd() . If the ENTER key is pressed, it will be turned on with the function play_cd() . The volume of reproduction of cd-audio can be controlled with the setup structure and the function set_volume() . ---See: play_cd() - is_play_cd() - set_volume() - setup structure stop_mode7() stop_mode7( ) Description: Eliminates the mode 7 window which number (from 0 to 9) is given as parameter. This is the one indicated as first parameter in the function start_mode7() , is necessary due to that can be up to 10 different mode 7 windows, and the system needs to know which of them is ending. When a mode 7 window is eliminated, every process which belongs exclusively to this window will die automatically, so, every process which has its variable ctype with the value c_m7 and they are not being seen in any other mode 7 window. Important: When the video mode is changed with the function set_mode() every mode 7 window (and its processes) will be eliminated, without being in this case, necessary to use this function ( stop_mode7() ). Example program: PROGRAM example_stop_mode7; BEGIN load_fpg(\"help/help.fpg\"); write(0, 160, 0, 1, \"Press [ENTER] to start the mode 7 display.\"); write(0, 160, 10, 1, \"Press [SPACE] to stop the mode 7 display.\"); write(0, 160, 190, 1, \"Use the mouse to move the mode 7 display.\"); angle=90000; LOOP IF (scan_code==_space) stop_mode7(0); // The mode 7 is stopped END IF (scan_code==_enter) start_mode7(0, 0, 4, 0, 0, 64); m7.camera=id; END x=mouse.x; y=mouse.y; FRAME; END END - In the example a file of graphics is loaded, and the instructions of the program appear on screen, after this, the coordinates of the main process, which will be the camera of the mode 7, will be controlled with the mouse (through the statements x=mouse.x; and y=mouse.y ). When the ENTER key is pressed, a mode 7 window is created with a graphic of a circle, controlled by the main process. When the space bar is pressed, the function stop_mode7() will be called, eliminating this window of the mode 7 visualisation. To Create a mode 7 window is a bit complex procedure and requires to begin some parameters, as in this case the camera, some of them required by the function start_mode7() and other variables in the global structure m7 (as the variable m7.camera used in the example). ---See: start_mode7() - m7 structure stop_scroll() stop_scroll( ) Description: Eliminates the scroll window which number (from 0 to 9) is given as parameter. This is the one indicated as first parameter in the function start_scroll() and it is necessary due to can be up to 10 different scroll windows, and the system needs to know which one is ending. When a scroll window is eliminated, every process which belongs exclusively to this window will die automatically, so, every process which has its variable ctype with the value c_scroll and they are not being seen in any other scroll window. Important: When the video mode is changed with the function set_mode() every scroll window (and its processes) will be eliminated, without being in this case, necessary to use this function ( stop_scroll() ). Example program: PROGRAM example_stop_scroll; BEGIN load_fpg(\"help/help.fpg\"); write(0, 160, 0, 1, \"Press [ENTER] to activate the scroll window.\"); write(0, 160, 10, 1, \"Press [SPACE] to end the scroll.\"); LOOP IF (scan_code==_space) stop_scroll(0); // The scroll is quit. END IF (scan_code==_enter) start_scroll(0, 0, 103, 102, 0, 15); END scroll.x0+=1; scroll.y0+=1; scroll.x1-=1; FRAME; END END - In the example a file of graphics is loaded and the instructions of the program appear on screen. When the ENTER key is pressed, a scroll window will be created and when the space bar is pressed, the function stop_scroll() is called, eliminating this scroll window. Inside of the main loop, the coordinates of the scroll are accessed, being contained in the global scroll structure to move manually the scroll window ( scroll.x0+=1; ... ). To create a scroll window is a bit complex procedure and requires to start some parameters, some of them, required by the function start_scroll() and other contained in the global scroll structure (as the variable scroll.x0 used in the example). ---See: start_scroll() - scroll structure stop_sound() stop_sound( ) Description: Stops the sound that is being played through the channel, passed as a parameter. The required is the value returned by the sound() function when the reproduction of a sound effect starts. There are 16 sound channels. Thus, up to 16 sounds may simultaneously be played. Example program: PROGRAM example_stop_sound; PRIVATE id_sound; channels; playing=FALSE; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 160, 0, 1, \"Press [SPACE] to start the reproduction.\"); write(0, 160, 10, 1, \"Press [ENTER] to stop the sound channel.\"); id_sound = load_pcm(\"help/help.pcm\", 1); LOOP IF (scan_code==_space AND NOT playing) channels = sound(id_sound, 128, 256); playing=TRUE; END IF (scan_code==_enter) stop_sound(channels); // The sounds stops playing playing=FALSE; END FRAME; END END - In the example, a background graphic is put and the necessary messages are displayed. At the same time, the sound effect stored in the help.pcm file is loaded with the load_pcm() function, that returns the sound identifier that is stored in the id_sound variable. Notice that, in this example, 1 is passed to this function as a second parameter. That is done to indicate that the loaded sound effect must indefinitely be repeated every time it is initialised (stressing thus the effect of the stop_sound() function). In every step of the loop, it is checked whether the spacebar is pressed. In this case, the reproduction of the sound effect will start with the sound() function, which will return the channel number that will be stored in the channel variable. If the ENTER key is pressed, the sound will be stopped with the stop_sound() function. To gradually stop a sound, turning its volume down little by little, several calls to the change_sound() function must be made to slightly reduce the channel volume until it reaches level 0. Then, the stop_sound() can be called to definitively stop the sound. ---See: sound() - change_sound() - load_pcm/wav() - unload_pcm/wav() system() system( <\"external command\"> ) Description: Executes the operative system's command passed as a parameter. Example program: PROGRAM example_system; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to execute a DIR.\"); LOOP IF (scan_code==_space) system(\"dir\"); // A command of MS-DOS is executed. END FRAME; END END - In the example, after the display of a text, you enter inside the main loop in which the DIR command of the MS-DOS operative system will be executed every time the spacebar is pressed. One of the utilities of this command is, for instance, to delete a temporary file that has been created in the program, calling the command of the system DEL < file name > . Note: The system can be blocked depending of the executed commands. In these cases you must reset the computer. There is no guarantee dealing with this function running, due to the multiple incompatibilities that can appear between the external commands and the manager of internal processes of DIV Games Studio. system(\"COMMAND.COM\") Description: Executes a session of the MS-DOS operative system from the program itself. On typing EXIT from it, you will return to the program at the point in which this statement was executed. ---See: exit() unload_fpg() unload_fpg( ) Description: Unloads the graphics file whose code is passed as parameter from the memory. This is the value returned by the load_fpg() function when a new graphics file is loaded in the memory. After having unloaded a graphics' file, much care must be taken not to go on using in the program any graphic that was in that file. Otherwise, the program could become blocked. It is not necessary to unload the file from the memory before finishing the program, as the system will do it automatically. Therefore, a file must be unloaded from the memory only when it is not going to be used for a while and when the aim is to free up space occupied in the computer's memory in order to load other resources (other graphics files, sounds, fonts, etc.). Example program: PROGRAM example_unload_fpg; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); write(0, 160, 0, 1, \"Press [ENTER] to unload the file and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_fpg(file1); // The file is loaded. END - The example loads the graphics file contained in the help.fpg file with the load_fpg() function, storing the file code in the file1 private variable. The program will remain in a loop until the ENTER key is pressed. At that moment, the file will be unloaded from the memory with unload_fpg() and the program will finish. The graphics individually loaded with the load_map() or load_pcx() (or created with new_map() ) functions will not be unloaded when file number 0 (with code 0) is loaded , even if they were used as if they belonged to it. These graphics will have to be unloaded by using the unload_map() or unload_pcx() functions. ---See: load_fpg() - load_map/pcx() - unload_map/pcx () unload_pcm() / unload_wav() unload_pcm( ) unload_wav( ) Description: Unloads the sound whose code is passed as a parameter from the memory. This is the value returned by the load_pcm() or load_wav() function when a new sound effect is loaded in the memory. After having unloaded a sound effect, much care must be taken not to go on using in the program this effect (its code) for the sound() or unload_pcm() functions. Otherwise, the program could become blocked. It is not necessary to unload the sound from the memory before finishing the program, as the system will do it automatically. Therefore, a sound must be unloaded from the memory only when it is not going to be used for a while and when the aim is to free up space occupied in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.), which will be logical just with sound effects of a certain length, in other words big enough so as to be worth freeing up the space they occupy. Example program: PROGRAM example_unload_pcm; PRIVATE sound1; BEGIN sound1=load_pcm(\"help/help.pcm\",0); write(0, 160, 0, 1, \"Press [ENTER] to unload the sound and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_pcm(sound1); // The sound is unloaded. END - The example loads the sound effect stored in the help.pcm file with the load_pcm() function, storing the sound code in the sound1 private variable. The program will remain in a loop until the ENTER key is pressed. At that moment, the file will be unloaded from the memory with unload_pcm() and the program will finish. The stop_sound() function must be used to stop a sound effect, but keeping it in the memory in order to be played again when desired. ---See: load_pcm/wav() - sound() - change_sound() - stop_sound() write() write( , , , , ) Returns: The identifying code of the text that has been written. Description: This function is used to show an alphanumeric text on-screen. For that, it requires the following parameters: - The font code or type of letter that is going to be used. Here, you must put either 0 when the aim is to use the system's font (white, small font, 6 by 8 pixels), or the font code returned by the load_fnt() function when a new font is loaded in the program. , - The coordinates referred to the screen in which the text is going to be displayed, first in the horizontal axis and then in the vertical one. - This code determines the position of the text specified by the previous coordinates. Its values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right For example, if a text is written at the 160, 0 coordinates and with the centreing code 1 (Up), then the text will c entre in the column 160 and it will be displayed from line 0 downwards. Or, if the aim is to have a text in the upper left corner, it must be displayed at the 0, 0 coordinates and with centreing code 0 (Up left). - The text to be written as a literal (a text in inverted commas) will be specified as last parameter (see the literals' specifying symbols ). The displayed text will remain on-screen until it is deleted with the delete_text() function, that requires as parameter the identifying code returned by write() . The write_int() function must be used to display the numeric value of a variable (such as the score of the player). The texts will remain unchangeable on screen even if graphics are displayed on it or processes' graphics pass before or behind them. Example program: PROGRAM example_write; PRIVATE font1; BEGIN font1 = load_fnt(\"help/help.fnt\"); write(0, 160, 100, 4, \"Sample text with the system font.\"); write(font1, 0, 0, 0, \"LEFT UP\"); write(font1, 320, 200, 8, \"RIGHT DOWN\"); LOOP FRAME; END END - In the previous example, the font contained in the help.fnt file is loaded with the load_fnt() function (whose font code is stored in the font1 variable), and then three texts are written: The first one with the system font (0), being placed at the 160, 100 coordinates (screen centre) the centre of the text (centreing code 4). The second one with the loaded font (whose font identifier is stored in the font1 variable), being placed at the 0, 0 coordinates the upper left corner of the text (centreing code 0). And finally, the third text, also with the loaded font, being placed at the 320, 200 coordinates the lower right corner of the text (centreing code 8). After that, the program will indefinitely remain expecting inside a loop. The depth plane in which the written texts appear is controlled through the text_z global variable, that is useful to regulate which graphics must be seen above the texts and which ones must be seen below them. Then, it will be possible to move the texts towards another position if necessary, by using the move_text() function, which also requires the identifying code returned by write() as parameter. When fonts loaded from files FNT are used, the colours palette used to generate these fonts must be activated (see load_pal() ). Otherwise, the colours may appear changed, and the text will be incorrectly displayed. ---See: write_int() - move_text() - delete_text() - load_fnt() - text_z write_int() write_int( , , , , ) Returns: The identifying code of the text that has been written. Description: This function is used to show the numeric value of a variable. For that, it requires the following parameters: - The font code or type of letter that is going to be used. Here, it is necessary to put either 0 when the aim is to use the system's font (white, small font, 6 by 8 pixels), or the font code returned by the load_fnt() function when a new font is loaded in the program. , - The coordinates referred to the screen in which the numeric value is going to be displayed, first in the horizontal axis and then in the vertical one. - This code determines the position of the numeric value specified by the previous coordinates. Its values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right For example, if a numeric value is written at the 160, 0 coordinates and with the centreing code 1 (Up), then the numeric value will be centred in the column 160 and it will be displayed from line 0 downwards. Or, if the aim is to have a numeric value in the upper left corner, it must be displayed at the 0, 0 coordinates and with centreing code 0 (Up left). - The offset inside the computer's memory of the variable whose value is intended to be displayed, must be specified as last parameter (the offset of the data is obtained with the OFFSET operator). The displayed numeric value will remain on-screen until it is deleted with the delete_text() function, that requires as parameter the identifying code returned by write_int() . Important: During the time that the value of the variable appears on screen, this value will automatically be updated every time the variable is modified. For that, new calls to write_int() are not necessary. The write() function must be used to display any kind of alphanumeric text (a fixed text). The texts will remain unchangeable on screen even if graphics are displayed on it or processes graphics pass before or behind them. Example program: PROGRAM example_write_int; PRIVATE variable; BEGIN write(0, 160, 190, 1, \"Press [SPACE] to change the value of the variable.\"); write_int(0, 160, 100, 4, OFFSET variable); // A variable is displayed. LOOP IF (scan_code==_space) variable=rand(-100, 100); END FRAME; END END - In the example, a text is displayed by using write() and the value of a variable with the write_int() function. This last function is passed the following parameters: 0 - As font (0 is the system font). 0, 10 - As screen coordinates. 0 - As centreing code (Up/Left). OFFSET variable - As the offset of the variable in the memory. In every step of the loop, if the spacebar is pressed, the value of the variable is changed, assigning it one randomly chosen with the rand() function. The depth plane in which the written texts appear is controlled through the text_z global variable, that is useful to regulate which graphics must be seen above the texts and which ones must be seen below them. Then, it will be possible to move the texts towards another position if necessary, by using the move_text() function, which also requires the identifying code returned by write() as parameter. When fonts loaded from files FNT are used, the colour palette used to generate these fonts must be activated (see load_pal() ). Otherwise, the colours may appear changed, being the text incorrectly displayed. Warning: It is not possible to display an expression, as it is shown below: write_int(0, 0, 0, 0, offset variable + 1); To display the value of the variable plus 1. That is to say, if the aim was to display this value, it would be necessary either to add 1 to the variable or to create another variable, assigning it the value of the original variable plus 1, for instance: variable2 = variable + 1; write_int(0, 0, 0, 0, offset variable2); In this case, you should take into account that you had to update the value of the variable2 at least once per every FRAME of the game, as by changing variable the value of variable2 will not automatically be updated unless the variable2 = variable + 1; statement is again executed. ---See: write() - move_text() - delete_text() - load_fnt() - text_z xput() xput( , , , , , , , ) Description: Advanced version of the put() function to put a graphic on the screen background. This function requires the following parameters, in order: - file code with the graphics library that contains both graphics. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) functions will be used as if they belonged to the first file (the file with the code 0). - code of the graphic inside the file that is going to be displayed on screen. , - coordinates dealing with the screen where the graphic is intended to be put. These coordinates reveal the position in which the graphic centre (or the control point number 0, if it is defined) will be placed. - angle (in degree thousandths) in which the graphic is going to be displayed; the normal angle is 0 . - size (in percentage) in which the graphic is going to be displayed; the normal size is 100 . - Indicates the mirrors and transparencies with which the graphic will be displayed; the possible values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical (180\u00b0) mirror. 4 -Transparent graphic. 5 -Horizontal transparent and mirror. 6 -Vertical transparent and mirror. 7 -Horizontal and vertical transparent, mirror. - Number of region (window inside the screen) in which the graphic must be displayed. This value will normally equal 0 to display the graphic at any position of the screen. The define_region() function must be used to define a region. The graphics displayed in this way on the background screen will be in the game display below all the processes, scroll regions, texts, etc. If the aim is that a graphic is above others, it is necessary to create it as a new process and fix its z variable with the priority of its display. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put; PRIVATE file1; coord_x; coord_y; angle1; size1; flags1; BEGIN file1=load_fpg(\"help/help.fpg\"); LOOP coord_x=rand(0, 319); coord_y=rand(0, 199); angle1=rand(-pi, pi); size1=rand(10, 200); flags1=rand(0, 7); // The graphic 101 is put xput(file1, 101, coord_x, coord_y, angle1, size1, flags1, 0); FRAME; END END - In the example, the file is loaded with the graphics and, in every iteration of the loop, graphic number 101 (a triangle) is put with the xput() function at coordinates randomly chosen with the rand() function, with random angle, size and value of flags , and in region number 0 (entire screen). The put() function is a simplified version of the xput() function, and it is useful when you do not want to rotate, scale, mirror or display the graphic with transparencies. The map_put() or map_xput() functions must be used to put a graphic inside another one (instead of the screen background). If the graphic intended to be put is just a screen background, it is easier to use the put_screen() function, as it does not require the screen coordinates because it will automatically centre the graphic on screen. ---See: put() - map_put() - map_xput() - put_screen() load_map() / load_pcx() load_map( ) load_pcx( ) Returns: The loaded graphic code . Description: Loads a MAP or PCX file with a graphic in the computer's memory . The function requires the file name as a parameter, in inverted commas. The graphic code is returned as return value, which is a numeric value that must be specified to use the graphic, in the graph variable or, in general, in all the functions requiring a graphic code among their parameters. It is possible to load as many graphics as necessary. Every time one is loaded, the function will return the corresponding code (the first graphic loaded will have the code 1000 , the following one the code 1001 , etc.) It is possible to specify the path to the file with the graphics' file. Nevertheless, if the file is in the directory by default (\\MAP or \\PCX), it won't be necessary. Important: When the file code to which that graphic belongs is required inside a function, the code 0 (which is the code of the first file FPG that is loaded in the program) must be indicated. When different graphics have been loaded, keep in mind that if they have different palettes, every one of them must previously be activated with the load_pal() function, indicating the name of the file (MAP / PCX) as a parameter, before using the graphic. Graphics created with different palettes can not simultaneously be used. Example program: PROGRAM example_load_map; PRIVATE map1; BEGIN map1 = load_map(\"help/help.map\"); // A graphic map's file is loaded. put_screen(0, map1); LOOP FRAME; END END - In the example, a graphic map is loaded with the load_map() function, storing the graphic code that returns in the map1 private variable. This code is later used as a parameter of the put_screen() function to put the graphic on the background screen. The unload_map() and unload_pcx() functions allows us to free up the computer's memory used by the graphic when it is not going to be used for a specific time. For that purpose, it also requires the graphic code to know which is the graphic to be unloaded from the memory. It is not necessary to unload the graphic from the memory before finishing the program, as the system will do it automatically. To load several graphics all at once in a program, they must be included inside a graphics file (FPG) and loaded with the load_fpg() function. The function new_map() allows you to create a new graphic map of any size and colour, without loading it from an file. ---See: new_map() - unload_map/pcx() - load_fpg() - load_pal() - graph reset_sound() reset_sound( ) Description: Advanced function, only for very expert users. Resets the sound system. This function is used to activate new parameters of the sound hardware. The following values of the setup global structure must be established: setup.card setup.port setup.irq setup.dma setup.dma2 This function is normally used inside the sound setup programs (see setup_program ). To activate the rest of the values of the setup structure, those referred to the mixer volume, the set_volume() function must be called. The values to establish the volume are the following ones: setup.master setup.sound_fx setup.cd_audio ---See: set_volume() - Setup structure - setup_program unload_map() / unload_pcx() unload_map( ) unload_pcx( ) Description: Unloads the graphic whose code is passed as a parameter from the memory. This is the value returned by the load_map() load_pcx() or new_map() function by loading a new graphic stored in an file MAP or PCX in the computer's memory. After having unloaded a graphic, much care must be taken not to go on using this graphic in the program. Otherwise, the program would risk to become blocked. It is not necessary to unload the graphic before finishing the program, as the system will do it automatically. Then, a graphic must be unloaded from the memory only when it is not going to be used for a specific time and when the aim is to free up the occupied space in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.), which will make sense only with graphics of a certain size, big enough so as to be worth freeing up the space they occupy. Example program: PROGRAM example_unload_map; PRIVATE map1; BEGIN map1=load_map(\"help/help.map\"); put_screen(0, map1); write(0, 160, 0, 1, \"Press [ENTER] to unload the graphic and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_map(map1); // The graphic is unloaded. END - In the example, a graphic map is loaded with the load_map() function, storing the graphic code returned by it in the map1 private variable. This code is later used as a parameter of the put_screen() function to put the graphic on the background screen. Then, the program will display a message and wait in a loop for the ENTER key to be pressed. At that moment, the graphic will be unloaded by using the unload_map() function. The graphics individually loaded with the load_map() or load_pcx() (or created with the new_map() ) functions will not be unloaded when file number 0 (with code 0) is unloaded with the unload_fpg() function, even if these graphics are used as if they belonged to it. ---See: load_map/pcx() - unload_fpg() unload_fnt() unload_fnt( ) Description: Unloads from the memory the font (the kind of letter or the set of graphic characters ) whose code is passed as a parameter. This is the value returned by the load_fnt() function by loading a new letter font stored in a file FNT in the computer's memory. After having unloaded a font, much care must be taken not to go on using this font in the program. Otherwise, the program could crash. It is not necessary to unload the font before finishing the program, as the system will do it automatically. Then, a font must be unloaded from the memory only when it is not going to be used for a specific time and when the aim is to free up the occupied space in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.). Example program: PROGRAM example_unload_fnt; PRIVATE font1; BEGIN font1=load_fnt(\"help/help.fnt\"); write(font1, 160, 0, 1, \"FONT LOADED FROM DISK\"); write(0, 160, 190, 1, \"Press [ENTER] to unload the font and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_fnt(font1); // The font is unloaded END - In the example, the font stored in the help.fnt file is loaded with the load_fnt() function, storing the font code returned by it in the font1 private variable. This code is later used as a parameter of the write() function to put a text on screen with that font. Then, the program will wait in a loop for the ENTER key to be pressed. At that moment the font will be unloaded by using the unload_fnt() function and the program will finish. Font number 0, (the system font having 0 as font code), can not be unloaded . ---See: load_fnt() - write() - write_int() set_volume() set_volume( ) Description: Advanced function, only for very experienced users. Adjusts the different volume controls managed by the mixer of the system sound. To adjust the volume, the following values of the setup global structure must be set: setup.master - General volume setup.sound_fx - Sound effects volume setup.cd_audio - CC-audio music volume This function is normally used inside the sound setup programs (see setup_program ), or even in the rest of the programs, normally to adjust the CD_Audio music volume. To activate the rest of the values of the setup structure (those referring to the sound card's parameters) the reset_sound() function must be called with the following defined values of the structure: setup.card setup.port setup.irq setup.dma setup.dma2 ---See: reset_sound() - Setup structure - setup_program set_color() set_volume( , , , ) Description: Redefines a colour of the palette. This function is used to modify the components of a colour of the game palette. You must be very cautious with it, because all the graphics on the screen that use this colour will be affected, to modify the colours of just one graphic use the function convert_palette() . The must be a number between 0 and 255 . The components of the colour will be specified as a number between 0 (minimum) and 63 (maximum). - red Component of the colour. - green Component of the colour. - blue Component of the colour. Now a program is shown which modifies randomly the colours of the palette. Example program: PROGRAM example_set_colour; GLOBAL colour,r,g,b; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); LOOP colour=rand(1,255); r=rand(0,63); g=rand(0,63); b=rand(0,63); set_color(colour, r, g, b); // A colour of the palette is redefined. FRAME; END END - In the example a multicolour screen is placed as background and inside of the program main loop, the component colours of the palette are modified randomly when the space bar is pressed. To obtain random numbers use the function rand() . To modify the entire palette, it is better to load a wholly different file palette with the function load_pal() . To realise other palette effects, the function roll_palette() can be used, which allows you to make loops of changing colours, or the function fade() which allows you to realise multiple fades and saturations of colour at different speeds. ---See: roll_palette() - load_pal() - fade() - fade_off() - fade_on() net_join_game() net_join_game( , , ) Returns: Number of players in the game (0, 1, 2, ...). If there is an error, a negative number is returned, which is the error code: ** -1** : Connection aborted by the user. ** -2** : Can't start the connection. ** -3** : The number of players doesn't fit. ** -4** : There were errors of synchronisation. Description: The net functions are of an extremely advanced level, so could be difficult to understand for users with not enough experience in programming. First the predefined global structure net must be initialised with the parameters that define the type of connection which is going to be established. Then, a call to the function net_join_game() will be enough to create a new game or to join a game (if it is already created). The name of the game (a literal, as \"MyGame\" ), is used to differentiate a game from other games running at the same time on one local net. From that moment, every computer connected to the game will send and receive data from the others automatically, through the net structure, indicated by the parameters. The structure of data. This must be a global structure of the program with as many registers as players that are connected at the same time. In the fields of the structure the sent data can be read and written to; each player must input their values in their own register. The number which corresponds to the total number of players is returned by this function. The system will automatically send their register values to the other players, and the registers of the others players to them. The predefined structure net In this structure are established the parameters which define the type of connection. The fields of this structure are : net.device - Type of Connection Port (1-IPX, 2-Serial link or 3-Modem). net.com - N\u2551 of COM Port, from 1 to 4 (just for serial and modem). net.speed - Connection Speed (in bauds), up to 115000 (just for serial and modem). net.number - Telephone number (just modem), for example net.number=\"913040622\"; . net.init - Initialising string of the modem, for example net.init=\"ATZ\"; . net.mode - 0 or 1 depending on whether the signals are pulses or tones (only for modem). net.server - Indicates if it is the server (just reading, can't be modified). net.max_players - Maximum number of players, from 2 to 16 (it must be the same as the number of registers to the global structure). net.num_players - Current number of players, from 1 to 16 (players can connect and disconnect at any moment). When the connection is made by a serial link or modem, you may only connect 2 players . It's important that the register number of the structure used for the data transfer has as many registers as that indicated in net.max_players . For example, if a game is created and the maximum number of players is 8, and the information which must be given to the players is just their coordinates (x,y), then it could be done as is shown in the following program (supposing a IPX connection for a local net). Example program: PROGRAM example_net_join_game; GLOBAL STRUCT player[7] // 8 players as maximum (from 0 to 7). x,y; END id_red; BEGIN net.device=1; net.max_players=8; // Here, the number of registers is indicated. // ... id_red=net_join_game(\"xxx\",OFFSET player, sizeof(player)); IF (id_red<0) // An error has been produced ... END // The register of this player is \"player[id_red]\" player[id_red].x=x; // I Define my fields player[id_red].y=y; FRAME; // Sending / Reception of data // Now there are connected \"net.num_players\", and their data has also been passed to // the other registers of the structure player[]. // ... END - Note: Further information can be found about how to structure a game over the internet in the user's manual of DIV Games Studio. ---See: net_get_games() - STRUCT net net_get_games() net_get_games() Returns: Activated games of this game currently running. Description: returns the number of live games currently being played of a particular game (to connections over local net). This function is used to see if there is any live game at a determined moment. To establish a connection, the function net_join_game() is used, to create a game or to connect to them. Example program: PROGRAM example_net_get_games; GLOBAL n; // Active games. BEGIN net.device=1; // set device to local LAN // ... n=net_get_games(); IF (n>0) // ... END //... END - Just is useful to IPX connections, it has no meaning in serial link or modem connections (because in these cases there can be just one game). ---See: net_join_game() - ,STRUCT net stop_mode8() stop_mode8( ) Description: Eliminates the mode 8 window which number (from 0 to 9) is given as the parameter. This is the one indicated as the first parameter in the function start_mode8() , it is necessary to define the mode 8 window number as there can be up to 10 different mode 8 windows, and the system needs to know which of them is being terminated. Note: To create a mode 8 window is an advanced procedure and requires some parameters to be set, as in this case the camera, some of them required by the function start_mode8() and others are contained in the global m8 structure (such as the variable m8.camera ). Example program: PROGRAM example_stop_mode8; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); write(0,0,0,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); stop_mode8(0); // Eliminates the region number 0 of mode 8 END - This program shows an initiation example of a mode 8 region, loading the map contained in the file wld_view.prg , and starting a region (the number 0 ) with start_mode8() function. This program waits in a loop until it detects the ESC key has been pressed, at which point it leaves the loop and then eliminates this region with the stop_mode8(0) function. ---See: start_mode8() - 1411,STRUCT m8 - load_wld() xadvance() xadvance( , ) Description: Advances the process the indicated angle as many points as the indicated distance shows as parameter. This function is equivalent to the function advance() , if the angle is used as its first parameter. The distance can be a negative number too, so the graphic of the process will advance (its coordinates x and y ) in the opposite direction to this angle. Example program: PROGRAM example_xadvance; PRIVATE angle2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=101; x=160; y=100; write(0, 0, 0, 0, \"Use the cursors to change the direction.\"); LOOP angle+=5000; IF (key(_right)) angle2-=10000; END IF (key(_left)) angle2+=10000; END xadvance(angle2,4); // We advance the process to points FRAME; END END - This example will draw a triangle on screen which will rotate in the selected direction chosen with the cursors, independent of the orientation of the graphic on the screen (of visible angle). The program advances 5 degrees per frame in the direction selected by the cursors. Remember that the angle is specified in thousandths of a degree. ---See: Use of the angles in the language - advance() - get_distx() - get_disty() char() char( ) Returns: The ASCII value of the (first) character contained in the literal parameter. Description: This function char() is used to obtain the ordinal value of a character. Example program: PROGRAM example_char; PRIVATE value; BEGIN // .. value=\"A\"; // The address of the literal \"A\" is assigned in memory. // .. value=char(\"A\"); // The ASCII value of \"A\" is assigned (65 in decimal). // .. END - In a program, the literals (texts between quotation marks) are translated as the memory address which they have been allocated. To assign to one variable a character (its ordinal value), instead of the address of the string, use this function. See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel() path_find() path_find( , , , , , , , ) Returns: Number of route points, or 0 if it doesn't find any. Description: Finds a route from the current coordinates of the process to a determined point, dodging the defined obstacles in a searching map (in the user's manual, can be found information about these maps). The mode. Defines the type of route searching mode, depending on the indicated as first parameter of the function. 0 - Searching less precise and faster. 1 - Searching more precise, but slower. The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. The route points. Now must be indicated the coordinates and where the process must go (the origin is taken as the initial coordinates of the process which executes the function path_find() ). This function returns a group of structure points, which are the points that form the route from the origin to the destination point. To do this, a structure must be declared which contains two fields (x,y), and as many registers as points that comprise the calculated route. The two last parameters of the function contain, the address ( OFFSET ) of this structure and its size ( SIZEOF() ), so the coordinates contained in this structure can be passed back to the function as the results. Example program: PROGRAM example_path_find; GLOBAL num_points; STRUCT points[100] x,y; END index; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); graph=200; mouse.graph=200; LOOP // Obtains the route to the mouse's coordinates num_points=path_find(0,0,201,2,mouse.x,mouse.y,OFFSET points,sizeof(points)); // If a route was obtained, it shows the route and advances to the destination IF (num_points>0) FOR (index=0;index 4) xadvance(fget_angle(x,y,points[0].x,points[0].y),4); ELSE x=points[0].x; y=points[0].y; END draw(1,24,15,0,x,y,points[0].x,points[0].y); END FRAME; delete_draw(all_drawing); END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file as its searching map . The square size of the searching map is 2 The main process is continuously finding a route to the mouse cursor with the function path_find() . The different segments of this route are shown with lines using the function draw() , and the coordinates are incremented with the function xadvance() . To obtain the distance and the angle to the next point of the route the functions fget_dist() and fget_angle() are used. To see if it's possible to go directly in a straight line between two points (without passing through any obstacle) the function path_line() can be used. The function path_free() determines if a particular point of the map is an obstacle or if it is a free point (accessible). ---See: path_line() - path_free() path_line() path_line( , , , , ) Returns: True (1) , if it is possible to go from one point to another without going through any obstacle, or false (0) if not. Description: It determines if, inside of a searching map, you can go in a straight line up to a point (starting from the current coordinates of the process), without passing through any obstacle of the searching map (in the user's handbook you can find information about these maps). In case of wanting to obtain a path between two points that dodges all the obstacles , use the function path_find() , and to see if the destination point is inside of an obstacle, use the function path_free() . The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. The route points. Now must be indicated the coordinates and where the process must go (the origin is taken as the initial coordinates of the process which executes the function path_find() ). Example program: PROGRAM example_path_line; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); graph=200; mouse.graph=200; LOOP // It checks if you can go in a straight line to the mouse IF (path_line(0,201,2,mouse.x,mouse.y)) IF (fget_dist(x,y,mouse.x,mouse.y)>4) xadvance(fget_angle(x,y,mouse.x,mouse.y),4); draw(1,24,15,0,x,y,mouse.x,mouse.y); ELSE x=mouse.x; y=mouse.y; END END FRAME; delete_draw(all_drawing); END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file is used as its searching map . The square size in the searching map is 2 . The main process is continuously checking if you can go in a straight line to the mouse coordinates with the function path_line() . If this is possible, a line is traced with the function draw() , and the process coordinates advance in this direction with the function xadvance() . To obtain the distance and the angle to the mouse cursor the functions fget_dist() and fget_angle() are used. ---See: path_find() - path_free() path_free() path_free( , , , , ) Returns: True (1) , if the point in a searching map is free (is not an obstacle), or false (0) if not. Description: Determines if, inside of a searching map, the coordinates are placed in an accessible zone, not overlapping with any obstacle (in the user's manual can be found information about these searching maps). In case of wanting to obtain a route to dodge the obstacles between two points the function path_find() must be used, and to see if it can go to a point in a straight line without passing through any obstacle use the function path_line() . The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. Now the coordinates and to be referenced must be indicated . Example program: PROGRAM example_path_free; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); mouse.graph=200; mouse.size=400; LOOP // Checks if the mouse is in an accessible zone IF (path_free(0,201,2,mouse.x,mouse.y)) mouse.angle+=5000; END FRAME; END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file as its searching map . the square size of the searching map is 2 The main process is continuously checking, with the function path_free() , if the mouse cursor is in a free zone, or over an obstacle. When the cursor is in a free zone, out of any obstacle, the cursor graphic will rotate. ---See: path_find() - path_find() new_map() new_map( , , , , ) Returns: The code of the graphic created. Description: Creates a new map in memory (without loading it from an file of the disk). To do this, the function requires the and (in pixels) of the map that must be created, a central point (of the same) in and , and the colour with which the map will be initially filled (the number of the colour inside of the active palette, from 0 to 255). This function acts similarly to the function load_map() , except that an file graphic from the disk is not loaded, and the graphic created is a solid graphic of just one colour. The value returned is the code of the graphic , which is a numeric value which must be specified to use the graphic, in the variable graph or, in general, in every function which requires a code of graphic in its parameters. Important: When, inside of a function, the code of file which belongs to the graphic is required , you must be indicate the code 0 (which is the code of the first file FPG that is loaded in the program). Example program: PROGRAM example_new_map; BEGIN // Is created a map of 16x32 points // with its centre in the point (0,0) // and with the colour 15 of the palette mouse.graph = new_map(16,32,0,0,15); // Is assigned as mouse cursor REPEAT FRAME; UNTIL (key(_esc)); unload_map(mouse.graph); // And finally the graphic is deleted END - In the example a map is created with the function new_map() and is saved as the code of the graphic which is returned in the variable mouse.graph , as the mouse cursor. Pressing the ESC key takes you out of the loop of the program and the graphic will be deleted with the function unload_map() (exactly the same as if it were loaded from an file). The function unload_map() frees up the computer memory used by the graphic when it is used no more, and due to that the code of the graphic is also required to know which graphic is the one that is to be deleted from memory. It is not necessary to delete the graphic from memory before exiting the program, because the system will do that automatically. ---See: load_map/pcx() - unload_map/pcx() - graph load_wld() load_wld( , ) Description: It loads a mode 8 map in a program. These maps are saved in the files with the extension WLD, and are created with the map's 3D menu (in the user's manual can be found further information on how to construct these maps). The parameters required are the which contains the map in WLD format, and the code of the which contains the file's textures. This file with the textures of the map needs to be previously loaded in the program with the function load_fpg() . Once the map is loaded, a region of mode 8 screen must be initiated with the function start_mode8() . The functioning is quite similar to the mode 7 which shows a graphic in a folded plane (see start_mode7() ). Example program: PROGRAM example_load_wld; GLOBAL fpgfile; BEGIN set_mode(m640x480); set_fps(70,0); fpgfile = load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",file); // Loads a file WLD start_mode8(id,0,0); ctype=c_m8; height=64; radius=64; m8.height=32; go_to_flag(0); LOOP IF (key(_right)) angle-=5000; END IF (key(_left)) angle+=5000; END IF (key(_up)) advance(24); END IF (key(_down)) advance(-9); END IF (key(_q)) z+=16; END IF (key(_a)) z-=16; END IF (key(_w)) m8.angle+=8; END IF (key(_s)) m8.angle-=8; END FRAME; END END - This program shows an initiation example of a mode 8 region, loading the map contained in the file wld_view.prg , and whose texture is found in the file wld_view.fpg . ---See: start_mode8() - go_to_flag() - load_fpg() start_mode8() start_mode8( , , ) Description: This is an advanced function that requires the user to have a certain amount of experience to use it. It creates a window with a mode 8, which generates a three-dimensional map. First the map must be loaded with the load_wld() function and then, the following parameters of this function need defining. - Identifier code of the process in which the mode 8 camera will be placed, the camera will be placed at the coordinates (x,y) , at height (z) and looking in the indicated direction defined by (angle) (these are local data predefined for the process). - Up to 10 mode 8 windows can be created on screen, numbered from 0 to 9 ; if just one is created, then define this as number 0 . This number will be needed to modify the parameters of the window, because the system needs to know which one of the 10 possible mode 8 windows you wish to modify. - Here will be indicated the rectangular region of the screen where the mode 8 is going to be shown. If the number of the region indicated is 0 , it will be shown full screen. Other regions must be defined previously with the function define_region() (a region is just a rectangular zone of the screen). Note: The functioning is very similar to the mode 7 which shows a folded plane (see start_mode7() ). Apart from the call to the function, some values of the global m8 structure must be initiated for the window to function correctly . This is a structure of 10 registers (one for each possible mode 8 window) and each register has the following fields: camera - Identifier code of the camera height - Height of the camera in relation to the process angle - Vertical angle of the camera (-128,128) z - Plane of depth (priority of impression of the region) The field camera is essential ,as that is asked as one of the calling parameters of the function start_mode8() because, without this field, the window can't determine the viewpoint from which the map will be initially viewed. Example program: PROGRAM example_start_mode8; GLOBAL fpgfile; BEGIN set_mode(m640x480); set_fps(70,0); fpgfile = load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",file); start_mode8(id,0,0); // Starts a mode 8 region ctype=c_m8; height=64; radius=64; m8.height=32; go_to_flag(0); LOOP IF (key(_right)) angle-=5000; END IF (key(_left)) angle+=5000; END IF (key(_up)) advance(24); END IF (key(_down)) advance(-9); END IF (key(_q)) z+=16; END IF (key(_a)) z-=16; END IF (key(_w)) m8.angle+=8; END IF (key(_s)) m8.angle-=8; END FRAME; END END - This program shows an initiation example of a mode 8 region, loading the file wld_view.prg , and whose textures are found in the file wld_view.fpg . To create a process where a graphic is displayed in the mode 8 region, its local variable ctype must be defined as well as c_m8 ( type of coordinate as the coordinate of mode 8 ). When a process is in a mode 8 region its variables x and y will be related to the point inside of the map sector (WLD), and the variable z will indicate the height. If there are several mode 8 windows, the process will by default be seen in all of them, if the process is wanted to be seen in just some of them, the local variable cnumber must be defined. For a process to have many graphics (many views), depending on the angle from which it is going to be viewed, you must define the local variable of the graphic xgraph (instead of the variable graph ). Note: To eliminate a mode 8 region you must be use the function stop_mode8() , indicating the number of m8 . ---See: STRUCT m8 - load_wld() - go_to_flag() - stop_mode8() go_to_flag() go_to_flag( ) Description: Places a process in a mode 8 region in a position indicated by a flag, the process calling the function is the one placed in that position, the only parameter needed is the , as a mode 8 region can have more than one predefined flag position. After the function has been called, in the next FRAME the process will be placed at the flag coordinates. The height of the flag will always be understood to be the minimum height of the sector where it is going to be found. The flags are placed in the editor of the three-dimensional maps, control of which is explained in the user's manual. Note: This function is equivalent to giving the process the coordinates a flag ( x , y , z ). Example program: PROGRAM example_go_to_flag; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); // Places the process camera at flag 0 LOOP FRAME; END END - This example program initialises a mode 8 region, loading the map contained in the wld_view.prg file using the load_wld() function, and starts a region with start_mode8() . Then, it places the process (which acts as the camera of the window) in the position indicated by the flag number 0 of the map sector. ---See: start_mode8() - STRUCT m8 - load_wld() set_sector_height() set_sector_height( , , ) Description: Modifies the height of the ground or ceiling of a mode 8 sector. The following parameters are required: - Number of sector of the map for which the height is wished to be modified. This number can be obtained from three-dimensional maps editor, as explained in the user's manual. - The new sector height of the ground must be indicated (a value from 0 to 4096), if ** -1** is indicated as the parameter, the current sector height of the ground will remain (useful to ascertain the height of the ground). - The new sector height of the ceiling must be indicated (a value from 0 to 4096), if ** -1** is indicated as the parameter, the current sector height of the ceiling will remain (useful to ascertain the height of the ceiling). To start a mode 8 region, the function start_mode8() must be called. Note: If the height of the ceiling is the same as the ground's height this sector won't be accessible (if this one is inside of another, it will appear as a column). The height of the ceiling must be smaller than the height of the ground. Example program: PROGRAM example_set_sector_height; GLOBAL sector=255; altitude; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=64; LOOP altitude=1000+get_distx(angle1,64); angle1+=5000; set_sector_height(sector,altitude,-1); FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , and places it at the predetermined coordinates with the function go_to_flag() . Then, inside of the program main loop, the height of the ground of the sector 255 is fixed with the function set_sector_height() . The function get_sector_height() allows you to find the ground and ceiling heights in a mode 8 sector. ---See: get_sector_height() - start_mode8() - STRUCT m8 get_sector_height() get_sector_height( , , ) Returns: The height of the ground and ceiling of a mode 8 sector (in the variables which offset are indicated as the two last parameters). Description: This function allows you to determine in a program, the height of the ground and ceiling of a determined sector, inside of a mode 8 sector. To do this, the is required , and the OFFSET (address of memory) of the two variables where the result will be returned. This information also can be obtained inside of the editor of three-dimensional maps as explained in the user's manual. Example program: PROGRAM example_get_sector_height; GLOBAL ceiling_height; floor_height; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtain the heights of a sector get_sector_height(255,OFFSET floor_height,OFFSET ceiling_height); // ... END - This small example shows how the function get_sector_height() must be called to obtain the heights of a sector (in this case, in the variables ceiling_height and floor_height these values are obtained for the sector number 255 ). To establish the height of a sector, the function set_sector_height() must be used. ---See: set_sector_height() - start_mode8() - STRUCT m8 set_point_m8() set_point_m8( , , ) Description: Modifies the coordinates of a three-dimensional map's vertex on a mode 8 sector. The following parameters are required: - Number of vertices of the map which position is wanted to modified. This number can also be obtained from the editor of the three-dimensional maps, as is explained in the user's manual. , - The new coordinates of the vertex must be defined. The coordinates inside of a three-dimensional map are placed with the rank ( 0 .. 30200 ). To create a mode 8 region, the function start_mode8() must be called. Note: This is a function which can give rise to multiple errors of visibility . For that reason, it is not recommended for use by inexperienced users. The vertices can only move inside of the sector in which they started, sector boundaries can't be crossed (not the vertex, nor the lines which these make) and, besides, all sectors which can't contain processes may not be moved. Example program: PROGRAM example_set_point_m8; GLOBAL position1; position2; angle1; angle2; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=64; LOOP position1=3400+get_distx(angle1,150); angle1+=5000; position2=3400+get_distx(angle2,150); angle2+=7000; set_point_m8(1620,position1,9280); // Fixes the vertex 1620 set_point_m8(1621,position2,9456); // Fixes the vertex 1621 FRAME; END END - This small example initialises a mode 8 region, loading the map wld_view.wld , and places it in the predetermined coordinates with the function go_to_flag() . Then, inside of the program's main loop, the position of the vertex 1620 and 1621 is fixed with the function set_point_m8() . The function get_point_m8() allows you to find the coordinates of a vertex of a three-dimensional map in a mode 8 region. ---See: get_point_m8() - start_mode8() - STRUCT m8 get_point_m8() get_point_m8( , , ) Returns: The coordinates of a vertex of a mode 8 map (in the variables which offset , indicated as the two last parameters). Description: This function allows you to determine inside of a program, the coordinates of a specific vertex, inside of a mode 8 region. To do this, the is required, and the OFFSET (pointer) of the two variables where the result is stored. This information can also be obtained from the three-dimensional maps editor, which is explained in the user's manual. Example program: PROGRAM example_get_point_m8; GLOBAL position_x; position_y; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains a vertex's coordinates get_point_m8(1620,OFFSET position_x,OFFSET position_y); // ... END - This small example shows how the function get_point_m8() is called to obtain the position of a sector vertex (in this case, in the variables position_x and position_y ). To set or establish the positions of a vertex, the function set_point_m8() must be used. ---See: set_point_m8() - start_mode8() - STRUCT m8 set_fog() set_fog( , ) Description: Modifies the fog of a mode 8 region initiated with the function start_mode8() , to do this, the following parameters are required: - Percentage or initial distance of the fog (from 0 to 100), in this way, the point from which the effect is applied is determined. - Percentage or final distance of the fog (from 0 to 100), in this way, the point from which the fog is solid/completely opaque is determined. Normally the position or final percentage is established as the double of the initial, the further apart the values are, the more slowly the fog will appear. Example program: PROGRAM example_set_fog; GLOBAL fogpos; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); FRAME; z+=128; LOOP fogpos=25+get_distx(angle1,20); angle1+=5000; set_fog(fogpos,fogpos*2); // Establishes the fog level of the mode 8 FRAME; END END - This small example shows how the function set_fog() must be called to modify the fog of a mode 8 region. The variable position varies from 5 to 45 (using the function get_distx() ), this will be the initial position, the final one will be fixed as double the initial one. Note: The function set_env_color() allows you to fix the ambience colour or the fog colour of a mode 8 region. ---See: set_env_color() - start_mode8() - STRUCT m8 set_sector_texture() set_sector_texture( , , , ) Description: Modifies the textures of ground and ceiling of a mode 8 sector. The following parameters are required: - Number of the map sector for which textures are to be modified. This number can be obtained from the three-dimensional maps editor, as is explained in the user's manual of the program. - The code of the new texture graphic to be used as the ground texture of the sector (ie: the number of the graphic inside of the FPG which contains every texture of the mode 8 region). If a ** -1** is indicated as parameter the current texture will remain (to modify just the ceiling texture). - The code of the new texture graphic to be used as the ceiling texture of the sector (ie: the number of the graphic inside of the FPG which contains every texture of the mode 8). If a ** -1** is indicated as parameter the current texture will remain (to modify just the ground texture). - Luminosity of the texture, from 0 (ambience colour, which is normally black) up to 15 (texture with the original colours). If a ** -1** is indicated, the current level of luminosity in the sector will remain unchanged. Note: every texture must be contained in the same file FPG, this is the file which is loaded with load_fpg() function and which number is given as the parameter of the function load_wld() . Example program: PROGRAM example_set_sector_texture; GLOBAL texture=94; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=128; m8.angle=-64; LOOP IF (texture++==103) texture=94; END set_sector_texture(255,texture,-1,15); FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , which is placed at the predetermined coordinates with the function go_to_flag() . Then, inside of the program main loop, the ground texture of the sector 255 is set with the function set_sector_texture() . The function get_sector_texture() allows one to find the textures (and luminosity) that are assigned to a mode 8 sector. The function set_wall_texture() allows you to establish the texture of a wall. ---See: get_sector_texture() - set_wall_texture() - set_sector_height() get_sector_texture() get_sector_texture( , , , ) Returns: The luminosity, and the textures of the ground and ceiling of a mode 8 sector (stored in the variables which offset are indicated as the parameters). Description: This function allows you to determine which are the textures in a program for the ground and the ceiling and/or the luminosity of a determined sector, inside of a mode 8 region. To do this, the is required , and the OFFSET (pointer) for the variables where the results will be stored are also required. Example program: PROGRAM example_get_sector_texture; GLOBAL ceiling_texture; floor_texture; luminosity; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains the luminosity and textures of a sector get_sector_texture(255,OFFSET ceiling_texture,OFFSET floor_texture,OFFSET luminosity); // ... END - This small example shows how the function get_sector_texture() must be called to obtain the textures and the luminosity of a sector (in this case, in the variables floor_texture , ceiling_texture and luminosity these values are obtained for the sector number 255 ). The function set_sector_texture() allows you to establish the textures and luminosity of a mode 8 sector dynamically. The function get_wall_texture() allows you to find what the assigned texture of a mode 8 wall is . ---See: set_sector_texture() - get_wall_texture() set_wall_texture() set_wall_texture( , , ) Description: Modifies the wall texture of a mode 8 sector. The following parameters are required: - Number of the wall texture required. This number can be obtained in the three-dimensional maps editor, as is explained in the user's manual of the program. - The code of the graphic which is to be assigned as the new wall texture (the number of the graphic inside of the FPG which contains every mode 8 texture) must be indicated. If a ** -1** is indicated as the parameter, the current texture will remain unchanged. - Luminosity of the texture, from 0 (ambience colour, which is normally black) up to 15 (texture with the original colours). If a ** -1** is indicated, the current level of luminosity will remain unchanged. Note: every texture must be contained in the same file FPG, this is the file which is loaded with load_fpg() and which number is given as a parameter to the function load_wld() . Example program: PROGRAM example_set_wall_texture; GLOBAL texture=104; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=128; LOOP IF (texture++==113) texture=104; END set_wall_texture(511,texture,15); // Modifies a wall texture FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , and it is placed in the predetermined coordinates with the function go_to_flag() . Then, inside the program main loop, the texture of the wall number 511 is fixed with the function set_wall_texture() . The function get_wall_texture() allows you to find the current texture of a wall. The function set_sector_texture() allows you to establish the {textures of ground and ceiling} of a mode 8 sector. ---See: get_wall_texture() - set_sector_texture() - set_sector_height() get_wall_texture() get_wall_texture( , , ) Returns: The luminosity and the texture of a mode 8 wall (in the variables which offset are indicated in the parameters). Description: This function allows you to determine inside of a program, what the texture and the luminosity is of a determined wall, inside of a mode 8. To do this, the is required, and the OFFSET (pointer) of the variables where the result will be stored. Example program: PROGRAM example_get_wall_texture; GLOBAL texture; luminosity; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains the luminosity and texture of a wall get_wall_texture(255,OFFSET texture,OFFSET luminosity); // ... END - This small example shows how the function get_wall_texture() must be called to obtain the texture and the luminosity of a wall in a sector (in this case, the variables texture and luminosity are assigned to the wall number 255 ). The function set_wall_texture() allows you to establish the texture and luminosity of a mode 8 wall dynamically. The function get_sector_texture() lets us know which are the floor and ceiling textures of a mode 8 sector. ---See: set_wall_texture() - get_sector_texture() set_env_color() set_env_color( <% red> , <% green> , <% blue> ) Description: Modifies the colour of the ambience or fog of a mode 8 sector, to do this the components (red), (green) and (blue) of the sector are required. The three components must be specified as percentage, from 0 to 100 . By default, the fog is set as a black colour (0,0,0), but this colour can be modified to create a different ambience. Example program: PROGRAM example_set_env_colour; GLOBAL light; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); FRAME; set_fog(30,90); z+=128; LOOP light=50+get_distx(angle1,50); angle1+=5000; set_env_color(light,light,light); // establishes the ambience colour FRAME; END END - This small example shows how the function set_env_color() must be called to modify the fog colour of a mode 8 region. The variable light varies from 0 to 100 (using the function get_distx() ), this percentage is the same for the three components of the colour, so this will gradually change from black to white , going through all the grey scale in between. Note: The function set_fog() allows you to fix the density of the fog or ambience of a mode 8 region. ---See: set_fog() - start_mode8() - STRUCT m8 strcpy() strcpy( , ) Returns: Copies a string from the origin to the string destination. Description: Copies the to the , (the original content of the string destination will be lost). The must be a data type STRING , of a length long enough to contain the text of the . Example program: PROGRAM example_strcpy; GLOBAL STRING string1=\"Initial text\"; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,192,0,\"Press [SPACE] to copy another text in \"); LOOP IF (key(_space)) strcpy(string1,\"Final text\"); // Modifies string1 END FRAME; END END - When the length of the copied string is smaller than 1024 characters, this same operation can be done with the following statement: (continuing with the previous example): string1 = \"Final text\"; With a generic statement of assignation as the following: = ; The Being always of a data type STRING . To join some text strings together the function strcat() must be used. ---See: strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel() strcat() strcat( , ) Returns: Joins two strings together and returns the address of the string destination. Description: Joins two text strings, copying the and adding on the end of the text contained in the . The must be of data type STRING , of a length long enough to contain both strings. Example program: PROGRAM example_strcat; GLOBAL STRING string1=\"Beginning \"; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,192,0,\"Press [SPACE] to add a text to \"); LOOP IF (key(_space)) strcat(string1,\"Final\"); // Adds a text to string1 END FRAME; END END - When the length of the resultant string is smaller than 1024 characters, this same operation can be achieved with the following statement : (continuing with the previous example): string1 = string1 + \"Final\"; (or) string1 += \"Final\"; Or with a generic statement of assignation (or with the symbol += , of operative assignation) such as the following: = + ; (or) += ; Being always of data type STRING . To copy text strings, the function strcpy() must be used. To separate (or substrate) text strings, the function strdel() must be used. ---See: strcpy() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel() strlen() strlen( ) Returns: The length of the string, in characters (with spaces included). Description: Counts the number of characters of the text given as a parameter, or contained currently in the passed string. The can be a literal (text between quotation marks) or data of any other type. Example program: PROGRAM example_strlen; GLOBAL STRING string1=\"Text example\"; length_string1; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,20,0,\"Length of :\"); length_string1=strlen(string1); // calculates the length write_int(0,0,30,0,OFFSET length_string1); LOOP FRAME; END END - A character or string can be added to another string with the function strcat() , or with a statement of assignation such as the following: string1+=\"a\"; To remove characters of a string use strdel() , although it is possible to eliminate characters at the end of a string with statements such as the following: string1--; string1-=1; string1=string1-1; ---See: strcpy() - strcat() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel() strcmp() strcmp( , ) Returns: ** +n** - If the first string is bigger than the second. ** 0** - If the strings are identical. ** -n** - If the first string is smaller than the second. Description: Compares two text strings, character per character, giving back 0 when both strings are identical. Example program: PROGRAM example_strcmp; GLOBAL STRING mystring; BEGIN // ... IF (strcmp(mystring,\"abc\")==0) // The two strings are identical ... END // ... END - if the strings have less than 1024 characters, the comparison of strings can also be done with the typical operators of comparison. For example, the comparison of the previous example could be done with the following statement: IF (mystring==\"abc\") //... END In the same way, the symbol <> can be used to compare if the two strings are different, with the symbols < or <= if a string is smaller, or identical to another, etc. To search for a string inside another (to see if it is contained in it), the function strstr() , must be used, and to see if a string contains a specific character the function strchr() must be used. ---See: strcpy() - strcat() - strlen() - strchr() - strstr() - strset() - upper() - lower() - strdel() strchr() strchr( , ) Returns: ** -1** If none of the characters were found inside of the string. ** +n If one of the characters was found in the position n** of the string. Description: Searches for one or some in a . It receives the string as first parameter and, as the second, one or more characters in a literal (between quotation marks). This function will determine if the string contains any of the characters and, if so, will indicate at which position inside the string (from 0) the character appears. In the character appears on more than one occasion, the function will always return the first position the character occurred. Example program: PROGRAM example_strchr; GLOBAL STRING mystring=\"FGHIJK\"; position; BEGIN write(0,0,0,0,\"First vowel of is in position:\"); position=strchr(mystring,\"AEIOU\"); write_int(0,0,10,0,OFFSET position); LOOP FRAME; END END - In this example the function strchr() is used to determinate the first vowel of mystring is the position 3 of the string. The characters of a data of STRING can be accessed always as if this would be a table of characters. For example, to change in the data mystring of the previous example, the character \"I\" for a character \"-\" the following statement could be used: mystring[3]=char(\"-\"); To convert a character, contained in a literal, in its ordinal value (ASCII) the function char() is used. To determinate if a string is completely contained in another (if appears as a substring inside of the same), the function strstr() must be used. ---See: strcpy() - strcat() - strlen() - strcmp() - strstr() - strset() - upper() - lower() - strdel() strstr() strstr( , ) Returns: ** -1** If the substring wasn't found inside of the string. ** +n If it was found in the position n** of the text string. Description: Searches for the sequence of characters contained in the in a . This function will determine if a text string contains the substring (as \"HOUSE\" contains \"USE\") and, if so, will indicate whereabouts the substring appears inside of the string (from 0, 1 in the previous example). If the substring on more than one occasion, the function will return the position where the string first occurred. Example program: PROGRAM example_strstr; GLOBAL STRING mystring=\"This is an example string.\"; position; BEGIN position=strstr(mystring,\"an\"); write_int(0,0,10,0,OFFSET position); LOOP FRAME; END END - In this example the function strstr() is used to determine where the substring \"is\" is found inside mystring , it will return the position 8 . To change from capital letters to small letters the functions upper() and lower() can be used. To determine if a string contains a character, the function strchr() must be used, which, allows you to search for any character inside the specified group simultaneously. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strset() - upper() - lower() - strdel() strset() strset( , ) Description: Assigns to every position of the the indicated as the second parameter. The function can receive the in two ways; as a literal (the character between quotation marks), or as its ordinal (its ASCII value) which must be a value between 0 and 255 . The complete string will be replaced with this character. The length of the string depends on the indicated value between \"[]\" in its initiation, if the function doesn't know the length of the data of type STRING , a string of 256 characters will be created (from the position 0 to 255). Example program: PROGRAM example_strset; GLOBAL STRING mystring=\"This is an example string.\"; BEGIN write(0,0,0,0,\"content of (press space to change it):\"); write(0,0,10,0,mystring); LOOP IF (key(_space)) strset(mystring,\" \"); // Fills up the string with \" \" END FRAME; END END - To calculate the current length of a string, the function strlen() will be used. To delete characters from a string (from the beginning and from the end) the function strdel() must be used. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - upper() - lower() - strdel() upper() upper( ) Returns: If a character was a small letter (lowercase), it returns the same character but as a capital letter (uppercase). Description: converts a string (or just a character) to capital letters, including the special characters, like the letter \"\u00b1\" or the accentuated vowels. This function works in one of two ways, depending on the parameter it receives: If it receives a text string (or literal between quotation marks), it will convert to capital letters every contained character in the string and won't return any significant value (just the cursor of the receipt string). If it receives just one character (its ordinal value or ASCII value), it will return the character converted into a capital letter (but just its ordinal value), and the function will not change any data in memory. Example program: PROGRAM example_upper; GLOBAL STRING mystring=\"This is an example string.\"; STRING myletter=\"a\"; BEGIN upper(mystring); // converts a string to capital letters upper(myletter); // converts a character to capital letters write(0,0,0,0,mystring); write(0,0,10,0,OFFSET myletter); LOOP FRAME; END END - This example has defined two global data ( mystring and myletter ), the function upper() will be used to convert it to capital letters, and then it will be shown on screen. This function will not modify those characters which are not small (lowercase) letters. The function lower() is the opposite to upper() , because it can converts a string (or a character) to small (lowercase) letters. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - lower() - strdel() lower() lower( ) Returns: If a character is given to a capital letter (uppercase), it returns the character changed to a small letter (lowercase). Description: Converts a string (or a simple character) into small letters, including the special characters, like the letter \"\u00b1\" or the accented vowels. This function can work in one of two modes, depending on the parameter given: If it receives a text string (or literal between quotation marks), it will change into small letters every character contained in the string and will not return any significative value (just the cursor of the string given). If it receives just a character (its ordinal value or ASCII), it will return the character changed into a small letter (its ordinal value), and the function won't change any data in memory. Example program: PROGRAM example_lower; GLOBAL STRING mystring=\"THIS IS AN EXAMPLE STRING\"; STRING myletter=\"A\"; BEGIN lower(mystring); // Changes a string into small letters lower(myletter); // Changes a character into small letters write(0,0,0,0,mystring); write(0,0,10,0,OFFSET myletter); LOOP FRAME; END END - This example has defined two global data ( mystring and myletter ), the function lower() will be used to convert them into small letters, and then will be shown on screen. This function won't modify those characters which are not capital letters. The function upper() is the opposite to lower() , because it changes a string (or a character) into capital letters. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - strdel() strdel() strdel( , , ) Description: This function deletes characters from a . Characters Will be eliminated from the beginning of the string and characters from the end of it. To eliminate just characters from the beginning of the string you must indicate 0 as the , and to eliminate just from the end, set 0 as { }. Example program: PROGRAM example_strdel; GLOBAL STRING mystring=\"This is an example string.\"; BEGIN strdel(mystring,5,9); write(0,0,0,0,mystring); LOOP FRAME; END END - This example uses the function strdel() to eliminate the first 5 characters of and the last 9 , and then, show the resultant string on screen (\"is an examp\"). Note: If the quantity of characters to delete is negative (for the beginning or for the end), the function will add spaces to the string. It is also possible to eliminate characters from the end of a string with statements such as the following: string1--; string1-=1; string1=string1-1; ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() screen_copy() screen_copy( , , , , , , ) Description: Copies a screen region to a region of any graphic. This is a potent function that can be very useful, because it gives \"feedback\" from the computer screen, and can send an image of the screen to a graphic (opposite operation to the normal). First you must define the number of the rectangular which is going to be copied from the screen (of the previous image of the program), these regions are defined with the function define_region() . The region number 0 is always related to the entire screen. Then, the graphic where the image is going to be transferred to must be indicated with the parameters and (the file will be the number 0, if the graphic belongs to the first FPG loaded, or if it has been loaded already). Finally, the zone inside of the graphic the image must be transferred to will be defined. This will be defined as , , and , related to the coordinates inside of the graphic (being the coordinates [0,0] its upper left corner). Example program: PROGRAM example_screen_copy; GLOBAL angle1; angle2; BEGIN load_fpg(\"help/help.fpg\"); graph=2; x=160; y=100; put(0,graph,x,y); LOOP // Copies the screen (region 0) to the graphic 2 screen_copy(0,0,2,0,0,320,200); angle1+=1000; angle2+=1971; angle=get_distx(angle1,25000); size=95+get_disty(angle2,30); FRAME; END END - In this example the file help.fpg is loaded, in which the graphic number 2 is a cell of different colours, and is placed on the screen and defined as the graphic of the main process, which will rotate and change its size (depending on the angle and angle2 , respectively). Then the function screen_copy() is used again to send the updated image of the screen to this graphic, so this effect happens. Note: The size of the screen region (the transferred zone) and the size of the graphic region (where it's transferred) doesn't have to match . The function screen_copy() will do a reduction or ampliation when needed to adjust the size of the transferred zone. ---See: define_region() - clear_screen() - graph qsort() qsort( , , ) Description: Orders or shuffles one of the fields of a program structure . It is a simple but useful function which allows the quick ordering and shuffling of data structures. Its use is very simple, all is required is the , the one of the , and the ; one of the indicated now: 0 - Ascendent ordination (from min to max). 1 - Descendent ordination (from max to min). 2 - Random ordering (shuffling) Any of the data contained in the structure can be used as the index field, without depending on if it is numeric data or a string of text (in which case it will be ordered alphabetically) Example program: PROGRAM example_qsort; GLOBAL STRUCT mystructure[9]; STRING name[32]; points; x,y; END BEGIN //... // Orders the registers of mystructure, the one with the biggest // score being placed at the beginning qsort(mystructure,points, 1); //... END - This example shows the easy use of the function qsort() to order a structure, that can represent any type of object inside of a program. It is not necessary that the field used as index ( points in this case) is the first field of the structure. Note: The shuffling of a structure requires a field which makes differences between the different registers of the same. This operation can be useful to give \"randomness\" to a program (for example, to \"mix\" or \"shuffle\" a deck of cards). load_song() load_song( , ) Returns: Identifier of the loaded song, or -1 if an error occurs. Description: Loads a song from an file MOD, S3M or XM, to its later reproduction. The function requires the name of the file which contains the music module, and if this one must be played back just once (indicating 0 in ) or indefinitely (indicating 1 ). These music modules can be composed with multiple shareware programs or freeware programs. In DIV Games Studio these music modules can be played back, in the created programs, but you cannot compose new modules. Example program: PROGRAM example_load_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); // Loads an XM module, with replay song(id_song); write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() , indicating that this one must be played back indefinitely. The reproduction of the file is begun with a call to the function song() . To delete a song from memory, the function unload_song() must be used. The sound volume of the song can be controlled with the function set_volume() and the data contained in the setup structure . Note: With this version of DIV Games Studio comes included some files of freeware music modules in the directory MOD . Note: To reproduce songs contained in a CD-Audio track the functions play_cd() and stop_cd() must be used. ---See: unload_song() - song() - play_cd() - Setup structure unload_song() unload_song( ) Description: Deletes from memory the music module whose identifier is given as the parameter. This is the value which the function returns load_song() when is loaded into memory. After deleting a module you must be very cautious not to use it again in the program, otherwise the program would crash. It is not necessary to delete the modules before finishing the program because the system will do it automatically. So, just delete from memory the modules which are not going to be used for the time being in order to liberate computer memory to load other resources (other files of graphics, sounds, fonts, etc). Example program: PROGRAM example_unload_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); // Sets free the filled memory by the module END - This example loads the module contained in the file help.xm with the function load_song() . The playback of the file is indicated with a call to the function song() . The program will continue to play this module until the ESC key is pressed, the module is then deleted from memory with the function unload_song() , indicating as the parameter id_song which contains the identifier of the module returned when loaded. Note: songs that are CD-Audio tracks, which can be played with the function play_cd() , don't use up computer memory, so they cannot be deleted with the function unload_song() . ---See: load_song() - song() song() song( ) Description: Starts playback of a music module loaded with the function load_song() . The function will receive as its only parameter the { } to play back. Just one module can be played at the same time, if another starts, the previous module will stop. But a music module, a CD-Audio track (see play_cd() ) and multiple sound effects (see sound() ) can be played at the same time . The playback will always begin from the start of the module (the beginning of the song). To play a specific part of the module then use the function set_song_pos() , which sets the position from where playback of the module will start. Example program: PROGRAM example_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); // Starts the reproduction of the music module write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() , indicating that this must be played indefinitely (this must be indicated in the file's load). Then the playback of the file begins with the function song() . The program will then enter a loop in which this module will still be playing, until the ESC key is pressed and the program finishes. The sound volume of playback can be controlled with the function set_volume() and the contained data in the setup structure . Note: To finish the playback of a music module the function stop_song() must be used. Note: The function is_playing_song() can find if the module is being currently played. ---See: load_song() - stop_song() - play_cd() - sound() stop_song() stop_song( ) Description: Stops the playback of the music module (MOD, S3M or XM) which is being played. This function doesn't require any parameter, because only one music module can be played at the same time. It is not essential to stop the playback of a music module before being deleted from memory (an operation made with the function unload_song() ), this is done automatically. Example program: PROGRAM example_stop_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press SPACE to stop the song ...\"); LOOP IF (key(_space)) stop_song(); // Stops the module END FRAME; END unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() . The playback of the file begins with a call to the function song() . The program will then enter into a loop in which this module will still be playing, when the space bar is pressed it makes a call to the function stop_song() and the module finishes. To delete a song from memory the function unload_song() must be used, all the programs created in DIV Games Studio will free any filled memory automatically at the end. Note: To stop a song of CD-Audio the function stop_cd() is used, and for a sound effect, use the function stop_sound() . Note: The function is_playing_song() can find out if a module is playing. ---See: song() - load_song() - play_cd() - sound() set_song_pos() set_song_pos( ) Description: Fixes the position of the music module playback (the \"pattern\" number). This is a number between 0 and the max number of pattern of the module. This value varies for each module, and can be defined in the programs used to compose them. The modules usually have quite a variable number of patterns, though the average is usually situated between 30 and 40. Inside each pattern, the modules have a determined number of lines (normally 64), in which appear the musical notes, so each pattern could be defined as a small section of the music module. To obtain the current position which is being played back the function get_song_pos() is used. The position of the module can be changed if the module is playing or has stopped. This function can be used to advance or to retard the playback of the module, to implement diverse loops in certain parts of a module, etc. Example program: PROGRAM example_set_song_pos; GLOBAL id_song; position_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press SPACE to change the position of the module ...\"); write(0,0,20,0,\"position:\"); write_int(0,0,30,0,OFFSET position_module); LOOP IF (key(_space)) position_module=rand(0,19); set_song_pos(position_module); // Changes the position of the module END position_module=get_song_pos(); FRAME; END END - This program loads the module contained in the file help.xm and then starts its playback with the function song() . From this moment the current position of the module will be shown on screen and it can be changed by pressing the space bar (a random position will be assigned between 0 and 19, because this module has 20 patterns). Note: The playback line of a module can't be set (inside each pattern), but the value can be obtained with the function get_song_line() . ---See: get_song_pos() - song() - load_song() get_song_pos() get_song_pos( ) Returns: The current position of the musical module which is being played. Description: Returns the current position of playback of the musical module, this position can be set with the function set_song_pos() . This is a number between 0 and the max number of pattern of the module. This value is different for each module, and is defined in the programs used to compose them. The modules can have any variable number of patterns, although the average is between 30 and 40. Inside each pattern the modules have a determined number of lines (normally 64), in which appear the musical notes, therefore each pattern can be defined as a small section of the musical module. Example program: PROGRAM example_get_song_pos; GLOBAL id_song; position_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Position of the module:\"); write_int(0,0,10,0,OFFSET position_module); LOOP position_module=get_song_pos(); // Obtain the position FRAME; END END - This program loads the module contained in the file help.xm and then initiates its playback with the function song() . From this moment the current position of the module on screen will be shown, obtained with the function get_song_pos() . Note: the line number which is played back Can be obtained, inside the pattern, with the function get_song_line() . ---See: get_song_line() - set_song_pos() - song() get_song_line() get_song_line( ) Returns: The line number of the musical module. Description: The line number of a musical module playing can be obtained With this function. This current position, or pattern, can be obtained with the function get_song_pos() . Inside each pattern the modules have a determined number of lines (normally 64), in which appear musical notes. The modules often have a different number of patterns, although the average is between 30 and 40. Example program: PROGRAM example_get_song_line; GLOBAL id_song; line_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Line of module:\"); write_int(0,0,10,0,OFFSET line_module); LOOP line_module=get_song_line(); // Obtain the number of line FRAME; END END - This program loads the module contained in the file help.xm and then initiates its playback with the function song() . From this moment the current line of the module is shown on screen, obtained with the function get_song_line() . Note: The line of a musical module Cannot be set, although it is possible to fix the position where playback begins with the function set_song_pos() (always will begin from the line 0 of the pattern). ---See: #219,get_song_pos()} - set_song_pos() - song() is_playing_sound() is_playing_sound( ) Returns: 0 - If the channel is stopped. 1 - If is going the sound by the channel. Description: This function allows you to know if one of the sound channels are playing sound or if it is disposed. the is required as the parameter, this value is obtained as the return of the function sound() after initiating the playback of the sound effect. Example program: PROGRAM example_is_playing_sound; GLOBAL sound_id; channel_id; BEGIN write(0,0,0,0,\"Press ESC to finish.\"); sound_id = load_pcm(\"help/help.pcm\",0); channel_id = sound(sound_id, 256, rand(100,400)); REPEAT // If the playback has finished, return the sound IF (NOT is_playing_sound(channel_id)) channel_id = sound(sound_id, 256, rand(100,400)); END FRAME; UNTIL (key(_ESC)); END - This example uses a function to continually test and restart the sound, controlled by the program, instead of automatically (as is often indicated in the loading of the sound, in the functions load_pcm() or load_wav() ). The playback again always initiates once the sound channel is free, it means, each time when playback of the sound has finished. The program uses this circumstance (manual control of the replay) to emit the sound with a different frequency in each case, this couldn't be done with the automatic replay. This frequency is obtained as a value between 100 and 400 with the function rand() . Note: The same sound can be played back by different channels each time, therefore it is necessary to save the channel number each time when the playback is initiated. ---See: sound() - change_sound() - is_playing_song() is_playing_song() is_playing_song( ) Returns: 0 - Any module is playing. 1 - Is playing a musical module. Description: This function determines if a digital musical module of the file MOD, S3M or XM is being played. These modules must be loaded with the function load_song() and their playback is initiated with the call to song() . Only one module can be played back at the same time, therefore this function doesn't require any parameter, only returns 1 if there is one module reproducing. Example program: PROGRAM example_is_playing_song; GLOBAL id_song; sounding; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"ENTER initiate the module / SPACE to stop it\"); write_int(0,0,10,0,OFFSET sounding); LOOP IF (key(_enter)) song(id_song); END IF (key(_space)) stop_song(); END sounding = is_playing_song(); // Determines if is playing FRAME; END END - This example loads musical module contained in the file help.xm and permits, inside one loop, initiate it with the key ENTER and stop it with the space bar. Inside the same loop is used the function is_playing_song() to determine if it is playing each moment. Note: To finish the playback of one musical module must be used the function stop_song() . ---See: load_song() - song() - is_playing_sound() fopen() fopen( , ) Returns: The handle or identifier of the open file, or 0 if an error was produced. Description: Opens a data file to read or write to, with the help of a handle or identifier of file which this function returns from the open or created file. the to open or create is required , and the of opening, which must be a literal (text in inverted commas) inside the following: \" r \" - Open the file for reading of the data contained in it. \" w \" - Create the file to write (if it already exists, it will lose the presently contained data). \" a \" - Open the file to write to after finishing with it, or it creates the file if it didn't exist. \" r+ \" - Open an existent file to activate it, permitting reading and writing. \" w+ \" - Create a file to write to, permitting also its reading. \" a+ \" - Open an file to read it from any position and write new data to add on the end. Once an file is opened, you can use all the functions for files based in handles , but once the necessary operations have been completed in the file must not be closed , you should then close it with the function fclose() . The main functions are fread() for reading the data inside the file and fwrite() to write the data; it is important to open the file in the appropriate mode for the requested operations. For example, you cannot write in the file if it was opened only for reading. Example program: PROGRAM example_fopen; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); // Open file to write fwrite(OFFSET list1,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); // Open file to read fread(OFFSET list2,4,myhandle); fclose(myhandle); END - This example program has defined two global lists; list1 with four values initiated in 11, 22, 33 and 44, and list2 with four without initiates (zero). The functions of files are used to write in one file the content of the list1 and then load it over the list2 . After finishing the program, the data of the first list will have been copied into the second. the function fopen() is called on two occasions, the first to {create it and write} in it and the second to open it and read its contents. It is important to underline that each time when you open or create the file, you must close it with the function fclose() (can be seen how in the example the file is closed on two occasions). The function fseek() allows you to situate the pointer of reading/writing at any position in the file. In this way, data at any point of the file can be read or written. The function flush() empties the buffers of writing and allows you also to check how many files are open at any moment. Note: The functions save() and load() allow you also to save the data in files of the disk and restore them. These functions are less useful, but their use is easier than the functions based in handles here described. ---See: fclose() fread() - fwrite() - save() fclose() fclose( ) Returns: Number of closed files. Description: Closes an file opened with the function fopen() , fclose must receive as parameter the handle or identifier of file returned by this function. In the second modality, the function fclose() can {close all opened files} at one time, for this you indicate 0 (zero) as its parameter, instead of handle . Anyway, the function returns the number of files which were closed, if it returns 0 it can mean one of these cases: ** -** There was no open file. ** - The passed handle doesn't correspond to any opened file. ** - The file corresponding to this handle was already closed. All open files must be closed before the program finishes its execution. Example program: PROGRAM example_fclose; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET list1,4,myhandle); fclose(myhandle); // The file closes to be opened in other mode myhandle=fopen(\"help/help.dat\",\"r\"); fread(OFFSET list2,4,myhandle); fclose(myhandle); // The file closes definitively END - the functions of files Are used to write in one file the content of the list1 and then copy it over the list2 . After finishing the program, the data of the first will have been copied into the second. If the open file in one mode (with the function fopen() ) wants to access an file in a different mode, you must first close the file before opening it in the new mode; in the example, the file of writing is then closed to open it then in reading mode. The function flush() empties the buffers of writing and permits you also to check how many files are open at any moment. ---See also: fopen() fread() - fwrite() fread() fread( , , ) Returns: 0 - If an error was produced , or all asked data was not read . 1 - If all data was read. Description: This function permits you to read the data of an file opened with the function fopen() , starting from the position indicated by the {pointer of reading/writing}. The file must be opened in the reading mode , or a mode which it permits reading of data. The pointer is situated at the beginning of the file, after it has been opened, and advances sequentially during the reading of the data. But this pointer can be situated in any position, using the function fseek() and the function ftell() allows you to obtain the current position of the pointer of an file. The function fread() requires as a parameter the < OFFSET of the data> in which must the data of file be read , it means, the memory address from where must be placed the data which are reading from the file. As second parameter is required the or total size of the data which you want to read, it means, the number of positions of memory which occupy these data. The length of one data can be obtained with the function sizeof() . The last parameter must be the handle or identifier of file which was obtained after open the file as value of return of fopen() . Example program: PROGRAM example_fread; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET list1,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); fread(OFFSET list2,4,myhandle); // Read the file about fclose(myhandle); END - This example program has defined two global lists; list1 with four values initiated as 11, 22, 33 & 44, and list2 with four without initiate (all zero). The file functions are used to write in one file the content of the list1 and then copy it over the list2 . After finishing the program, the data of the first list will have been copied into the second. The function fopen() is called on two occasions, the first to {create it and write} in it and the second to open it and read its contents. It is important to underline that each time you open or create the file, you must close it with the function fclose() (in the example the file is closed on two occasions). The inverse function to fread() , which permits you to write data in an file instead of read it, is fwrite() . The way to use this function and its parameters are similar to those of fread() . Note: By default, the is specified as the number of simple data, remembering that a simple data (a variable) occupies {4 bytes}. So for example, if ten data (indicating 10 as length)are read, these date will occupy 40 bytes of memory. This relation can be changed by modifying the global variable drive_size , which has a default value of 4 in all programs. ---See: fopen() - fwrite() - fseek() - drive_size fwrite() fwrite( , , ) Returns: 0 - If an error was produced or the data was not successfully written. 1 - If all the data was written. Description: This function allows you to write data into an file opened with the function fopen() , starting from the position indicated by the cursor of reading/writing . The file must have been opened in a write mode . The cursor is placed at the beginning of the file, when opened or created, and advances sequentially as the data is written. But this cursor can be placed in any position of the file using the function fseek() and the function ftell() allows you to obtain the current position of an file cursor. The function fwrite() requires as its first parameter the < OFFSET of the data> which must be written in the file, so, the address of memory. As second parameter is required the or total size of the data which are wanted to be written, the number of memory positions which fill these data. The length of a data can be obtained with the function sizeof() . The last parameter must be the handle or identifier of file which was obtained when the file was opened as return value of fopen() . Example program: PROGRAM example_fwrite; GLOBAL mytable[3]=11,22,33,44; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); // Writes in the file fclose(myhandle); END - This example program writes the contained data in in the file help.dat of the disk. The function fopen() is called to create it and to the function fclose() to close it once every data has been written. The opposite function to fwrite() ,that allows to read data in an file instead of write to it, is fread() . The way to use this function and its parameters is the same as fwrite() . Note: By default, the is specified as the number of simple data assuming that a simple data (a variable) fills 4 bytes of memory. So, if for example, ten data are written (indicating 10 as length), then 40 bytes of data will be written. This relation can be changed by modifying the global variable drive_size , which, by default is 4 in every program. ---See: fopen() - fread() - fseek() - drive_size fseek() fseek( , , ) Description: Places the cursor of reading/writing of an file at the indicated position. The function requires, first, the or identifier of the file returned by the function fopen() when opened. Then the new position where the of the file must be placed is defined. Now every future reading or writing operation which is done, will be from this position. As a last parameter the in which the new position of the cursor must be specified is indicated, can be one of the following three modes: seek_set - Position is in relation to the beginning of the file (0). seek_cur - Increment related to the current position (1). seek_end - Position is in relation to the end of the file (2). To obtain the current situation of an file cursor, the function ftell() must be used. Every reading or writing operation of an file is done automatically, so all these access functions are called sequentially (reading or writing the data one after another). Example program: PROGRAM example_fseek; GLOBAL mytable[3]=11,22,33,44; mydata; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); // Places the cursor to read the fourth data of the file (44) fseek(myhandle,3,seek_set); fread(OFFSET mydata,1,myhandle); fclose(myhandle); END - This example writes the four data items contained in mytable (11,22,33 and 44) in the file help.dat , and then, opens the file for reading and uses the function fseek() to place the cursor in the position 3 from the beginning of the file (with seek_set ). Then you can read from the fourth data item of the file, so that, when a value is read in the variable mydata this will be 44 , the fourth value of the table. Note: By default, the is specified as a number of simple data items, assuming that a simple data (a variable) fills 4 bytes of memory. If, for example, the cursor is placed in the tenth position from the beginning of the file, then the program can access the data from the fortieth byte. This relation can be changed, by modifying the global variable drive_size , which by default is 4 for every program. ---See: ftell() - fread() - fwrite() - drive_size ftell() ftell( ) Returns: The current position of the cursor of reading/writing in an file. Description: Returns the position of the reading/writing cursor in an file, for which, the only parameter required is the or identifier of file returned by the function fopen() when the file was opened. To establish a new position for an file cursor, the function fseek() must be used. In contrast, the function, ftell() always returns the position of the cursor, related to the beginning of the file. Every reading or writing operation of an file automatically moves the cursor forward, so every access is done sequentially (reading or writing the data one after another). Example program: PROGRAM example_ftell; GLOBAL mytable[3]=11,22,33,44; midata1; midata2; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); midata1=ftell(myhandle); // Position of the cursor before writing fwrite(OFFSET mytable,4,myhandle); midata2=ftell(myhandle); // Position of the cursor after being written the data fclose(myhandle); END - This example writes the four data items contained in mytable (11,22,33 & 44) into the file help.dat . After opening the file with fopen() the position of the cursor is obtained and saved in the variable midata1 (this will be 0, the beginning of the file). Then, the four values contained in the table are written in the file and the position of the cursor is obtained again, which now is saved in midata2 (will be 4, at the end of the file, after the four written values). Finally, the file is closed with #224.fclose() before ends. Note: By default, the is specified as a number of simple data, assuming that a simple data (a variable) fills 4 bytes . So for example, if the cursor is placed in the tenth position from the beginning of the file, then the program can access the data from the fortieth byte. This relation can be changed, modifying the global variable drive_size , which by default is set at 4 for every program. Nota: The function filelength() allows you to find the length of an file, but to do this the file must already be open. ---See: fseek() - fread() - fwrite() - drive_size filelength() filelength( ) Returns: The length of the file Description: This function obtains the length of an file already opened with fopen() , to do this you need as a parameter the or identifier of file returned by the fopen() function. This function doesn't modify the current position of the reading/writing cursor of the file, but simply returns the number of data items contained therein. Example program: PROGRAM example_filelength; GLOBAL mytable[3]=11,22,33,44; longitude; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); longitude=filelength(myhandle); // Obtains the length of the file (4) fclose(myhandle); END - This example program creates first an file called help.dat , writing to it the four values contained in mytable . Once the file has been created, it will be reopened in read mode to obtain its length . Note: By default, the length of the file is obtained as the number of simple data items it contains, assuming that a simple data (a variable) fills up 4 bytes . If, for example, the length of an file is ten then it will occupy forty bytes of memory. This relation can be changed by modifying the global variable drive_size , which by default is 4 for every program. Note: The functions get_dirinfo() and get_fileinfo() allow you to obtain a lot of information about the structure of directories (folders) on the drive and about the files/files contained on it. ---See: fopen() - get_dirinfo() - drive_size flush() flush( ) Returns: The number of opened files/files. Description: Empties the memory buffers, and ensures that all data written to a file which is still in the cache memory is saved in its correspondent file. This operation is not very necessary, because the administration of the cache that the operating system makes, is very effective and the data is not going to be lost due to not being correctly written to its corresponding file/file. But, this function has another utility. It will return the {number of files opened with} fopen() inside of a program. The file system allows just a maximum number of files to be open at once, which depends on the system's configuration. Every file must be closed with fclose() once the program has finished operating on them. This last function allows you to close just one file, or everyone which is open. Example program: PROGRAM example_flush; GLOBAL midata1; midata2; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); midata1=flush(); // Obtains the number of opened files (1) fclose(myhandle); midata2=flush(); // Obtains the number of opened files (0) END - This example obtains on two occasions the number of files opened, with the function flush() . After the file help.dat has been opened, the function determines that there is one open file, and once closed, could be used to check that no files are still open. ---See: fopen() - fclose() get_dirinfo() get_dirinfo( , ) Returns: Number of files of the directory which coincides with the mask and the type selected. Description: This function allows you to obtain a list of the files in a directory (folder). The is required to select the type of files which must be listed. This is just a name of a partial file using jokers; for example, the mask \" . \" (must be indicated as a text between quotation marks) will select every file in the directory. You can also include in the mask, the path of the directory (if no path is defined the files of the current directory will be listed). For example, the mask \"C:\\WINDOWS\\SYS*.??E\" will select every file of the directory \"C:\\WINDOWS\" whose name starts with \"SYS\" and whose extension finishes with \"E\" . As a second parameter the must be indicated which are to be included in the list, this will be one of the following: ** _normal** - To list just the normal files. ** _hidden** - To include also all hidden files. ** _system** - To include also the system files. ** _subdir** - To include also the subdirectories. ** _volid** - To list just the label of the volume. The most common choice is to indicate _normal as the , this type covers most files, including read-only files, file files and read/write files (only some special files are excluded, which typically are internal system files). If _hidden , _system or _subdir is indicated in this parameter, these types of files will be included as well as the normal files (it's not necessary to specify _normal ). Also, you can select more than one of these types; for example, indicating _hidden+_system will list every normal file, as well as every hidden and system file. When {_volid) is indicated, just the name of the volume label of the disk will be listed, no file or subdirectory will be listed (you can't add other types to this). The function get_dirinfo() simply returns the total number of listed files; the names of these files are saved in the global structure dirinfo (the first name of the file is saved in dirinfo.name[0] , the second in dirinfo.name[1] , etc.). The total number of listed files which this function returns is saved in dirinfo.files . The list of file names is always saved in alphabetic order, but the function qsort() can be used to order the global structure dirinfo with any other criteria. This function just allows you to obtain the names of the files, to obtain further information about them (the attributes, the size, the data, etc.) the function get_fileinfo() must be used. Example program: PROGRAM example_get_dirinfo; GLOBAL counter; BEGIN write(0,0,0,0,\"List of files - Press ESC to finish\"); get_dirinfo(\"C:\\WINDOWS*.EXE\",_normal); // Obtains the list of files FOR (counter=0;counter<dirinfo.files;counter++) x=(counter%4) 80; y=16+(counter/4) 8; write(0,x,y,0,dirinfo.name[counter]); END REPEAT FRAME; UNTIL (key(_esc)); END - This example program lists every normal EXE file of the directory C:\\WINDOWS, and then shows them on screen. The loop FOR is the one that shows on screen the list of the files of the structure dirinfo in four columns, as otherwise the function get_dirinfo() doesn't show any information on screen, it just fills up the structure dirinfo with the names of the files found in the directory. To open or create a file the function fopen() can be used. To change the directory, you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to find out the free disk space on a drive. ---See: get_fileinfo() - fopen() - chdir() - mkdir() - disk_free() get_fileinfo() get_fileinfo( ) Returns: 0 - Can't obtain any information about the file. 1 - The information about the file was saved correctly. Description: Obtains information about a file or directory on the disk, for which, the function requires the as a parameter (between quotation marks). You can either just indicate the filename, or include the path to the file as well. If the function finds the file in the specified directory (or in the current one, in the case of no directory being specified), it will return back the value 1 and will save all information about the file in the global structure fileinfo , which contains the following fields: ** fullpath** - Complete name (including the path). ** drive** - Disk drive (1-A:, 2-B:, 3-C:, ...). ** dir** - Directory of the file. ** name** - Name of the file. ** ext** - Extension of the file. ** size** - Size (in simple data, see drive_size ). ** day** - Day (data of the last access). ** month** - Month (data of the last access). ** year** - Year (data of the last access). ** hour** - Hour (hour of the last access). ** min** - Minute (hour of the last access). ** sec** - Second (hour of the last access). ** attrib** - Attributes of the file. The path to the file can be completely specified (from the main directory of the drive, as \"C:\\WINDOWS...\") or relative to the current directory (from which the game is executed, like \"MAP\\MIOS...\"). Anyhow, the complete path from the main directory will always be stored in fileinfo.fullpath , including the drive letter of the disk. The function get_fileinfo() just obtains information about a file, to obtain the complete list of files in a directory, the function get_dirinfo() must be used. Example program: PROGRAM example_get_fileinfo; BEGIN // ... get_fileinfo(\"help/HELP.FPG\"); // ... END - This small example asks for information about the file help.fpg contained in the directory help . It can be extracted and traced (with F12 ) to see how, after the call to the function, the global structure predefined as fileinfo has been filled up with information concerning the file. To open or create a file the function fopen() can be used, and to delete a file from the drive the function remove() can be used. The function disk_free() allows you to ascertain the free disk space of any drive. ---See: get_dirinfo() - fopen() - remove() - disk_free() getdrive() getdrive( ) Returns: The number of the current drive. Description: This function allows you to determine which is the drive that is being currently used, this is returned as a number, where 1 corresponds to the drive A: , the number 2 to B: , 3 to C: , etc. There are no parameters required in the function call. The function setdrive() allows you to set the current drive; all access to the disk (reading and writing files) is always done on the selected drive which, by default, will be the drive on which the program is executed. Example program: PROGRAM example_getdrive; GLOBAL drive; BEGIN write(0,0,0,0,\"Current drive:\"); drive=getdrive(); write_int(0,0,20,0,OFFSET drive); LOOP FRAME; END END - This program shows on screen the number of the current drive obtained using the function getdrive() . To change the directory you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to ascertain the remaining free disk space on a drive. ---See: setdrive() - chdir() - mkdir() - disk_free() setdrive() setdrive( ) Description: This function allows you to set the current drive; all access to the disk (reading and writing files) is always done on the selected drive which, by default, will be the drive on which the program was executed. The must be indicated with a number, where the number 1 corresponds with the drive A: , the number 2 with B: , 3 the C: , etc. this function doesn't return any value. The function getdrive() allows you to obtain the number of the current drive. Example program: PROGRAM example_setdrive; GLOBAL drive; BEGIN // ... drive=getdrive(); setdrive(1); // Is placed in the drive A: // ... setdrive(drive); // Recovers the previous drive // ... END - This program first, obtains the current drive with the function getdrive() and saves it in the variable drive , then the drive is set to 1 (A:) before, finally, the drive is reset as the drive in which the program is being executed. Note: When a drive is changed with setdrive() no value is returned, but afterwards getdrive() can be called to check that the program has been placed on the correct drive. To change the directory you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to ascertain the remaining free disk space on a drive. ---See: getdrive() - chdir() - mkdir() - disk_free() chdir() chdir( ) Returns: 1 - The indicated directory was changed. 0 - This directory can't be read. Description: Changes the current directory, on the selected drive. The directory must be indicated as a literal (text between quotation marks), and can be a relative path (from the current directory) or an absolute path (from the main directory). The ways of use and possibilities of this function are the same as the command CD that can be typed in at the command line of the operating system. Each program is placed at the beginning of the directory where the main executable is found. New directories (or folders)can be created on a disk with the function mkdir() , and with the function remove() the other directories can be eliminated. Example program: PROGRAM example_chdir; BEGIN chdir(\"MAP\"); // Is placed in the directory MAP\\ // ... chdir(\"..\"); // Comes back to the previous directory END - This small example shows how the function chdir() can be used to change the current directory. The function setdrive() allows you to set the current drive and the function getdrive() allows you to ascertain it; all access to the disk (reading and writing of files) is always done on the selected drive which, by default, will be the drive on which the program is being executed. Note: The list of a directory's files can be obtained with the function get_dirinfo() . ---See: mkdir() - remove() - setdrive() - getdrive() mkdir() mkdir( ) Description: Creates a new directory (inside of the current directory or folder). You must indicate as a parameter the name of the directory to be created as a literal (text between quotation marks). The way of using and possibilities for this function are the same as the command MD which can be typed at the command line of the operating system. Each program is placed at the beginning of the directory where the main executable is found. You create a new directory with the function mkdir() , eliminate the other directories with the function remove() . . Example program: PROGRAM example_mkdir; BEGIN mkdir(\"temporal\"); // Creates a new directory // ... remove(\"temporal\"); END - This small program shows how the function mkdir() can be used to create a directory, and then it is deleted with the function remove() . The function setdrive() allows you to set the current drive and the function getdrive() allows you to ascertain it; all access to the disk (reading and writing of files) is always done on the selected drive which, by default, will be the drive on which the program is being executed. Note: The directory's list of files can be obtained with the function get_dirinfo() . ---See: chdir() - remove() - setdrive() - getdrive() remove() remove( ) Description: Deletes files or subdirectories contained inside of the current directory in which the program was executed. The must be indicated in a literal (text between quotation marks), also the joker/wild characters \"?\" and \" \" are accepted (as for example \" .bak\" to eliminate every file with the extension BAK). The files eliminated will always be inside of the current directory (see chdir() to change the directory) and on the current drive (see setdrive() to change the drive). With this function directories can also be eliminated, but only if they are empty (if there are no files or other subdirectories inside). Note: This function must be used with more caution, because the files deleted cannot be recovered, and information or programs contained on the disk can be lost . Example program: PROGRAM example_remove; BEGIN mkdir(\"temporal\"); // ... remove(\"temporal\"); // Deletes a directory END - This small example creates a directory with the function mkdir() and then eliminates it with the function remove() . Note: The directory's list of files can be obtained with the function get_dirinfo() . ---See: chdir() - setdrive() - get_dirinfo() disk_free() disk_free( ) Returns: The free disk space on the drive. Description: This function allows you to determine the free disk space of any drive. The number of the is required as the only parameter, the number 1 meaning the drive A: , 2 with B: , 3 with C: , etc. The remaining space on the drive is given in Kbs (in kilobytes, each one being a total of 1024 bytes). The current drive can be ascertained (the one where the program is being executed) thanks to the function getdrive() . Example program: PROGRAM example_disk_free; GLOBAL drive; free_space; BEGIN // ... drive=getdrive(); free_space=disk_free(drive); // ... END - This program uses first the function getdrive() to determine on which drive the program is being executed (where the variable drive )is stored on, and then determines the free disk space of that drive with disk_free() . To obtain information about the size of the files etc... you must be use the functions get_dirinfo() and get_fileinfo() . Note: The function memory_free() allows you to determine the free RAM memory, the quantity of memory that is available to run the program. ---See: getdrive() - memory_free() memory_free() memory_free( ) Returns: The free memory available for the program. Description: This function allows you to determine the computer's RAM memory that is available for the use of the program. No parameter is required, and the memory total is returned in Kbs (in kilobytes, each one being a total of 1024 bytes). This quantity of memory will be available for the program to load all its resources (graphics, sounds, etc.), it is useful to check with this function, at the start of a program, that the computer has enough memory to load all the necessary resources. Example program: PROGRAM example_memory_free; GLOBAL free_memory; BEGIN // ... free_memory=memory_free(); // ... END - This small example uses the function memory_free() to save the quantity of RAM available for the program in the global variable free_memory . Note: The function disk_free() allows you to determine the free disk space on a computer drive. ---See: disk_free() ignore_error() ignore_error( ) Description: This function allows you to ignore a specified execution error, the is required as a parameter; this is the present number in the information window of an error which appears on occasions when a program is being executed. At the beginning it is not recommended to ignore the execution errors, because the program may not work correctly, and you may need some information relative to the error to solve the problem. When a program produces an execution error, it is always for a reason; and to ignore the error will not solve the problem. Note: Not all the errors can be ignored, there are some errors which make it impossible for the program to run properly. These are the errors denoted as \"serious\", which will always cause the program to abort. Example program: PROGRAM example_ignore_error; BEGIN ignore_error(145); // To ignore the divisions by zero x=x/0; END - In this example the function ignore_error() is called to advise the system that, from now on, it should ignore all divisions by zero (these will produce an unquantifiable result). Now a division by zero is made, to check that the program doesn't emit an error message. This error number is 145 , the same as the number given with the call to the function ignore_error() of the previous example. List of codes of execution errors: 100 There is not enough memory to run the program. 101 Call to key() with a nonexistent key code. 102 The palette was not loaded, file not found. 103 An invalid palette file was loaded. 104 Too many FPG files are open at the same time. 105 The file was not loaded, file not found. 106 An invalid FPG file was loaded. 107 Number of scroll invalid (must be between 0 and 9). 108 Number of region invalid (out of range). 109 file Code invalid. 110 Code of graphic invalid. 111 An FPG file was used before it was loaded. 112 A graphic's code is needed for the scroll. 113 Too many fonts have been loaded. 114 The font was not loaded, file not found. 115 An invalid font file was loaded. 116 Identifier code of fonts invalid. 117 Code of text centre invalid. 118 There are too many blocks of text currently active in the program. 119 Identifier of text invalid. 120 Screen region is defined incorrectly. 121 Nonexistent graphic was used. 122 A block out of memory was written. 123 The file you are attempting to write to hasn't been opened. 124 Can't write to the file (check space on disk). 125 A block out of memory was read. 126 Can't open the file for reading. 127 Can't read the file. 128 Can't load the sound effect. 129 Can't play the wanted sound effect. 130 Can't start the wanted animation. 131 Number of mode 7 invalid (must be between 0 and 9). 132 A code of graphic for the mode 7 is needed. 133 Number of checkpoint invalid. 134 Number of button incorrect (must be between 0 and 3). 135 Number of axis incorrect (must be between 0 and 3). 136 Address of the palette table out of memory. 137 Can't check regions in mode 7 graphics. 138 Code of graphic information incorrect. 139 Can't check collisions in mode 7 graphics. 140 Access out of rank. 141 An invalid process was accessed.. 142 The process looks like a block, expecting FRAME. 143 Can't load the map, file not found. 144 An invalid map file was loaded. 145 A division by zero was made. 146 The size of the region is incorrect. 147 Can't load FLI/FLC animation, file not found. 148 Value of timeout incorrect (must be between 1 and 60). 149 Number of players incorrect (must be between 2 and 8). 150 Only global data can be sent . 151 Size of the square invalid (must be between 1 and 256). 152 searching Map invalid (from 1x1 to 128x128). 153 Size of the map incorrect (from 1x1 to 32768x32768). 154 Number of colour incorrect (must be from 0 to 255). 155 The centre is outside of the graphic's limits. 156 The object is outside of the map and will be eliminated. 157 Map texture not found. 158 Texture size incorrect. 159 Can't load the world, file not found. 160 Can't load the world, file not valid. 161 Flag number invalid. 162 Dispositive invalid (just 1-IPX,2-SERIAL,3-MODEM). 163 Packet size invalid (just from 1 to 199). 164 The string of text destination is invalid. 165 Null cursor was accessed. 166 The access mode to the file is invalid. 167 Can't load the module. 168 Too many ignored errors. 169 To many files opened.. 170 Identifier of file (handle) not valid. 171 Value out of rank. 172 Too many graphic objects visualised. 173 Type of graphic object is not known. 174 Percentage of link out of rank (0..15). 175 Number of graphic object invalid. 176 Error variable of type: Texture of map [a] not found in file [b]. 177 Map texture. 178 Not found in file. 179 Too many partitions of dynamic memory were made.. 180 The cursor doesn't correspond to any of the reserved blocks. 181 Can't reserve blocks of less than one position. 182 A block outside of the memory was (de)encrypted. 183 Can't load another palette when the current one is enforced. 200 file with corrupted data, can't be loaded. Note: With the compilation options (see Compiler_options ) the errors of execution can be ignored , but this practice is not recommended. ---See: Compiler_options save_map() / save_pcx() save_map( , , ) save_pcx( , , ) Returns: 1 - If the file was loaded successfully. 0 - While saving the file there was an error. Description: Creates a MAP or PCX file from a graphic loaded in memory. The function requires the and codes which identify the graphic, and the MAP or PCX which must be created on the disk containing that image. The name of the file must be specified as a literal (text between quotation marks, as \"image.pcx\"). Graphics loaded with the functions load_map() or load_pcx() (or created with new_map() ) will be used as if they were from the first file (the file with the code 0). The function save_map() always creates MAP files, and save_pcx() will always create PCX files, independent of the indicated extension in the . If there is no error, the function will create the file with the image and will return back the value 1 . These maps can be loaded in the graphical environment of DIV Games Studio or in the programs, using the functions load_map() o load_pcx() . Example program: PROGRAM example_save_map; BEGIN load_fpg(\"help/help.fpg\"); save_pcx(0,1,\"help/help.pcx\"); // Creates a PCX file END - This example uses the function save_pcx() to create a PCX file containing an image previously loaded inside of the file help.fpg with the function load_fpg() . A graphic can be created with the function new_map() , and to modify a graphic the following functions can be used: map_block_copy() - Transfers a block of a graphic to another. map_get_pixel() - Obtains the colour of a graphic pixel. map_put() - Puts a graphic into another. map_put_pixel() - Fixes the colour of one point in a graphic. map_xput() - Places a graphic into another, with added effects. Note: The function write_map() allows you to write text in a graphic created in memory (instead of writing it on screen). ---See: load_map/pcx() - unload_map/pcx() sin() sin( ) Returns: The sin of a given angle. Description: Calculates the sin in thousandths of the angle given as the parameter. The angles are always manipulated in thousandths of degree (see the use of angles in the language ), and the sin will be returned in thousandths of a unit as well (as a value from -1000 to 1000). For example, sin(90000) will return 1000 , because the sin of 90 degrees is 1. Example program: PROGRAM example_sin; GLOBAL angles[15]; sine[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Sins\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); sine[n] = sin(angles[n]); // The sin of the angle is calculated write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset sine[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and use the function sin() to calculate the sine of them. ---See: Expression - See: Use of the angles in the language cos() cos( ) Returns: The cosine of a given angle. Description: Calculates the cosine in thousandths of the angle given as the parameter. The angles are manipulated always in thousandths of a degree (see the use of angles in the language ), and the cosine will be returned in thousandths of a unit also (as a value from -1000 to 1000). For example, cos(0) will return 1000 , because the cosine of 0 degrees is 1. Example program: PROGRAM example_cos; GLOBAL angles[15]; cosine[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Cos\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); cosine[n] = cos(angles[n]); // The cosine of the angle is calculated write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset cosine[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and will use the function cos() to calculate the cosine of them. ---See: Expression - See: Use of the angles in the language tan() tan( ) Returns: The tan of a given angle. Description: Calculates the tangent in thousandths of the angle given as the parameter. The angles are manipulated always in thousandths of a degree (see the use of angles in the language ), and the tan will be returned in thousandths of also (as a value inside of the rank min_int ... max_int ). For example, tan(45000) will return 1000 , because the tan of 45 degrees is 1. Example program: PROGRAM example_tan; GLOBAL angles[15]; tangent[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Tans\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); tangent[n] = tan(angles[n]); // calculates the tan of the angle write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset tangent[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and will use the function tan() to calculate the tangent of them. ---See: Expression - See: Use of the angles in the language asin() asin( ) Returns: The arcsine of a given sine. Description: Calculates the arcsine of the sine given as the parameter in thousandths, the corresponding angle to a sine value is obtained (opposite operation to sine, which can be obtained with the function sin() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the asin will be returned in thousandths of a degree also (as a value inside of the rank min_int ... max_int ). The is required as a value from -1000 to 1000 (from -1.0 to +1.0), and the result is returned as an angle between -90000 and 90000 (from -90 to +90 degrees). Example program: PROGRAM example_asin; GLOBAL sine[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Sin\"); write(0,160,0,0,\"Asin (angle)\"); FROM n=0 TO 15; sine[n] = rand(-1000, 1000); angles[n] = asin(sine[n]); // calculates the arcsine of a sine write_int(0, 0, 20+n 10, 0, offset sine[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of sines, randomly chosen between -1000 and 1000 (represented in thousandths), and will use the function asin() to calculate the arcsine of these values. ---See: Expression - See: Use of the angles in the language acos() acos( ) Returns: The arccos of a given cos. Description: Calculates the arccos of the cosine given as the parameter in thousandths, the corresponding angle to a cosine is obtained (inverse operation to the cosine, which can be obtained using the function cos() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the acos also returns values in thousandths (as a value inside of the rank). The is required as a value from -1000 to 1000 (from -1.0 to +1.0), and the result is returned as an angle between ** -90000 and 90000** (from -90 to +90 degrees). Example program: PROGRAM example_acos; GLOBAL cosine[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Cos\"); write(0,160,0,0,\"Acos(angle)\"); FROM n=0 TO 15; cosine[n] = rand(-1000, 1000); angles[n] = acos(cosine[n]); // The acos of a cos is calculated write_int(0, 0, 20+n 10, 0, offset cosine[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the sins, randomly chosen between -1000 and 1000 (represented in thousandths), and will use the function acos() to calculate the asin of them. ---See: Expression - See: Use of the angles in the language atan() atan( ) Returns: The arctan of a given tangent. Description: Calculates the arctan of the tan given as a parameter in thousandths, the corresponding angle to a tan is obtained (inverse operation to the tan of an angle, which can be obtained with the function tan() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the arctan will be returned in thousandths of a degree also. The is required as a value inside of the rank min_int ... max_int (from -inf to +inf), and the result is returned as an angle between -90000 and 90000 (from -90 to +90 degrees). Note: There is another function to calculate the arctan called atan2() , this function takes as its parameters the values and and returns the arctan of y/x between -180000 and 180000 (of -180 to 180 degrees). Example program: PROGRAM example_atan; GLOBAL tangent[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Tan\"); write(0,160,0,0,\"Atan(angle)\"); FROM n=0 TO 15; tangent[n] = rand(-1000, 1000); angles[n] = atan(tangent[n]); // The arctan of a tan is calculated write_int(0, 0, 20+n 10, 0, offset tangent[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the tans, randomly chosen between -1000 and 1000 and use the function atan() to calculate the arctan of them (between -45 and 45 degrees). ---See: Expression - See: Use of the angles in the language atan2() atan2( , ) Returns: The arctan of / . Description: Calculates the arctan of the tan obtained as the division of the two values, given as the parameter ( / ), the angle corresponding to arctan (inverse operation to the tan of an angle, which can be obtained with the function tan() ) is obtained. The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the arctan is also returned in thousandths as a value between -180000 and 180000 (from -180 to +180 degrees). Note 1: Another function exists to calculate the arctan called simply atan() , this function takes as its only parameter the tan of an angle and returns its arctan between -90000 and 90000 (from -90 to 90 degrees). Note 2: There is also a version of atan2() , which is more simply adapted to the geometric concepts; it is the function denoted as fget_angle() which obtains directly the angle between two points. ---See: Expression - See: Use of angles in the language draw() draw( , , , , , , , , ) Returns: The identifier of the primitive graphic painted. Description: This is a generic function able to draw some primitive graphics on screen (such as lines, boxes and circles). The following parameters must be indicated: - Type of primitive graphic, as one of the following: 1 - Straight line. 2 - Rectangle. 3 - Filled rectangle. 4 - Ellipse. 5 - Filled ellipse. - colour of the ink with which the primitive will be drawn (from 0 to 255 , as a colour of the palette). - Level of opacity of the primitive, from 0 to 15 (to allow for transparency effects). - Number of region (window inside of the screen) where the primitive can be painted ; normally this value will be 0 to print the primitive in any position of the screen. To define a region on the function define_region() must be used. , - Starting point of the straight line, or the upper left corner of the box which contains the rectangle or ellipse. , - End point of the straight line, or the lower right corner of the box which contains the rectangle or ellipse. When a primitive graphic is painted with draw() this will remain fixed on screen until it is moved with the function move_draw() , or eliminated with the function delete_draw() . The identifier of the primitive returned by the function draw() will be necessary in order to move or delete the primitive. The representation system of these graphic primitives is quite similar to the system for texts; texts are painted with write() and will remain fixed until they are moved with move_text() or eliminated with delete_text() . Note: The level of impression or depth of the primitive graphics can be controlled with the predefined global variable draw_z . Example program: PROGRAM example_draw; GLOBAL counter; types; colour; opacity; x0,y0; x1,y1; BEGIN write(0,0,0,0,\"Press ESC to finish ...\"); REPEAT FROM counter=1 TO 10; types=rand(1,5); colour=rand(0,255); opacity=rand(0,15); x0=rand(0,319); y0=rand(0,199); x1=rand(0,319); y1=rand(0,199); // Paints a primitive graphic draw(types,colour,opacity,0,x0,y0,x1,y1); END FRAME; delete_draw(all_drawing); UNTIL (key(_esc)); END - This example program draws on screen 10 primitive graphics whose characteristics are selected randomly with the function rand() , and after creating an image with FRAME , it then deletes them with the function delete_draw() . The process is repeated until the ESC key is pressed. Note: a maximum of 256 primitive graphics can be represented on the screen at the same time. ---See: move_draw() - delete_draw() - draw_z delete_draw() delete_draw( ) Description: Deletes a primitive graphic which has been painted with the function draw() , for which the is required as a parameter, which is the numeric code which was returned when it was painted. If all_drawing is specified as a parameter the function will delete every primitive graphic represented on screen, the identifier is only necessary in the case of wanting to eliminate a particular primitive graphic. Example program: PROGRAM example_delete_draw; PRIVATE id_draw; types; colour; opacity; x0,y0; x1,y1; BEGIN write(0, 160, 8, 1, \"[ENTER] To show a primitive / [SPACE] to delete it\"); draw(2,127,15,0,0,0,319,199); LOOP types=rand(1,5); colour=rand(0,255); opacity=rand(0,15); x0=rand(0,319); y0=rand(0,199); x1=rand(0,319); y1=rand(0,199); id_draw=draw(types,colour,opacity,0,x0,y0,x1,y1); WHILE (NOT key(_space)) FRAME; END delete_draw(id_draw); // We delete the graphic WHILE (NOT key(_enter)) FRAME; END END END - In the previous example, a primitive is painted on screen, then the program waits for the space bar to be pressed, at which moment the primitive is deleted and then when the ENTER key is pressed the program repeats the loop. This is the second primitive, which identifier has been saved in the variable id_draw (the first primitive is the rectangle which has the same size as the screen and is painted with the first call to the function draw() of the program). To delete every primitive graphic call the function delete_draw(all_drawing); , the parameter all_drawing will also eliminate the rectangle. Note: The characteristics of a graphic primitive presented on screen (position, colour, opacity and size) can be modified with the function move_draw() . ---See: draw() - move_draw() move_draw() move_draw( , , , , , , ) Description: Modifies a primitive graphic which has been painted with the function draw() , to do this, the following parameters are required: - Is the numeric code which was returned by the function draw() when the primitive graphic was painted and which is now wanted to be modified. - colour of ink for the primitive (from 0 to 255 , as a colour of the palette). - Level of opacity of the primitive, from 0 to 15 (to allow for transparency effects). , - Initial point of the straight line, or the upper left corner of the box which contains the rectangle or ellipse. , - Final point of the straight line, or the lower right corner of the box which contains the rectangle or ellipse and the screen coordinates ( x , y ) where it must be moved to. Example program: PROGRAM example_move_draw; PRIVATE id_draw; colour; opacity; BEGIN write(0, 0, 0, 0, \"Move the mouse ...\"); id_draw=draw(4, 127, 15, 0, 0, 0, 32, 32); LOOP colour=rand(0,255); opacity=rand(0,15); // The graphic primitive is moved to the mouse coordinates move_draw(id_draw, colour, opacity, mouse.x-16, mouse.y-16, mouse.x+16, mouse.y+16); FRAME; END END - In the example a circular primitive graphic is painted with the function draw() , and its identifier of graphic primitive is saved in the global variable id_draw . Then, inside of a loop, the function move_draw() will be used to place the circle at or near the mouse coordinates, and assign a randomly chosen colour and opacity to each image. Note: To eliminate (delete) a primitive graphic the function delete_draw() is used, and with the predefined global variable draw_z the priority of impression of them can be handled . ---See: draw() - delete_draw() - draw_z write_in_map() write_in_map( , , ) Returns: The created code of the graphic containing the text. Description: Creates a new map in memory (without loading it on disk, very similar to the function new_map() ), and writes in the map some text which characteristics are described with the following parameters: - The code of the font or type of letter which is going to be used. Here a 0 must be placed when you want to use the system font (font of white colour, small, of 6 to 8 points), or the code of font returned by the function load_fnt() when a new font is loaded in the program. - specify the text to be written as a literal, as text between quotation marks (see the delimitation symbols of literals ). - This code value determines where the centre of the text will be placed on the checkpoint of the created map. its possible values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right The text will always be fitted in a new map of the same dimensions, but this checkpoint will specify which point of the map will centred on the coordinates where it will then be placed. This function works practically the same as load_map() , but instead of reading a file on the disk which contains the graphic it creates a graphic which contains a written message. The code of the graphic is given as the return value, which is a numeric value which must be specified in order to use the graphic in the variable graph or, in any function which requires a code of graphic as its parameters. When the code of file which belongs to the graphic is wanted inside of a function the code 0 must be indicated (which is the code of the first file FPG which is loaded in the program). Example program: PROGRAM example_write_in_map; GLOBAL mi_font; BEGIN mi_font=load_fnt(\"help/help.fnt\"); // A new map is created with the text \"MOUSE\" // with the checkpoint in the centre, and is // assigned as the graphic of the mouse cursor. mouse.graph = write_in_map(mi_font,\"MOUSE\",4); REPEAT FRAME; UNTIL (key(_esc)); unload_map(mouse.graph); END - In the example a font is loaded with the function load_fnt() , and then a map is created with the function write_in_map() , saving the code of the graphic which is returned in the variable mouse.graph , so it will appear as the mouse cursor. The new map is created with the message \"MOUSE\" written with the font help.fnt , and its main checkpoint is placed in the centre (with the code 4 ). Pressing the ESC key will bring you out of the loop and the program will delete the graphic with the function unload_map() (exactly the same as if it were a file loaded from the drive). But, it is not necessary to delete the graphic from memory before finishing the program, because the system will do it automatically. The main advantage of the function write_in_map() is to be able to work with texts as if they were graphics, so they can be rotated, scaled, printed with transparency effects, etc... Note: write_in_map() can show a numeric value if used with the function itoa() , which allows you to convert a numeric value into a string of text. ---See: write() - unload_map/pcx() - graph - itoa() calculate() calculate( ) Returns: The result of the numeric expression. Description: Allows you to convert a literal (or text between quotation marks), which contains a number or numeric expression, to a constant value which can be assigned to any data. Allows you to convert some text into a number; for example, the statement x=calculate(\"234\"); will assign the value 234 to the variable x (exactly the same as with the statement x=234; ). The function itoa() allows the opposite operation, to convert a number into text. But also, the function calculate() can evaluate an expression, contained in the text with some operators, that can be the following (all the symbols accepted by each operator are indicated): ** + -** Addition and substraction. ** * /** Multiplication and division. ** % MOD** Modulus, or rest of an entire division. ** < <<** Binary rotation to the left. ** > >>** Rotation to the right. ** ^ ^^ XOR** OR binary exclusive. ** | || OR** OR binary. ** & && AND** AND binary. ** ! NOT** Binary negation. ** SQRT** Square root. Parentheses ( ) can also be used the to indicate priorities inside of the calculation of the expression. For example, calculate( \"(2+3) 4\" ) would return the value 20 * as a result. Note: The operation of this function is very similar to the window of the calculator ( System\\Calculator ) of the windows environment. Example program: PROGRAM example_calculate; GLOBAL STRING calculation; result; BEGIN write(0,0,0,0,\"Introduce an expression:\"); write(0,0,10,0,calculation); write(0,0,30,0,\"Result:\"); write_int(0,0,40,0,OFFSET result); LOOP SWITCH(ascii) CASE 8: calculation--; END CASE 27: calculation=\"\"; END CASE 0..31: END DEFAULT: calculation+=ascii; END END result = calculate(calculation); // Evaluates the calculation IF (timer MOD 100>50) calculation+=\"_\"; ELSE calculation+=\" \"; END FRAME; calculation--; END END - This example program allows you to introduce an expression to a string of text (See STRING ) and then evaluates it with the function calculate() to show the result of the same string. Note: if an error is produced in the evaluation of the expression (for example, if there exists any parenthesis which are not closed again), the function will return 0 as its result. ---See: itoa() - write() - STRING itoa() itoa( ) Returns: A string of text containing the result. Description: This function is used to convert a numeric value or into a string of text, that allows you to convert a number into text. The string will have as many types as digits has the result. The function calculate() allows the opposite operation; to convert a literal or string of text into a numeric value. Example program: PROGRAM example_itoa; GLOBAL STRING message; BEGIN load_fpg(\"help/help.fpg\"); mouse.graph=200; write(0,0,0,0,message); REPEAT // It makes a message with text and numbers using itoa() message = \"Cursor of the mouse in (\" + itoa(mouse.x) + \",\" + itoa(mouse.y) + \").\"; FRAME; UNTIL (key(_esc)); END - This example program creates a string of text called message (see STRING ) letters and numeric values (the coordinates of the mouse, see mouse ), and it is represented on screen with the function write() . The program loads the file help.fpg with load_fpg() and assigns the graphic 200 as the cursor of the mouse. The program will continue until the ESC key is pressed. Note: The name of the function itoa() , that comes from the C language, comes from the expression \"integer to ascii\". And the function that does the opposite operation, \"ascii to integer\" is called calculate() . ---See: Calculate() - Arithmetic expressions - Write() change_channel() change_channel( , , ) Description: This is a complementary function to change_sound() , which modifies the properties of one of the sound channels which plays back the digital sound effects (See sound() ) or music modules (See song() ). The number which is wanted to be adjusted must be indicated, (normally the channel number returned by the function sound() ), and the two following values: - Is given as the volume of the channel, between 0 and 512 , independent of the volume of the sound and the general volume level. When the volumes of the different channels are too loud the sound will be distorted, so it is recommended to modify the volume of the sound effects through the function change_sound() which, also allows you to adjust the frequency of the sound. - Is the \"panning\" or difference of volume between the left speaker and the right one, it must be a value between 0 and 255 . Note: The general levels of volume can be adjusted with the global structure setup (digital sound, cd-audio and general volume). Example program: PROGRAM example_change_channel; PRIVATE balance=128; // volume level (0..256) id_sound; channel_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); id_sound = load_pcm(\"help/help.pcm\", 1); channel_id = sound(id_sound, 256, 256); write(0, 160, 0, 1, \"Press right or left to change the balance.\"); write_int(0, 160, 10, 1, offset balance); LOOP // Changes the balance of the channel change_channel(channel_id, 50, balance); IF (key(_right) AND balance<255) balance++; END IF (key(_left) AND balance>0) balance--; END FRAME; END END - In the example a sound (contained in the file help.pcm )is loaded and played. Inside of the program's main loop the channel balance through which the sound with the function change_channel() is being played , can be changed using the cursor keys. Note: See also the global predefined table in the predefined global table channel , that indicates which of the sound channels are being used. ---See: change_sound() - sound() - song() STRUCT setup malloc() malloc( ) Returns: The OFFSET of the memory block asked, or 0 if the memory available is not enough. Description: This function assigns dynamic memory, or a new block of free memory if required, to the program. the of the memory block to be occupied is required as a parameter. This length is specified as a number of simple data blocks, each one of them taking up 4 bytes of memory; for example, if a block of length 100 is required then 400 bytes of memory will be put aside. A max number of 256 blocks can be requested inside of a program, irrespective of its size, the function free() allows you to liberate these memory blocks. Normally the OFFSET (memory address) returned by the function malloc() is assigned to a data of type pointer (See POINTER ). Example program: PROGRAM example_malloc; GLOBAL POINTER mytable[1000]; // pointer of a table of 1000 data counter; BEGIN mytable = malloc(1000); // Asks for 1000 memory positions FOR (counter=0;counter<1000;counter++) // Accesses the data mytable[counter]=-1; END free(mytable); // Liberates the memory occupied by the table END - This small example shows how a pointer to the table can be defined (the pointer contains none of the data of the table, just a handle to the table itself), and to assign memory to this pointer with the function malloc() . Once the memory is assigned to the table of data, the program accesses them (they are initiated to -1, as an example), and finally frees up the memory. The memory blocks which are not liberated with the function free() , will be liberated automatically by the system when the program has finished. Note: the quantity of available memory for the processing of program data (local and private data) can be controlled with the compilation options (See Compiler_options ). ---See: free() - POINTER free() free( ) Description: Liberates a block of dynamic memory which has been reserved previously with the the function malloc() the OFFSET or memory address in which the block starts is required as a parameter, which is the value obtained when it is reserved. The memory blocks not liberated with the function free() , will be liberated automatically by the system when the program ends. Example program: PROGRAM example_free; GLOBAL POINTER mytable[1000]; // Pointer of a table of 1000 data counter; BEGIN mytable = malloc(1000); // Asks for 1000 positions of memory FOR (counter=0;counter<1000;counter++) // Accesses to the data mytable[counter]=-1; END free(mytable); // Liberates the memory filled up by the table END - This small example shows how a pointer to a table can be defined (the pointer contains none of the data of the table, just a handle to the table itself), memory assigned to this with the function malloc() . Once the memory is assigned to the table of data, the program accesses them (they are initiated to -1, as an example), and finally frees up the memory. ---See: free() - POINTER encode() encode( , , ) Description: encrypt or un-encrypts a block of data in memory with a determined clue. The necessary parameters are the following: - Memory address in which starts the block which must be compressed, to obtain this address the operator OFFSET must be used. - Length of the data to be compressed, the number of positions of memory, filled up for the same, the length of any data can be obtained with SIZEOF() . - A literal (text between quotation marks) with the clue of encryption or decryption of the data. The algorithm is reversible so, to decrypt the data, simply you must to encrypt them with the same clue. The algorithm of encryption is very complex, so, any encrypted data with a clue just can be recovered applying to it the same clue again. Example program: PROGRAM example_encode; CONST password=\"mypass\"; GLOBAL table_original[14] =0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; table_encrypted[14]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; counter; BEGIN write(0,0, 0,0,\"Original values\"); write(0,160,0,0,\"encrypted values\"); write(0,0,190,0,\"[SPACE] to encrypt/decrypt the values\"); // encrypts the values of the second table encode(OFFSET table_encrypted,sizeof(table_encrypted),password); FOR (counter=0;counter<15;counter++) write_int(0,0, 20+counter 8,0,OFFSET table_original[counter]); write_int(0,160,20+counter 8,0,OFFSET table_encrypted[counter]); END LOOP IF (scan_code==_space) // encrypts and decodes of values of the second table encode(OFFSET table_encrypted,sizeof(table_encrypted),password); END FRAME; END END - This program has defined two tables of global data both with the same values and allows, pressing the space bar , to encrypt and decrypt one of the two tables (the denominated table_encrypted[] ). It can be seen how, when the data are encrypted a second time they are recovered in its original state. If a different clue is used, the result will be completely different. Note: There are other two functions which allow to encrypt and decrypt any kind of file, in this case must be used a function to each operation: encode_file() to encrypt and decode_file() to decrypt. ---See: encode_file() - decode_file() encode_file() encode_file( , ) Description: encrypts one or more files of the disk with a pre-determined clue. The necessary parameters are the following: - Description of a file which must be encrypted, a literal (text between quotation marks) with the name of the file. You can use the joker characters \"?\" and \" \" in the specifying of these files (for example, \" .BAK\" to encrypt every file with extension BAK). - A literal containing the clue of encryption of the file or files. The encryption algorithm is quite complex, but any encrypted file with a clue can be recovered simply by applying the same clue to it with the function decode_file() . If this function is not called, the resulted file will be completely useless, being impossible to recover the data contained in it. Files which are already encrypted cannot be encrypted a second time. Example program: PROGRAM example_encode_file; CONST password=\"mypass\"; GLOBAL mytable[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; BEGIN save(\"help/help.enc\",OFFSET mytable,sizeof(mytable)); encode_file(\"help/help.enc\",password); // encrypts the file END - This small program uses the function save() to create a file called help.enc with the data contained in mytable , and then the program encrypts it with the function encode_file() . You can see how the contents of the created file (inside of the directory help/ ) doesn't bear any relation to the original data (independent of what the encryption clue is). There is another function called encode() which allows you to encrypt and decrypt data in memory, in this case the operation is reversible, so the same function is used for both operations. Note: The functions compress_file() and uncompress_file() allow you to compress and uncompress files of the disk. The encrypted files cannot be compressed with the functions (as their contents are randomly organised). ---See: encode() - decode_file() - compress_file() - uncompress_file() decode_file() decode_file( , ) Description: Decodes one or more files on the disk, that share the same clue as the one they were encrypted with using the function encode_file() . The necessary parameters are the following: - Description of a file which must be unencrypted, a literal (text between quotation marks) with the name of the file. You can use the joker characters \"?\" and \" \" in the specifying of these files (for example, \" .BAK\" to decrypt every file with extension BAK). - A literal specifying the clue of encryption for the file or files. This clue must be exactly the same as the clue that the files were originally encrypted with, if {they are unencrypted with a different clue, the files will remain indecipherable}. The files unencrypted cannot be unencrypted again. Example program: PROGRAM example_decode_file; CONST pass=\"mypass\"; GLOBAL mytable[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; BEGIN save(\"help/help.enc\",OFFSET mytable,sizeof(mytable)); encode_file(\"help/help.enc\",pass); // ... decode_file(\"help/help.enc\",pass); // decodes the file END - This small program uses the function save() to create a file called help.enc with the data contained in mytable , and is encrypted with the function encode_file() . Before the program finishes the contents of the file are recovered again using the function decode_file() which decodes the data. The file will be returned to its original form. The function encode() allows you to encrypt and decode data in memory, but in this case, the operation is reversible, so the same function is used for both operations. Note: the functions compress_file() and uncompress_file() allow you to compress and uncompress files on the disk. The files encrypted cannot be compressed with these functions (due to its content being completely randomly organised). ---See: encode_file() - encode() - compress_file() - uncompress_file() compress_file() compress_file( ) Description: Compresses one or more files of the disk, the only parameter required is the which must be compressed, as a literal (text between quotation marks). The joker characters \"?\" & \" \" can be used to specify some files (for example, \" .BAK\" to compress every file with the extension BAK). To uncompress these files the function uncompress_file() must be used. The format of file encryption is a format specific to DIV Games Studio, so it can't be uncompressed with any other external utility program. The file will be saved compressed with the same name and extension as the original. Files already compressed cannot be compressed a second time. Example program: PROGRAM example_compress_file; GLOBAL counter; mytable[999]; BEGIN FOR (counter=0;counter<1000;counter++) mytable[counter]=counter; END save(\"help/help.cmp\",OFFSET mytable,sizeof(mytable)); compress_file(\"help/help.cmp\"); // Compress the file. END - This small program uses the function save() to create a file called help.cmp with the data contained in mytable , this being a group of consecutive numbers from 0 to 1000. Once created, the file is compressed with the function compress_file() . In this case, the original size of the file is 4000 bytes (1000 blocks of data), and the size of the compressed file is 1441 bytes (36% of the original size). Note: the functions encode_file() and decode_file() allow you to encrypt and decode files on the disk. The files encrypted with these functions can't be compressed due to their being content completely randomly organised. But, {the files compressed can be encrypted}. ---See: uncompress_file() - encode_file() - decode_file() uncompress_file() uncompress_file( ) Description: Uncompresses one or more files on the disk, previously compressed with the function compress_file() , the only parameter required is the which must be uncompressed, as a literal (text between quotation marks). The joker characters \"?\" & \" \" can be used to specify some files (for example, \" .BAK\" to uncompress every file with extension BAK). The format of file encryption is a format specific to DIV Games Studio, so it can't be uncompressed with any other external utility program. The file will be uncompressed with the same name and extension as the one compressed. Files not compressed with the function compress_file() can't be uncompressed using this function. Example program: PROGRAM example_uncompress_file; GLOBAL counter; mytable[999]; BEGIN FOR (counter=0;counter<1000;counter++) mytable[counter]=counter; END save(\"help/help.cmp\",OFFSET mytable,sizeof(mytable)); compress_file(\"help/help.cmp\"); // Compress an file // ... uncompress_file(\"help/help.cmp\"); // Uncompress the file load(\"help/help.cmp\",OFFSET mytable); END - This small example uses the function save() to create a file called help.cmp using the data contained in mytable , this being a group of consecutive numbers from 0 to 1000, then the file is compressed with the function compress_file() . Once the compressed file has been created, it is then uncompressed with the function uncompress_file() and is again loaded over the original table using the function load() . Note: the functions encode_file() and decode_file() allow you to encrypt and decode files of the disk. The encrypted files, generated with these functions cannot be compressed due to their contents being completely randomly organised. But, the compressed files can be encrypted . ---See: compress_file() - encode_file() - decode_file() find_color() find_color( , , ) Returns: The colour number in the palette. Description: Finds the colour from the current palette nearest to the indicated colour. the desired colour must be specified in the palette using the three component RGB system of colour coding, that is (red), (green) and (blue), all of them being expressed as values between 0 and 63. the number of colour of the palette which is the nearest to the indicated component colours, will be given as the return value of the function. For example, if the program calls a function like find_color(63,63,0) , it will return the colour number of the palette which is the nearest to or identical to this colour, namely yellow . Note: the function find_color() doesn't modify the current palette , it just searches for the defined colours in the palette, to modify a colour of the palette the function set_color() must be used. Example program: PROGRAM example_find_colour; GLOBAL; blue; green; yellow; red; BEGIN blue=find_color(0,0,63); // Search for the colour blue green=find_color(0,63,0); // Search for the colour green yellow=find_color(63,63,0); // Search for the colour yellow red=find_color(63,0,0); // Search for the colour red draw(2,blue,15,0,0,0,79,79); draw(2,green,15,0,80,0,159,79); draw(2,yellow,15,0,160,0,239,79); draw(2,red,15,0,240,0,319,79); LOOP FRAME; END END - This example uses the function find_color() to define the colours blue , green , yellow and red inside of the palette, and then using the function draw() , shows four squares of these colours. The advantage of using this system is that it doesn't matter if the program changes the current palette, because the same colours can always be found. To modify the whole palette, the file must be loaded with the function load_pal() . To create other palette effects, the function roll_palette() can be used, which allows you to create cycles of colour, or the function fade() which allows you to create multiple fades and saturations of colour at different speeds. ---See: set_color() - roll_palette() - load_pal() load_screen() load_screen( ) Description: Loads an image file MAP or PCX into the background of the screen. If the graphic is a different size (in pixels) to the screen size the graphic will be printed centred on the screen. To delete the screen background the function clear_screen() must be used. It is a function that combines three actions into one: 1 - To load a file which contains a map with the background image (using the function load_map() or load_pcx() ). 2 - To establish the image as the background (using put_screen() ). 3 - To delete the previous image file from memory (with unload_map() or unload_pcx() ) Example program: PROGRAM example_load_screen; BEGIN load_screen(\"help/help.map\"); LOOP FRAME; END END - In the example the background image contained in the file help.map is loaded with the function load_screen() . Note: If you want to print a graphic on a solid part of the screen or region which is not centred , then use the function put() in conjunction with it. The function xput() allows, you to print graphics rotated, scaled, mirrored and/or transparent on any region of the screen. ---See: load_map/pcx() - put_screen() - unload_map/pcx() force_pal() force_pal( ) Description: Loads a colour palette (a file of type PAL, FPG, MAP, PCX or FNT) and establishes it as the obligatory palette for all the graphics and fonts which are loaded thereafter. The functioning is very similar to load_pal() (which simply loads and activates a palette) but, once the palette has been loaded with force_pal() , every map, file and font loaded afterwards {will adapt automatically to the current palette}. The graphics already loaded before force_pal() was called {won't be adapted}, and as such, if all the graphics are wanted to be seen with a unique palette, this function must be called at the beginning of the program. It is important to note that the maps, files & fonts will just adapt in the computer's memory, the original files remain unaltered, each one with their own palette. Note: To stop adapting the loaded graphics to the unique palette, the function force_pal(0) must be called (indicating a 0 as its parameter, instead of the name of a file. Example program: PROGRAM example_force_pal; BEGIN force_pal(\"help/help.pal\"); // Now all the files, maps and fonts can be loaded // which are wanted, irrespective of their own palette, to be adapted // automatically to the current palette. // ... END - This small example shows how all the graphics can be forced to just one palette inside of a program by calling force_pal() at the beginning of program execution. A palette can't be deleted from the computer's memory, because this doesn't take up any space in memory. ---See: load_pal() Insufficient memory. There is not enough memory to compile the program. ltobj.def was not found The file has not been found in the DIV directory; this file is indispensable to compile the programs. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application. Invalid ltlex.def file. The changes made in the file are invalid . Recover the original file if you have a copy. Otherwise, you will have to reinstall the application. Invalid ltlex.def file. Too many symbols have been defined in the file. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application. Invalid ltlex.def file. An invalid symbol has been defined in the file. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application. ltobj.def was not found The file has not been found in the DIV directory; this file is indispensable to compile the programs. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application. Invalid ltobj.def file. The changes made in the file are invalid . Therefore, you must recover the original file if you have a copy. Otherwise, you will have to reinstall the application. Unknown character. A character that does not belong to any symbol of the language and that, moreover, is not valid to create a new name was found in the program. If it is a comment it is necessary to indicate it correctly with a symbol // at the beginning of the comments of a line, or the symbols / and / to indicate the beginning and the end, respectively, of comments occupying more than one line. If you intend to create a name you must replace that character by another one among the characters allowed by the language. ---See: Syntax - Comments Unclosed literal. Literals are texts in inverted commas . In the indicated position of the program, a literal starts but it is not closed. All the literals must be closed in the same line as they started. It is not possible to define literals occupying more than one line. The literals may start and finish with the character [ ' ] (but they have to start and finish with the same character). There are two ways to include the character [ \" ] in a literal, supposing that the aim is to define a literal containing the text: a\"B\"c Duplicating the character: \"a\"\"B\"\"c\" Defining it with the simple inverted comma: 'a\"B\"c' It happens the same regarding the character [ ' ]. ---See: Syntax Unknown symbol. In the indicated position of the program there is a symbol that does not belong to the language. Check the symbols available in the language to construct the expression correctly. It is probably a typographic mistake; check the syntax. ---See: Syntax expecting for [PROGRAM] All the programs must start with the reserved word PROGRAM followed by the program name. Before this word, only can appear comments (explanatory texts preceded by the symbol // or between the symbols / and /) or the compilation options . Check if the word has been correctly written, as no difference is made between uppercase and lowercase letters. Therefore, PROGRAM , program , Program , ... are valid words. Example: // ------------------- // Listing of my game // ------------------- PROGRAM my_game; BEGIN LOOP FRAME; END END - ---See: Syntax - Comments - Program's head expecting for the program's name. expecting for the program's name to come after the reserved word PROGRAM . Example: PROGRAM program_name; BEGIN //... END - The name of this program is program_name . ---See: Syntax - Names - Program's head The name is not new. As a name of the structure, it has been used a name that had already been given to another object previously defined. It can be a name, a constant, a variable, a table, a structure, a process or a function of the program. It is also possible that you have intended to use the same name inside the program to identify two different objects, or that a predefined name has been used for another use inside the language . In that case, it is possible to access the glossary to see which is the object that this name is referred to. Anyhow, that name must be replaced by another similar one . Example: PROGRAM program_name; GLOBAL position=0; STRUCT position[9] // Error: The name is not new. x, y; END BEGIN //... END - ---See: Syntax - Names - Glossary expecting for [=] To define a table, its length is normally indicated in square brackets. If the number of elements of the table is not specified in square brackets, it is necessary to wait for it to be initialised so that the compiler can determine its length. A table without a defined length has been found. Thus, after the square brackets ( [] ) have been closed, the compiler was expecting for the symbol = to precede the initialisation of the table. Indicate the length of the table in square brackets, or assign values to the different positions of the table. When a table is not initialised, all its positions will be initialised at zero. Example: PROGRAM program's_name; GLOBAL table1[3]; table2[]=2, 4, 6, 8; table3[]; // Error: expecting for [=]. BEGIN //... END - In the example, two tables of four positions (0..3), table1 initialised at (0, 0, 0, 0) and table2 initialised at (2, 4, 6, 8) have been defined. ---See: Syntax - Declaration of table expecting for [)] The compiler was expecting for a bracket previously open with the symbol ) ) to be closed at the indicated position. This error normally appears for one of the two following reasons: In an expression, several brackets have been opened and then some of them have not been closed. In this case, the opened brackets must be closed. Inside an expression in brackets, any operator has been omitted, then appearing two operands in a row, for instance, (2*3 4) . In this case, it is necessary to indicate the lacking operator. ---See: Syntax expecting for []] The compiler was expecting for a square bracket previously opened, with the symbol []](#]) to be closed in the indicated position. This error normally appears for one of the following reasons: The opening of a square bracket ( [ ) has been indicated in a table or structure and, after having indicated its length or index, it has not been closed. In this case, the symbol ] must be added in the indicated position. On indicating the index of a table or structure, any operator has been omitted, then appearing, two operands in a row, for instance table[2*3 4] . It is necessary now to indicate the lacking operator. ---See: Syntax An operand was waited for. The indicated position in the program is inside the context of an expression and, at this point of the expression, an operand (a value on which it is possible to do some calculations) was waited for. Instead of it, another different element on which it is not possible to do any calculation is given. There are several causes that can provoke this error, among which the most frequent are the following ones: A reserved word of the language has been used as if it was a variable, for instance x=global*2; . In this case, it is possible to check whether it is a reserved word by accessing the glossary. An operand has been omitted inside an expression, for instance x=2+ /y; . A square bracket or a bracket that had not been previously opened has been closed inside an expression, for instance x=); . Anyhow, you must check the syntax of the indicated expression to correctly construct it. ---See: Syntax - Declaration of data Unknown name. A constant, a variable, a table or a structure is used in the indicated position of the program with the aim of accessing it before having declared it. The compiler can not resolve the problem because it does not know the kind of involved object. All the constants must be defined at the beginning of the program, inside the CONST section. The variables, tables and structures may be defined inside the GLOBAL , LOCAL or PRIVATE sections, depending on their scope, but they have always to be defined before being used. This error frequently appears in the following cases: A name has been incorrectly written, for instance; Example: PROGRAM my_game; CONST centre=160; BEGIN x=centre; // Error: Unknown name. //... END - An object is used before and then declared, for instance: Example: PROGRAM my_game; CONST double=simple 2; // Error: Unknown name. simple=1; BEGIN //... END - * In this case, the two previous declarations should be exchanged. On initialising a table or structure, a comma has been accidentally put after the list of values. Example: PROGRAM my_game; GLOBAL table[]=0, 1, 2, 3, a=0; // Error: Unknown name. BEGIN //... END - In this case, the compiler will report this error in the a variable, as it interprets that it is the following value in the list of the table's initialisation, and it is a name that has not been defined yet. ---See: Syntax - Constants declaration expecting for [BEGIN] This error appears when an invalid declaration is made inside the CONST , GLOBAL , LOCAL or PRIVATE sections. After the initial statement PROGRAM program's_name; wait for any of the sections previously mentioned to appear (always in the same order), finally appearing the word BEGIN . After the beginning of a process ( PROCESS process_name( ) or function ( FUNCTION name_of_function( ... )**) wait for the PRIVATE section or the BEGIN word to be shown. The error can appear under the following circumstances: The name of any section has been incorrectly written. Several sections have been put in an incorrect order: Example: PROGRAM my_game; LOCAL a=0; GLOBAL // Error: expecting for [BEGIN] b=0; BEGIN //... END - Keep in mind that the sections must appear in the following order: CONST GLOBAL LOCAL PRIVATE Inside any of the sections previously mentioned, an element that is not a valid declaration inside that section appear. Example: PROGRAM my_game; GLOBAL +variable=0; // Error: expecting for [BEGIN] BEGIN //... END - In this example, on reaching the symbol + the compiler determines that the GLOBAL section has already finished. Therefore, as the following element is not the beginning of the LOCAL or PRIVATE sections, the compiler is expecting for the BEGIN reserved word to appear, indicating the beginning of the program code. At the beginning of the program or on defining a process, the word BEGIN has been omitted. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process() FRAME; // Error: expecting for [BEGIN] END - ---See: Syntax - BEGIN A constant expression was waited for. To initialise constants , variables, tables and structures it is necessary to use numeric values or expressions whose value may be determined when the program is compiled. An expression starts in the indicated position. The value of this expression has not been resolved in compilation time, probably because it uses global, local or private data, or because a function is called. In constant expressions, it is only possible to use: Constants previously defined. Numeric values . Arithmetic or logical operators . Literals (texts in inverted commas). The sizeof() function. Example: PROGRAM my_game; GLOBAL my_variable=4; position=2 my_variable; // Error: A constant expression was waited for. BEGIN //... END - * In this example, position can not be initialised, as the x local variable is being used for that purpose. ---See: Syntax - Definition of constants The table has been exceeded. The constant expression that starts in the indicated position of the program can not be calculated, as in it you access a table or structure out of its range of positions. Check the range of the table or structure in its definition. Keep in mind that a table defined, for instance, as table[10] has 11 positions (from table[0] to table[10]). Example: PROGRAM my_game; GLOBAL table[]=1, 3, 5; value=table[3]; // Error: The table has been exceeded. BEGIN //... END - In this example, the value variable can not be initialised as an non-existent table position is being used for this purpose. ---See: Syntax - Declaration of table The offset can not be calculated. In the expression indicated in the program, the offset operator (or the & synonymous symbol) is used with the aim of obtaining the address (offset) of an object. That object has no address, as it is not a variable, a table or a structure. Therefore, the compiler can not resolve the expression. Probably you have intended to obtain the address of a constant expression or an expression involving several operands. Now, a program is shown with several examples of valid and invalid uses of the offset operator. Example: PROGRAM my_game; CONST my_constant=0; GLOBAL my_offset=0; my_variable=0; my_table[10]; STRUCT my_structure[10] variable; END BEGIN // Correct examples my_offset=offset my_variable; my_offset=offset my_table; my_offset=offset my_table[my_variable]; my_offset=offset my_structure[0].variable; my_offset=offset id.x; // Invalid examples my_offset=offset (my_variable 2); my_offset=offset my_constant; my_offset=offset 0; write_int(0, 0, 0, 0, offset (my_variable+1)); END - * There is no difference between the use of the offset reserved word or the symbol & . The constants such as my_constant have no offset as they are just synonymous of the numeric value they represent. The statement my_offset=offset (my_variable*2); is invalid as the multiplication is made at first and, once it has been done, the my_variable*2 value is transformed into a numeric result that has no assigned address. Unlikely, the offset my_variable*2 expression is valid as, in this case, the address of my_variable is obtained at first and then, this address will be multiplied by 2 . ---See: Syntax - offset Too many values for the table. A table has been initialised with more values than it can contain. Example: PROGRAM my_game; GLOBAL table1[3]=0, 1,2 , 3, 4; // Error: Too many values for the table. BEGIN //... END - To initialise a table take into account that, at the most, it can have as many values as the number in square brackets plus 1 indicates. Example: PROGRAM my_game; GLOBAL table1[3]=2, 4, 6, 8; BEGIN //... END - In this case, the table table1 may contain four values (table1[0]=2, table1[1]=4, table1[2]=6 and table1[3]=8). Another option is not to indicate the size of the table , so the compiler will deduce it from its initialisation. Example: PROGRAM my_game; GLOBAL table1[]=2, 4, 6, 8; BEGIN //... END - In this case, if it was necessary to refer to the table's length inside the program, the sizeof(table1) expression should be used, being equal to 4 in this example. ---See: Syntax - Declaration of table - sizeof() Division by 0. In the indicated position of the program, a constant expression unresolved because it contains a division by 0 among its operations, appears. On dividing a number by zero results \u00b1 infinite and, as in the programming language only integers within the range ( min_int ... max_int ) can be used, it is not possible either to store the result of that operation in any variable or to relate it with a constant. Example: PROGRAM my_game; CONST infinite=1/0; // Error: Division by 0. BEGIN //... END - It is probably an involuntary error. Thus, on evaluating the expression it is necessary to avoid doing any division by zero. ---See: Syntax - Statement of assignment Table of negative length. To define a table indicating in square brackets its length, it is necessary to use a positive integer (0, 1, 2, 3, ...), taking into account that all the tables start in the zero position and finish in the position indicated in the index. Example: PROGRAM my_game; GLOBAL table1[9]; table2[-9]; // Error: Table of negative length. BEGIN //... END - The compiler has detected a table defined with a negative length such as table2 . In this example, it is necessary to define the table such as table1 that, in this case, will be a table of 10 positions (from table1[0] to table1[9]). ---See: Syntax - Declaration of table expecting for [(] The compiler is expecting for a bracket with the [(](#() symbol to be opened in the indicated position of the program. There are many cases in which the opening of a bracket is obligatory: After a process name or a function , its call parameters must always be indicated in brackets. Even when the process or the function have no parameters, a bracket must be opened and, later, closed. Example: PROGRAM my_game; BEGIN my_process(); //... END PROCESS my_process() BEGIN //... END - In the control statements requiring a condition to control the program's flow, that condition must be put in brackets. Example: PROGRAM my_game; BEGIN IF (x<10) //... END WHILE (x<10) //... END REPEAT //... UNTIL (x<10) SWITCH (x) //... END FOR (x=0;x<10;x++) //... END END - In this example, it is possible to see how the different control statements indicate the condition in brackets. There are two exceptions: The SWITCH statement does not require a condition, but a simple expression, which must be in brackets, anyhow. The FOR statement has three parts inside the brackets, separated by semicolons. These parts are the following ones: initialisation ( x=0 ), condition ( x<10 ) and increment ( x++ ). After the DUP operator (used to initialise tables and structures) it is also obligatory to open a bracket. Example: PROGRAM my_game; GLOBAL table1[]=10 dup (1, 2, 3); BEGIN //... END - In this example, table1 would be a table of 30 positions (from table1[0] to table1[29]) initialised in the following way: 1, 2, 3, 1, 2, 3, ... ---See: Syntax - ( ) Only can be repeated once or twice. The DUP operator used to initialise tables and structures allows us to repeat (duplicate) a sequence of values a specific number of times: from once (in this case, the operator is useless) to an undetermined positive number of times. Example: PROGRAM my_game; GLOBAL table1[]=10 dup (1, 2, 3); table2[]=-10 dup (1, 2, 3); // Error: Only can be repeated once or twice. BEGIN //... END - In this example, table1 would be a table of 30 positions (from table1[0] to table1[29]) initialised in the following way: 1, 2, 3, 1, 2, 3, ... It is also possible, moreover, to omit the DUP operator. In this case, the declaration of table1 would become as follows: table1[]=10(1, 2, 3); The effect is exactly the same as in the previous example. That is to say, when the compiler is in a table's initialisation, the number (sequence_of_values ... ) sequence interprets that you intend to repeat the sequence_of_values the number of times indicated. Therefore, it is not possible to repeat a sequence of values zero times or a negative number of times. ---See: Syntax - DUP Invalid assignment. The indicated assignment can not be done in this position of the program. In an assignment statement it is only allowed to assign values to objects such as variables (of any kind), to a position of a table, or to an element of a structure. It is not possible to assign a value to a constant , a function or to a process or, in general, to any numeric or logical expression. The following program shows examples of several kinds of invalid assignments: Example: PROGRAM my_game; CONST my_constant=0; BEGIN my_constant=1; // Error: Invalid assignment. type my_game=2; // Error: Invalid assignment. sizeof(mouse)=3; // Error: Invalid assignment. 4+5=6; // Error: Invalid assignment. //... END - All these assignments are invalid because the result of an expression, which is just a numeric value, can not be modified with an assignment. Thus, it is the same as to put a statement of the kind 2=4; that, obviously, is impossible. ---See: Syntax - Definition of expression expecting for [END] A block of statements is waited for inside the BEGIN and END reserved words, as well as inside statements such as the following ones: IF ... ELSE ... END LOOP ... END WHILE ... END FOR ... END FROM ... END SWITCH ... END A block of statements finishes (and only can finish) with any of these three reserved words: END , UNTIL or ELSE . In the program, there is a block expected to finish with the END reserved word, but it finishes with another word. The two more usual cases are the following ones: That a REPEAT or a IF have been lost, finishing the statements block with a UNTIL or a ELSE . In this case, the REPEAT or IF associated must be looked for. Example: PROGRAM my_game; BEGIN // REPEAT //... UNTIL (key(_esc)); // Error: expecting for [END]. END - In this example, the statements block that started with the BEGIN of the main program has finished with an UNTIL (because the REPEAT has been accidentally commented), and the compiler was expecting for this block to finish with an END . That an END of any statement has been lost and the following PROCESS or the end of the program expecting for the END that has been lost is reached. Example: PROGRAM my_game; BEGIN IF (x<0) x++; END PROCESS my_process() // Error: expecting for [END]. BEGIN //... END - In this case, the END of the IF has not been put, interpreting the compiler that the IF finishes when the following END (the one of BEGIN ) is reached and, therefore, when the new PROCESS or {#1408,FUNCTION comes, it goes on expecting for the END of the BEGIN . ---See: Syntax - END Invalid expression. In the indicated position of the program there is an expression incorrectly constructed, so the compiler can not interpret it. Check the syntax of the expression. If the error is not found, try to express it in a different way. Try to divide the expression into several subexpressions, sequentially and separately doing the different calculations done in the original expression. For instance, the expression: x=(x*4+1)/2; can be expressed as the three following expressions: x=x*4; x=x+1; x=x/2; Thus, it is possible to locate the exact point in which the operation that can not be done is. ---See: Syntax - Definition of expression expecting for [UNTIL] A block of statements that started with the reserved word REPEAT must necessarily finish with the word UNTIL . In the indicated position of the program, the block of statements has finished with a different word. So probably: A REPEAT has finished with an END . In this case, if you intend to create a loop indefinitely, the LOOP ... END statement must be used. Example: PROGRAM my_game; BEGIN REPEAT //... END // Error: expecting for [UNTIL] END - Inside the REPEAT ... UNTIL loop will appear a spare word such as END or ELSE without its corresponding beginning ( IF , WHILE , ...). Example: PROGRAM my_game; BEGIN REPEAT IF (x<0) x++; END y++; END // Error: expecting for [UNTIL] UNTIL (x>=0); END - In this case, the END of the IF has been put twice, interpreting the compiler that the second END intends to close the REPEAT . Or finally, that you have forgotten to put the UNTIL of the REPEAT . ---See: Syntax - Statement REPEAT - IF - WHILE Local variable that can not be accessed. In the indicated position of the program, the aim is to access a variable of another process. But this is not possible, as this variable is not local in the other process. It is necessary to verify that the variable intended to access either is defined inside the LOCAL section of the program, or is a local variable predefined in the language (such as x , y , graph , size , ...). Example: PROGRAM my_game; GLOBAL id_my_process; score=0; BEGIN id_my_process=my_process(); id_my_process.x=0; id_my_process.score=0; // Error: Local variable that can not be accessed. END PROCESS my_process() BEGIN //... END - In this case, the aim is to access the score of my_process , but score is just a single GLOBAL variable and not a LOCAL variable of every process. This can also happen by trying to access a constant (defined in CONST ) or an expression like: x=id_my_process.(x+1); In this example, the expression makes no sense at all. The following expression would probably be the one intended to be used: x=id_my_process.x+1; (equivalent to x=(id_my_process.x)+1; ). ---See: Syntax - Declaration of local data Invalid parameter. The processes can receive parameters in the following kinds of data: A predefined local variable (like x , size , flags , ...). A local variable defined inside the LOCAL section. A global variable defined inside the GLOBAL section. A private variable of the process declared inside the PRIVATE section of the process. A private variable not declared inside the PRIVATE section. In all these cases, it is understood that a variable can be referred to a variable, to a specific position of a table or to an element inside a structure. In the indicated position of the program, the aim is either to receive a parameter in an object different from those aforementioned, or to indicate an expression instead of a simple variable. These are some examples of invalid parameters' declarations: PROCESS my_process(my_constant) A parameter can not be received in a constant. PROCESS my_process(x*2) A parameter can not be received in an expression. PROCESS my_process(x=0) A parameter can not be received in an assignment. ---See: Syntax - Parameters of a process expecting for another parameter. In the calls to processes or functions, it is necessary to put as many values or expressions as parameters are required, all of them inside the same bracket and separated by commas (,) . This error appears when the bracket is closed after a comma , as in the following example: Example: PROGRAM my_game; BEGIN signal(id, ); // Error: expecting for another parameter. END - There are two reasons for that: either a comma has been accidentally put after the last parameter, or the last parameter has been omitted (like in the previous example). ---See: Syntax - Parameters of a process Invalid number of parameters. The process or function has a number of parameters different from the one that appears in the indicated position of the program. If it is a function, access Glossary to consult the required parameters or place the cursor on the name of the function in the program and then press F1 . If it is a process , then it is possible that in the indicated position, the number of parameters is correct, but a call to this process has previously appeared in the program with a different number of parameters. Example: PROGRAM my_game; BEGIN my_process(); END PROCESS my_process(x, y) // Error: Invalid number of parameters. BEGIN //... END - In this example, the error is not in the definition of the process as it is shown, but in the previous call to that process ( my_process(); ). This is like this because when the compiler finds a call to a process that does not know, it records it like a new process and notes down its number of parameters. If the next time it finds that process the number of parameters does not coincide with those it had recorded, then the error appears. Therefore, if the call or definition of the process shown in the program is correct, then use the search option ( ALT-F ) to check the number of parameters in the previous calls to that process. ---See: Syntax - Parameters of a process expecting for [;] The FOR statement has three parts inside the brackets separated by semicolons. These parts are the following ones: FOR ( initialisation ; condition ; increment ) The initialisation is normally an assignment that sets the value of a variable when the FOR statement starts to run. The condition secondly established determines the continuance inside the loop. In every iteration it will be checked first whether this condition is complied with. Otherwise, the execution of the FOR statement will finish. The increment updates the variable's value that is used as a counter after every iteration of the loop. None of these three parts are obligatory, except the brackets and the two symbols semicolon (;) that separate the parts. Example: PROGRAM my_game; BEGIN FOR ( graph=10 ; graph<20 ; graph=graph+1 ) //... END FOR ( graph=10 ; graph<20 graph=graph+1) // Error: expecting for [;] //... END END - Several statements can be put inside every of the three parts providing that they are separated by commas (,) (several initialisations, conditions or increments). ---See: Syntax - Semicolon (;) - Statement FOR [BREAK] does not appear inside a loop. The BREAK statement makes the program continue after the loop that is running. This statement is used to exit the following loops: LOOP ... END FROM .. TO .. STEP .. ... END REPEAT ... UNTIL ( ](#)) WHILE ( ](#)) ... END FOR ( ](#)) ... END A BREAK statement will make the program continue to be executed after the END or UNTIL of the loop closest to the statement. BREAK can only appear inside one of these loops. If there are several nested loops (one inside another one) the BREAK statement will exit the inner loop. Example: PROGRAM my_game; BEGIN LOOP REPEAT IF (key(_esc)) BREAK; END //... UNTIL (x==0); //... END BREAK; // Error: [BREAK] does not appear inside a loop. END - In this example the BREAK statement will exit REPEAT ... UNTIL (when the ESC key is pressed) but not LOOP ... END . ---See: Syntax - Statement BREAK [CONTINUE] does not appear inside a loop. The CONTINUE statement makes the program finish the current iteration of the loop that is running. This statement is used to go to the beginning/end of the following loops: LOOP ... END A CONTINUE statement inside this loop will jump to LOOP . FROM .. TO .. STEP .. ... END A CONTINUE statement inside this loop will make the increment ( STEP ) and, if the value indicated in the TO has not been passed, the program will continue at the beginning of the loop. REPEAT ... UNTIL ( ](#)) A CONTINUE inside this loop will jump to UNTIL . WHILE ( ](#)) ... END A CONTINUE inside this loop will jump to WHILE . FOR ( ](#)) ... END A CONTINUE inside this loop will make the increment and the comparison. If the latter is true, the program will continue at the beginning of the loop. But if it is false, the program will continue after the END of the FOR . CONTINUE must obligatory appear inside one of these loops . If there are several nested loops (one inside another) the CONTINUE statement will take effect only in the inner loop. Example: PROGRAM my_game; BEGIN FOR (x=0, y=0;x<10;x++) IF (x<5) CONTINUE; END y++; END END - In this example, after the whole loop has been executed, x will be equal to 10 and y will be equal to 5 as, providing that x is less than 5, the CONTINUE statement prevents the y++; statement from being executed. ---See: Syntax - Statement CONTINUE expecting for [CASE], [DEFAULT] o [END] The syntax of the SWITCH statement is, broadly speaking, as follows: SWITCH ( ](#-)) CASE value : statements ; END CASE value .. value : statements ; END CASE value, value, value : statements ; END //... DEFAULT : statements ; END END The position indicated in the program is inside a SWITCH statement, but out of a CASE or DEFAULT section. For that reason, the compiler was expecting for one of the three following statements to appear in that position: The reserved word CASE starting a new section to be executed when the expression would coincide with the indicated value. The reserved word DEFAULT starting a section by default to be executed when the expression would not coincide with any of the values indicated in the different sections CASE . The reserved word END finishing the SWITCH statement. For a more detailed description of the SWITCH statement, consult the syntax of the language. ---See: Syntax - Statement SWITCH expecting for [END] An END of the CASE or DEFAULT was waited for inside the SWITCH statement. Inside the reserved words SWITCH and END one or more sections of the following kind were waited for: CASE ... END DEFAULT ... END In the program, there is one of these sections that was expected to finish with the reserved word END , but it finishes with another word. The most usual case is the following one: That a REPEAT or a IF have been lost, finishing the block of statements with an UNTIL or an ELSE . In this case, the associated REPEAT or IF must be looked for. Example: PROGRAM my_game; BEGIN SWITCH (x) CASE 0: //REPEAT //... UNTIL (key(_esc)); // Error: expecting for [END] END END END - In this example, the section that started with CASE has finished with UNTIL (because REPEAT has been accidentally commented), and the compiler was expecting this section to finish with END . ---See: Syntax expecting for [PROCESS] The compiler has interpreted that, in the indicated position of the program, the main program ( PROGRAM ... BEGIN ... END ), or the last process ( PROCESS or function ( FUNCTION ) and have finished and then, it was expected that either a process would start or the program would finish. The most frequent is to have duplicated END inside the last block of statements BEGIN ... END . Example: PROGRAM my_game; BEGIN IF (x<0) x++; END END FRAME; // Error: expecting for [PROCESS]. END - In this example, the END of the IF has been accidentally put twice, interpreting the compiler that the second is that of END of the BEGIN . Therefore, after this last END only the end of the program or the reserved word PROCESS or FUNCTION can come, marking the beginning of a new process. When a FRAME statement is placed in that position, the compiler reports the error. ---See: Syntax - Declaration of process A table can not be specified as a parameter. It is not necessary to declare the parameters of the process inside the PRIVATE section, as they are automatically declared. But if they are declared, they must be declared as variables, not as tables or structures, and they must not be initialised. You have probably intended to use the same name for two different objects. On the one hand, for the parameter of the process and, on the other hand, for a PRIVATE table of the same process. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a) PRIVATE a[9]; // Error: A table can not be specified as a parameter. BEGIN //... END - The compiler interprets that the parameter a is being typified as a table of 10 positions and, since a table can not be passed as a parameter, it reports the error. ---See: Syntax - Parameters of a process A parameter can not be initialised. It is not necessary to declare the parameters of the process inside the PRIVATE section, as they are automatically declared. But if they are declared, they must be declared as variables, not as tables or structures, and they must not be initialised. You have probably intended to use the same name for two different objects. On the one hand, for the parameter of the process and, on the other hand, for a PRIVATE variable of the same process. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a) PRIVATE a=0; // Error: A parameter can not be initialised. BEGIN //... END - The compiler interprets that the parameter a is being initialised at 0 and, as it is not allowed to initialise a parameter (as it will take its value depending on the call to the process), the error is reported. ---See: Syntax - Parameters of a process The end came inside a comment. The end of the program has come inside a comment of several lines (those defined between the /* and */ symbols). This error appears because any comment has not been closed. Therefore, check that all the comments opened with the /* symbol have their corresponding */ symbol closing them. Example: PROGRAM my_game; BEGIN / Beginning of the comment FRAME; END // Error: The end came inside a comment. - * ---See: Syntax - Definition of comments It is not possible to access external PRIVATE data. In the indicated position of the program, there is an attempt to access a PRIVATE variable of another process. It is not allowed. If the aim is to access a variable of a process from another process, this variable must be declared inside the LOCAL section. Example: PROGRAM my_game; PRIVATE n; BEGIN my_process(); //... END PROCESS my_process() PRIVATE n; BEGIN father.n=0; // It is not possible to access external PRIVATE data. END - It is not possible to access PRIVATE data, even when the accessed process is of the same kind as the process that is trying to access the variable. The correct way to declare the variable n in the previous example is as follows: Example: PROGRAM my_game; LOCAL n; BEGIN my_process(); //... END PROCESS my_process() BEGIN father.n=0; END - Keep in mind that all the processes of the program will have the data declared inside the LOCAL section (all the processes of the previous example will have an own variable named n ). ---See: Syntax - Declaration of PRIVATE data A structure must contain one element, at least. In the indicated position of the program, the aim is to close the declaration of a structure without any element (field) defined in it with END . A structure ( STRUCT ) is like a list of index cards (records) with several pieces of information (fields) in every index card. STRUCT name_structure[10] x, y; END In this example, the structure (set of index cards) is called name_structure and it has 10 records (ten index cards) with 2 fields each one (with two pieces of information; x and y ). Therefore, defining a structure without fields makes no sense (since it is the same as defining a set of index cards with no piece of information). Then, to access the information of the index cards, the structure is used as follows (suppose that in the global variable n the aim is to put the value y of the index card number 5 ). n=name_structure[5].y; An invalid program is shown now. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[10] END // Error: A structure must contain one element, at least. BEGIN //... END - ---See: Syntax - Declaration of structure expecting for an element of the structure. In the indicated position of the program, the aim is to declare an invalid element (field) of the structure. A structure can just have the following kind of fields: A variable. In this case, the name of the declaration without being initialised must be indicated. A table, indicating its name and, subsequently, its length in square brackets (keep in mind that a table declared like my_table[9]; is a table of 10 positions, from my_table[0] to my_table[10]). They must not be initialised. Another structure. It is possible to include as many structures inside other structures as necessary, with no limit of nesting. An example of structures nesting is shown now. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[9] elements; STRUCT data[9] x, y; END END a, b; BEGIN FROM a=0 TO 9; my_structure[a].elements=-1; FROM b=0 TO 9; my_structure[a].data[b].x=-1; my_structure[a].data[b].y=-1; END END //... END - In this example, every record of my_structure will have a variable called elements and another structure with 10 elements, each one with two variables: x and y . Next, in the same example, it is possible to see an example of access to that structure with two nested loops that initialise all the values of the structure at -1 . To see how to initialise the values of a structure in the definition itself, go to the topic syntax . ---See: Syntax - Declaration of structure It is not a type of process. The TYPE operator may only be used if it goes before a process name of the program or the word mouse (to detect collisions with the mouse pointer). In the indicated position of the program, it is not preceding a process name. It is probable either that the process name has been incorrectly written or that the type of a process is intended to be obtained from its identifying code . There is a way to obtain the type of a process having its identifying code , as it is shown below (suppose that we have the identifier in the id2 variable). id2.reserved.process_type Instead of TYPE id2 that is not allowed (as there is no process named id2 , since id2 is a variable). Next, an example of correct use of the TYPE operator is shown (with the aim of obtaining the identifying code of a process). Example: PROGRAM my_game; PRIVATE id2; BEGIN //... id2=get_id(TYPE my_process); //... id2=get_id(TYPE id2); // Error: It is not a type of process. //... END PROCESS my_process() BEGIN //... END - As it can be noticed, the TYPE operator requires the process name of the program with no brackets or parameters. ---See: Syntax - Types of processes The size can not be calculated. The sizeof() function may be used to obtain the number of elements of a table or structure. For that purpose, it requires in brackets , the name of the table or structure (with no square brackets or index). It can also be used with the name of a variable but, in this case, the function will always return 1. It can indistinctly be used with global, local or private data. In the indicated position of the program, the aim is to obtain the size of an object that is not a variable, table or structure. For instance, this error will appear if the aim is to obtain the size of a constant, function, process, etc. Example: PROGRAM my_game; CONST my_constant=99; GLOBAL a=sizeof(my_constant); // Error: The size can not be calculated. BEGIN //... END - This example will provoke the error on trying to obtain the number of elements of a constant , as a constant is not an object having a size, but just a synonymous of the numeric values that it represents. ---See: Syntax - sizeof Use: import \"name.dll\" The compiler was expecting for the file name to appear in inverted commas after the reserved word IMPORT . To declare the use of an external library, it is necessary to put a declaration like that of the following example. Example: PROGRAM my_game; IMPORT \"library.dll\"; BEGIN //... END - This program declares the use of the library called library.dll (alleged name of an hypothetical library of external functions). This declaration must be put just before the PRIVATE section or the BEGIN of the main program. It is possible to make several IMPORT declarations in a row to declare the use of more than one library ---See: Syntax - Declaration of libraries Use of an invalid external DLL. In the indicated position of the program, the aim is to load an invalid DLL , which is explained for the following reasons: The file with the DLL has become corrupted because it has been stored in a damaged environment. It is not a DLL specifically designed for DIV Games Studio. The file with extension DLL is not found in the path specified by the IMPORT statement. It is not possible to use DLL of other languages, as they are not compatible with this language even if all the files have the extension DLL . When this DLL has been prepared for this language, check the installation instructions and verify either that the file with extension DLL is in the directory of DIV Games Studio, or that the IMPORT statement specifies the complete path of that file. ---See: Syntax - Declaration of libraries Expression with no sense. In the indicated position of the program, the compiler has supposed that a statement of the following types started: Assignments, e.g.: = ** ; ** Increments or decrements, e.g.: ++ ; Call to a process or function, e.g.: ( ... ) ; Nevertheless, it has found an expression that apparently makes no sense, as once its operations have been done, its result is not used for any purpose. It is probably an isolated operator that has been left out of a statement, for instance, because an operator has been lost. Example: PROGRAM my_game; BEGIN x+1; // Error: Expression with no sense. //... END - This error is reported in this example, as the x+1; statement is not useful; it adds the x variable and the constant 1 but then, this result is not used for any purpose. If the aim is to add 1 to the x variable, then the following statement must be used: x=x+1; Here, the x variable and the constant 1 are added and then this result is assigned to the x variable. It could have also been done with the x++; statement (incrementing x). ---See: Syntax - Statement of assignment expecting for [:] The indicated position in the program is inside a SWITCH statement, after the beginning of a section with \" CASE value\". For that reason, the compiler was expecting for the symbol : to appear in this position preceding the statements of that section. The syntax of the SWITCH statement is, broadly speaking, as follows: SWITCH ( ](#-)) CASE value : statements ; END CASE value #, .. value : statements ; END CASE value, value, value : statements ; END //... DEFAULT : statements ; END END For a more detailed description of the SWITCH statement, consult the syntax of the language. ---See: Syntax - Statement SWITCH expecting for [;] The compiler is expecting for a semicolon (;) in the indicated position of the program. In the language, the following points of the program must be indicated with semicolons: The end of the options of compilation . The end of the declaration PROGRAM . The end of a declaration of data . The end of a declaration IMPORT . The end of the following statements: Assignments or increments of data . Calls to processes . Calls to functions . FRAME , RETURN , DEBUG , BREAK and CONTINUE . The end of the beginning of a loop FROM . And as division of the different parts of a FOR statement. The compiler will indicate when the symbol ; is missing in any of these periods. Moreover, this symbol can be put in other specific points of the programs. For instance, after any other type of statement, even if, in this case, it will be optional and, therefore, the compiler will not notice its lack. ---See: Syntax - ; expecting for a variable. The compiler was expecting for a global, local or private variable of the process in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly. If the aim is to use a variable of another process, a table or an element of a structure as a counter, the FOR statement must be used instead of FROM , as it allows us to define the conditions of the loop more freely. ---See: Syntax - Statement FROM expecting for [=] The compiler was expecting for a symbol = (assignment) in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly, and then the symbol = (assignment). Example: PROGRAM my_game; GLOBAL id2; BEGIN //... FROM id2.x=0 TO 9; // Error: expecting for [=]. //... END END - In this example, the error will appear on detecting the symbol . (period) instead of = after the first name ( id2 ) that appears. This happens because a variable of another process can not be used as a counter of a FROM loop. If the aim is to use a variable of another process, a table or an element of a structure as a counter, the FOR statement must be used instead of FROM , as it allows us to define the conditions of the loop more freely. ---See: Syntax - Statement FROM expecting for [TO] The compiler was expecting for the reserved word TO of the FROM statement in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly, and then the symbol = (assignment), preceding a constant. After this constant value, only the reserved word TO can appear. Example: PROGRAM my_game; GLOBAL id2; BEGIN //... FROM id2.x=0 STEP 9; // Error: expecting for [TO]. //... END END - In a FROM statement, the initial and final values of the loop's counter variable must always appear in both sides of the word TO . ---See: Syntax - Statement FROM The value STEP is not valid. In a FROM statement: If the initial value is less than the final value, a negative value can not be specified in the declaration STEP . If the initial value is bigger than the final value, a positive value can not be specified in the declaration STEP . Example: PROGRAM my_game; BEGIN FROM x=0 TO 10 STEP -1; // Error: The value STEP is not valid. //... END END - This loop is not valid as, if 1 is subtracted from x (that originally will be equal to 0 ) in every iteration, it will never reach 10 . If the aim is to create a continuous loop, the LOOP statement must be used. ---See: Syntax - Statement FROM Invalid FROM statement. In a FROM statement: The initial and final values of a FROM loop must be different. Example: PROGRAM my_game; BEGIN FROM x=0 TO 0; // Error: Invalid FROM statement. //... END END - Creating this loop makes no sense, as the inner set of statements will be repeated just once, which would be equivalent to initialising x at 0 (with the x=0; statement) and, then, to directly putting the inner statements, omitting the loop FROM . If the aim is to create an ever-repeating loop, the LOOP statement must be used. ---See: Syntax - FROM statement Correct compilation The program has no errors of compilation. Press: Menu programs\\Execute or F10 . To save, compile and execute the program. Menu programs\\Debug or F12 . To save, compile and debug the program step by step. Exceeded the capacity of the names vector. The buffer to store the names of the program has been exceeded. This error can only be due to the fact that too long data names and processes have been used. The only solution to compile the program is to replace some of these names by other shorter names. Exceeded the capacity of the demo version. This DEMO version of DIV Games Studio does not allow us to create programs as big as this one. It can only compile programs of a specific number of variables and processes. In the complete version of DIV GAMES STUDIO does not exist this limit, being possible to create programs of any size. The only option to compile this program is first eliminating all the processes and data that are no longer required or indispensable. Exceeded the capacity of the table of objects. The available space to store data records and the program's processes has been exceeded. This error should never happen, but when it happens it is difficult to resolve. The program is too big for this version of the compiler. If there is a new version of the compiler or any 'patch' that updates this limitation, it must be updated. Otherwise, the only option is to eliminate from the program all the processes and data that are not required or essential any longer. expecting for the structure name. To define a structure of data, its name must be specified after the reserved word STRUCT . Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END BEGIN //... END - This structure has been defined with the name positions and contains ten records (from 0 to 9) each one with two values x and y . ---See: Syntax - Names - Declaration Structures expecting for the process name. To define a process, its name must be specified after the reserved word PROCESS . Example: PROGRAM my_game; BEGIN //... END PROCESS my_process() BEGIN //... END - This process has been declared with the name my_process . ---See: Syntax - Names expecting for the name of a process. The name of one of the processes defined in the program must be defined after the reserved word TYPE . Example: PROGRAM my_game; BEGIN //... signal(TYPE my_process, s_kill); //... END PROCESS my_process() BEGIN //... END - ---See: Syntax - Names - Types of processes expecting for a name. As a parameter, the sizeof() function requires the name of a variable. It can also be the name of a variable, a table or a structure of the program. This function returns the number of data (or elements) that the object whose name is passed as an argument has. Therefore, if that object was a variable, the function would always return 1. Example: PROGRAM my_game; GLOBAL table[]=0, 1, 2, 3; length_table; BEGIN length_table=sizeof(table); END - In this example length_table will be equal to 4 after the statement execution, as the table contains four data. ---See: Syntax - Names - sizeof The name is not new. A name has been used twice for a field of the structure. You must replace this name by another similar one. Example: PROGRAM name_of_the_program; GLOBAL STRUCT position[9] x0, x0; // Error: The name is not new. END BEGIN //... END - ---See: Syntax - Names - Declaration of structure The name is not new. An invalid program's name has been used as it was already predefined as the name of another object. You must replace this name by another similar one. In order to know which is the object identified with that name , it is possible to access the Glossary . Example: PROGRAM x; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as the name of the program, that is predefined as the name of the local variable that indicates the x coordinate of the processes. ---See: Syntax - Names - Glossary The name is not new. To define a constant , an invalid name has been used, as it was already predefined as the name of another object. It can be the name of a constant, variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; CONST x=0; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as a constant's name that is predefined as the local variable that indicates the x coordinates of the processes. ---See: Syntax - Names ----------------------------------------------------------------------------- The name is not new. To define a new data, an invalid name has been used, as it was already predefined as the name of another object. It can be the name of a constant , variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; GLOBAL x[3]=0, 1, 2, 3; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as a global table's name that is predefined as the local variable that indicates the x coordinates of the processes. ---See: Syntax - Names The name is not new. A name of an invalid process has been used, as it was already predefined as the name of another object. It can be the name of a constant , variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; BEGIN //... END PROCESS my_game() // Error: The name is not new. BEGIN //... END - In this example, the aim was to use the name that had been previously used to identify the main program as the name of a process. ---See: Syntax - Names expecting for [=] To define a constant, a symbol = must be put after the name of the constant. The compiler has understood that the last defined word was the name of a new constant and, in the indicated position, it was expected for the symbol of assignment ( = ) to be shown. Example: PROGRAM my_game; CONST a=0; b=1; c,d; // Error: expecting for [=]. BEGIN //... END - ---See: Syntax - Declaration of data Too many values for the structure. A structure has been initialised with more values than it can contain. To initialise a structure, take into account the greatest number of values that it can contain. This number will be: N\u00ba of records X N\u00ba of fields Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END = 10 dup (-99, 99); BEGIN //... END - In this case, the structure positions has 10 records (from positions[0] to positions[9]) and 2 fields (x and y). Then, the greatest number of values that it can contain is 20 . In the example, all the fields x are initialised at -99 and all the fields y are initialised at 99 . ---See: Syntax - Declaration of structure Unknown name. In the indicated position of the program, reference is made to a non-existent PROCESS FUNCTION , that can be one of the following cases: The name of a process has been incorrectly keyed. In this case, check the name of the original process, as it is possible that the name does not correctly appear in its definition. The aim has been to use a language function and its name has not been correctly written. In this case, it is possible to access the general index to look for the exact name of the function. Reference is made to a process whose code has not been defined yet. Therefore, if the aim is to compile the program, it is necessary to define the process, at least, as follows: Example: PROGRAM my_game; BEGIN my_process(); END PROCESS my_process() BEGIN END - Indicating in the process the parameters that it receives (in the previous example, it does not receive any parameter). ---See: Syntax The increment can not be performed. In the indicated expression of the program the operator ++ (or the operator -- ) are incorrectly used with the aim of incrementing (or decrementing) an object. That object has no offset, as it is not a variable, table or structure. Thus, the compiler can not perform an increment (or decrement) about it. The aim has probably been to increment or decrement a constant expression or an expression involving several operands. Now, a program with several examples of valid and invalid use of the operators ++ and -- , is shown. Example: PROGRAM my_game; CONST my_constant=0; GLOBAL my_variable=0; my_table[10]; STRUCT my_structure[10] variable; END BEGIN // Valid examples my_variable++; my_table--; ++my_table[my_variable]; --my_structure[0].variable; id.x++; // Invalid examples (my_variable 2)++; my_constant--; ++0; --(my_variable+1); END - * The constants like my_constant can not be incremented as they are just synonymous of the numeric value they represent. The (my_variable*2)++; statement is not valid because the multiplication is first done and then, the value my_variable*2 becomes a numeric result that has no offset and, therefore, it is not possible to access it in order to increment it. In this case, the correct statement that should have been used is probably my_variable=my_variable*2+1; ---See: Syntax - ++ - -- Structure of negative length. To define a structure indicating its number of records in square brackets a positive integer (0, 1, 2, 3, ...) must be used, taking into account that all the structures start in the record zero and finish in the record indicated in the index. Example: PROGRAM my_game; GLOBAL STRUCT e1[9] x, y; END STRUCT e2[-9] // Error: Structure of negative length. x, y; END BEGIN //... END - The compiler has detected a structure defined with a negative number of records, like e2 . In this example, the structure must be defined as e1 that, in this case, will be a structure of 10 records (from e1[0] to e1[9]) and two fields (x and y). ---See: Syntax - Declaration of structure A statement was expected. The indicated position of the program is within the context of a block of statements. Thus, a statement was expected to start in the indicated position. These are the possible types of statements: assignment statements = ; control statements IF and SWITCH . loop statements FROM , WHILE , REPEAT , LOOP and FOR . break statements BREAK , CONTINUE and RETURN . special statements FRAME , CLONE and DEBUG . Being possible that, in this position, one of the following reserved words that can mark the end of a block of statements appear: END , ELSE and UNTIL . Example: PROGRAM my_game; BEGIN CASE 0: // Error: A statement was expected. //... END END - This example will provoke error, because the reserved word CASE is not valid to start a statement. It is only valid inside a SWITCH statement. ---See: Syntax - Declaration of statements expecting for the name of the string To define a string of text you must specify the its name after the reserved word STRING . Example: PROGRAM my_game; GLOBAL STRING player[32]; STRING message; BEGIN //... END - In this example two global text strings were defined. The first is defined with the name player which can accumulate up to 32 characters and the second with the name message which with the undeclared length can accumulate up to 256 characters (because this is the application's maximum size of text strings). ---See: syntax - names The name has already been allocated An item has been given a name that has already been used. It could be a name, a constant, a variable, a table, a structure, a process or function of the program. You may be attempting to use the same name inside the program to identify two different objects, or {a name you allocated is predefined for another use was inside the language}. In this case you can access the glossary to see to which object the name belongs to. In each case, you must substitute this name with another one . Example: PROGRAM name_of_program; GLOBAL player=0; STRING player; // Error: The name is not unique. BEGIN //... END - ---See: syntax - Names Text string has a negative length To define a text string you indicate in brackets its length, it is necessary for its length to be defined as a positive whole number (0, 1, 2, 3, ...), remembering that all strings begin in the position null and finish in the position which indicates the index. Example: PROGRAM my_game; GLOBAL STRING string1[9]; STRING string2[-9]; // Error: Text string has negative length. BEGIN //... END - The compiler detected a text string with a negative string length such as string2 ; in this example you must define the string as string1 which will be the string of 10 characters (from string1[0] to string1[9]). ---See: syntax a literal was expected Literals are texts in brackets . In the indicated position of the program a literal was expected to be given as the initial value of a text string. The text strings can be initiated as shown in this example. Example: PROGRAM my_game; GLOBAL STRING string=\"initial text in the string\"; BEGIN //... END - It is not obligatory to initiate the text strings of a program. In the case of initiation, the string could have an empty text (\"\") at the beginning of the program, so, these two declarations would be identical: STRING string; STRING string = \"\" ; In these cases, their length is not declared, therefore the strings can accumulate to a maximum of 256 characters (because this is the maximum size allowed for strings of text). ---See: syntax Literal is too long A text string was initiated with a literal with a bigger number of characters than the string can contain. Example: PROGRAM my_game; GLOBAL STRING string1[3]=\"ABCDE\"; // Error: Literal is too long BEGIN //... END - To initiate a text string you must remember that the maximum number of characters it can contain is the number contained in square brackets, plus one. Example: PROGRAM my_game; GLOBAL STRING string1[3]=\"ABCD\"; BEGIN //... END - In this case a text string string1 can contain four characters (string1[0]=char(\"A\"), string1[1]=char(\"B\"), string1[2]=char(\"C\") and string1[3]=char(\"D\")). The other option is not to indicate the size of the text string , establishing in this case the string size maximum of 256 characters. Example: PROGRAM my_game; GLOBAL STRING string1=\"ABCDEF\"; BEGIN //... END - In this case, string1 would contain initially six indicated characters (\"ABCDEF\"), but it can reach 256 during the execution of the program. ---See: syntax A comma was expected It is accessing an array indicating less dimensions than required. It means that an array of two dimensions is pretending to take one dimension as its parameters or an array of three dimensions is attempting to use it as a two dimensional array. Example: PROGRAM my_game; GLOBAL array1[9,9]; BEGIN //... array1[0]=0; // Error: A comma was expected. END - Check the previous declaration of the named array of data in the program. ---See: syntax A comma was expected It is accessing a structure indicating less dimensions than required. It means that a structure of two dimensions is attempting to use one dimension as its parameters or a structure of three dimensions is attempting to use it as a two dimensional structure. Example: PROGRAM my_game; GLOBAL STRUCT structure1[9,9]; n; //... END BEGIN //... structure1[0].n=0; // Error: A comma was expected. END - Check the previous declaration of the named structure of data in the program. ---See: syntax Cannot calculate the offset of the data In the expression indicated in the program the operator offset is used (or synonymous symbol & ) with the goal to obtain the location (dislocation) of a character , byte or word which belongs to a table. It is only possible to obtain the location at the beginning of the table, but not of its data (except such data as int ). Shown below is a program with two examples of the use of the operator offset (or the symbol & ) for tables of such type byte ; one valid, another not. Example: PROGRAM my_game; GLOBAL BYTE my_table[99]; offset_data; BEGIN // Correct example offset_data=offset my_table; // Erroneous example offset_data=offset my_table[1]; END - It is also applicable to text strings (data like string ), meaning, it is not possible to obtain the location of a character inside of the string. In this case, the operator offset is not necessary to obtain the dislocation of a string of text (it can be omitted). It means, that both of these two statements would be valid: offset_string = offset my_string ; offset_string = my_string ; Note: To operate with the text strings one has to use the functions of the language which were written to manipulate text (see for example strcpy() ). ---See: syntax - offset Assignation to incorrect string With text strings you can only realise assignations of three types: Conventional assignations (=), a copy of the string to the right of the = sign will be made to the left-hand string. Sum and assignation (+=), the substring on the right hand side will be added to the left-hand string. Subtraction and assignation (-=), characters of the string will be removed. If another type of assignation is attempted this error will be given. ---See: syntax - Definition of expression text string is too long To define a string of text indicating in brackets its length, one must use a whole number less than 1048576 , remembering that all strings start from the position zero and finish in the position which indicates the index. Example: PROGRAM my_game; GLOBAL STRING string1[29999999]; // Error: text string is too long. BEGIN //... END - The compiler detected a text string that was too long, such as string1 ; the maximum that can be declared is a string of text of 1 Megabyte, with such declaration: STRING string1 [ 1048575 ]; string1 can contain up to 1024*1024 characters, from string1[0] to string1[1048575]. ---See: syntax Incorrect initiation The number of values indicated in the initiation does not coincide with the previous declaration of the structure. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[9]; STRING name; x,y; END = 10 dup (\"AAA\",0); // Error: Incorrect initiation. BEGIN //... END - In the last example the program declares a structure of three fields, and then initiates it as if it had only two fields. You must check the original declaration, always remembering that a structure as my_structure[9] has 10 registers (from 0 to 9 ). For example, the valid initiation for the structure would be: 10 dup ( \"AAA\" , 0 , 0 ); ---See: syntax expecting [;] The compiler expects a semicolon (;) in the position indicated in the program. In the language you must indicate the end of a declaration of data with a semicolon. ---See: syntax - ; Expecting a compilation option The compiler was expecting a compilation option in the indicated position of the program. See the options of compilation disposed in this version of the language. ---See: syntax - Headline of program Expecting [=] To set a maximum number of processes you must use the statement compiler_options as it is shown in this program: Example: COMPILER_OPTIONS _max_process = 100; PROGRAM my_game; BEGIN //... END - In this case it was established that during the execution of the program ** a maximum of 100 processes** can execute simultaneously. ---See: syntax Assignation inside of a condition The compiler detected, in the fly out position of the program, a statement of assignation inside of one condition. Probably was intended to compare two values using for it the assignation symbol = , instead of the symbol of comparison / equivalence == . Note for new users: If you want to compare two values with the symbol = , you must include in the program the option _simple_conditions . For it you must put in the first line (before PROGRAM ... ) this statement: COMPILER_OPTIONS _simple_conditions; Note for users of the previous version: In this new version of the language are prohibited the assignations inside of one condition , to simplify the program syntax for new users. But it can be changed with the options of compilation (see _extended_conditions and _simple_conditions ). ---See: syntax - Compiler_options The length does not coincide with the previous declaration a text string or pointer was declared twice , as a parameter and as private data, and in the declarations a different length was specified. It is not necessary to declare this data as private, because you can specify its length in the same parameters of the process. Example: PROGRAM name_of_program; BEGIN //... END PROCESS my_process(string my_string[16]) BEGIN //... END - The process of this example receives a parameter in a private string (but this is not indicated in the process) of 17 characters in length (from my_string[0] to my_string[16]). The previous process can return to declare this string in the section PRIVATE (for example, to add an explanatory commentary), but in this case the specified lengths must coincide. In this case, my_string will be declared as shown below. Example: PROGRAM name_of_program; BEGIN //... END PROCESS my_process(string my_string[16]) PRIVATE string my_string[16]; // Here I will receive some text. BEGIN //... END - ---See: syntax - Declaration of private data Expecting a name To define a table or group of bytes you must specify its name after the reserved word BYTE . Example: PROGRAM my_game; GLOBAL BYTE my_byte; BYTE my_table1[127]; BYTE my_table2[255,255]; BEGIN //... END - In this example three variable of this type were defined. The first is the name my_byte which can contain only the values (between 0 and 255), the second with the name my_table1 can contain up to 128 values from (from my_table1[0] to my_table1[127]), and the third, which is a table of bytes of two dimensions, can contain a total of 65536 values (the result of multiplying 256 by 256). ---See: syntax - Names Value of BYTE out of rank (0...255) a variable of type BYTE was initiated with a value too big, or negative. This type of data can only contain values inside the rank 0 ... 255 . Example: PROGRAM my_game; GLOBAL BYTE mi_value=300; // Error: Value of byte out of rank (0...255). BEGIN //... END - If you want to assign this value to the data, you must not declare the data of this type BYTE , as is shown in this program. Example: PROGRAM my_game; GLOBAL my_value=300; BEGIN //... END - As this form creates a variable which can contain a whole number value inside the rank ( min_int ... max_int ). ---See: syntax Value of word out of rank (0...65535) A WORD was initiated with a value too big or negative. This type of data can only contain values inside the rank 0 ... 65535 . Example: PROGRAM my_game; GLOBAL WORD my_value=70000; // Error: Value of word out of rank (0...65535). BEGIN //... END - If you want to assign this value to the data, you must not declare the data as type BYTE , as is shown in this program. Example: PROGRAM my_game; GLOBAL my_value=70000; BEGIN //... END - As this form creates a data which can contain a whole number value inside the rank ( min_int ... max_int ). ---See: syntax Expecting a name To define a table of bytes you must specify its name after the reserved word WORD . Example: PROGRAM my_game; GLOBAL WORD my_word; WORD my_table1[127]; WORD my_table2[255,255]; BEGIN //... END - In this example three variable of this type were defined. The first is the name my_word and can only contain a value (between 0 and 65535), the second with the name my_table1 can contain up to 128 values (from my_table1[0] to my_table1[127]), and the third, which is a table of bytes of two dimensions, can contain a total of 65536 values (because it is the result of multiplying 256 by 256). ---See: syntax - Names Cannot specify a table as the parameter The parameters of the process must be declared as variables, not as tables or structures, and cannot be initiated (because they will receive their value with each call). Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a[9]) // Error: Cannot specify a table as the parameter. BEGIN //... END - The compiler interprets the parameter a as a table of 10 positions, and cannot pass a table as the parameter, so emits the error. ---See: syntax - Parameters of a process statement IMPORT is incorrect (see corresponding help) The declaration of external libraries must be done {below the headline of the program}, in other words, after the declaration PROGRAM name_of_program; . Different declarations of IMPORT can be used to declare the use of more than one library, as in this example. Example: // Headline of the program PROGRAM my_game; // Declaration of libraries IMPORT \"lib1.dll\"; IMPORT \"lib2.dll\"; //... // And in continuation (optional) the rest of the sections that make up the program. CONST //... GLOBAL //... LOCAL //... PRIVATE //... BEGIN //... END - This program declares the use of the denoted libraries lib1.dll and lib2.dll (supposed names of hypothetical libraries with external functions). Note 1: In the original version of DIV, this declaration had to be done between sections LOCAL and PRIVATE of the program. Note 2: The libraries prepared in the original (DIV1) version of the language will not function correctly in DIV2, it is necessary first to re-compile these libraries with new files of declarations. It means, that the font code of the libraries will be valid, but beforehand they must be re-compiled with new headline files (because they contain declarations for the new data and structures which exist in the DIV2 language). ---See: syntax - Declaration of libraries expecting a name To declare a pointer you must specify its name after the reserved word POINTER (or the symbol * ). Example: PROGRAM my_game; GLOBAL POINTER ptr; WORD POINTER my_words[15]; BYTE POINTER my_bytes; BEGIN //... END - In this example three variable of this type were defined. The first with the name ptr is a pointer to any conventional data, and it has no limitation of rank in its access (you can access ptr[ n ]with n being any value). The second is a pointer to data of type WORD (whole value between 0 and 65535) with a limitation of access to the first 16 values only. And the third is a pointer of data of type BYTE (whole between 0 and 255) without limitation of rank. ---See: syntax - Names expecting a name To declare a data type you must specify its name after the reserved word INT , but in this case it is not so important (because all the data by default will be of the same type). Example: PROGRAM my_game; GLOBAL INT a,b; // declare two whole number data c,d; // declare another two whole number data BEGIN //... END - In this example you can see 4 data of the type whole number declared, for the first two ( a and b ) the type was specified as (INT) (as in \"integer\"), but there is no difference, in the level of declaration, with the last two ( c and d ), because these would also be data of the type (INT). ---See: syntax - Names Incorrect declaration of the pointer to a structure The compiler was expecting, at the indicated position of the program, the name of a structure previously declared, with the intention of declaring it as a pointer. To define a pointer to a data structure you must use the following syntax: STRUCT POINTER name_structure name_pointer; name_structure being the name of a data structure declared previously in the program, and name_pointer being the name of a pointer to the structure which is being declared. ---See: syntax - Names - Declaration Structures Cannot receive a structure as the parameter A process cannot receive a structure as its parameter, if you want to access an external structure from a process, the process must receive as its parameter a pointer to the structure. Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END BEGIN my_process(OFFSET positions); //... END PROCESS my_process(STRUCT POINTER positions pos[9]); BEGIN //pos[ ... ].x = ... ; //... END - In this example you can access the structure inside my_process using the pointer pos . ---See: syntax - Names - Declaration Structures expecting a name of structure The indicated function requires as its parameter, at the indicated position, the name of a data structure of the program. You do not have to use the operator offset , you just need to indicate the name of the structure. Example: PROGRAM my_game; GLOBAL STRUCT records[9] STRING initials[2]; points; END BEGIN //... qsort(offset records,points,1); // Error: expecting a name. END - In this example the function qsort is used, which requires the name of a structure as its first parameter. In this case, the correct instruction to order the table records is this one: qsort(records,points,1); This instruction indicates how to order the structure, namely as a function of the field points and in descending order. Note 1: Also it is possible that the indicated name has nothing to do with a structure of data, but with the another type of object (for example, the name specified was of a table of data). Note 2: This data structure cannot belong simultaneously to another structure, so you cannot specify the name of a structure inside another one. ---See: syntax expecting a field of the structure The indicated function requires as its parameter, in the indicated position, the name of a field pertinent to the structure previously indicated . You don't have to use the operator offset , you only need to indicate the name of the field. Example: PROGRAM my_game; GLOBAL STRUCT records[9] STRING initials[2]; points; END BEGIN //... qsort(records,&points,1); // Error: expecting a field of the structure. END - In this example the function qsort is used, which requires the name of a field of the structure as its second parameter. In this case, the instruction to order the table (records) would be : qsort(records,points,1); This instruction indicates how to order the structure, as a function of the field points and in descending order. Note: the indicated name does not always have to be a data structure. ---See: syntax Syntax of a program. Now, the general structure of a program is shown in the language. To see the corresponding syntactic definition, click on the section of your interest with the mouse. All the programs must respect the previous structure with an exception: it is possible to put explanatory comments in any point of the program. ---See: Index - Glossary Definition of a name. A name is a sequence of alphanumeric characters used to identify an object of the program, such as the name of a process, constant or variable. These names can be made up of the following characters: Symbols: _ # \u00aa \u00ba $ \u20a7 \u0192 \u00a3 \u00a5 \u00a2 Digits: 0123456789 Letters: abcdefghijklmnopqrstuvwxyz Letters (extended): \u00f1 \u00e7 \u00e6 \u00e2\u00e4\u00e0\u00e5\u00e1 \u00ea\u00eb\u00e8\u00e9 \u00ee\u00ef\u00ec\u00ed \u00f4\u00f6\u00f2\u00f3 \u00fb\u00fc\u00f9\u00fa \u00ff provided that the following rules to create new names are respected: The sequence of characters must not contain characters that are not in the previous list (except capital letters corresponding to lower case letters included in the list). Inside the sequence, it is not possible to put blanks. That is to say, enemy spacecraft is not a valid name as, for the compiler, it would imply two names. In this case, the name can be declared as enemy_spacecraft . A name can not start with a numeric digit. That is to say, 0a is not a valid name. Nevertheless, all the necessary digits can be included in the name after the first character ( a0 is indeed a valid name). The name must not coincide either with any of the language's reserved words or with any of the objects (constants, variables, etc.) predefined in the language. To check it, see the list of reserved words and predefined objects, being possible to access the Glossary at any moment. The reserved words appear in capital letters and the predefined objects in lower case letters. There is no difference between the capital and lower case letters (for the compiler, ABc and abC are the same name). The same name can not be used for two different objects. For instance, it is not possible to name a constant value and then, to declare a process PROCESS value(x, y); . ---See: Syntax - Glossary Definition of comments. A comment is an explanatory note about the program. The comments are not necessary for the program's correct working. There are two kinds of comments: Of a single line: they start with the symbol // and finish at the end of the line in which they are defined. Of several lines: they start with the symbol / and finish with the symbol / . Example: / This is an example of a comment of several lines in which explanations about the program can be given / PROGRAM my_game; // Example of a single line comment. BEGIN // The main program starts. FRAME; END // The main program finishes. - All the texts included in a comment are ignored by the compiler. As many comments as necessary can be put, in any point of the program. The comments starting with / and finishing with /** (comments of several lines) can also start and finish in the same line. ---See: Syntax Program's head. PROGRAM ; All the programs must start with the reserved word PROGRAM followed by the name of the program and a symbol ; (semicolon) . This head is obligatory in all the programs. Before it, only one or several comments (explanatory texts preceded by the symbol // , or between the symbols / and /**) can optionally appear. In the names and reserved words there is no difference between capital and lower case letters, so PROGRAM , program , Program , ... are valid words. Example: // ------------------- // Listing of my game // ------------------- PROGRAM name_of_my_game; BEGIN //... END - ---See: Syntax Declaration of constants. CONST = ; ... This section of the programs is optional, as its utility deals with setting a series of synonymous for some numeric values. In a game, for instance, number 3 has been set in one or several points of the program as the maximum lives of the protagonist. If the aim is to modify this number, increasing or decreasing it, it will be necessary to look for this number and to replace it in the program. But there is a risk of replacing other '3' numbers appearing in the program with different aims. An alternative is to declare a constant called, for instance, maximum_lives as a synonymous of the numeric value 3 and use that constant in the program instead of the number. Now, if the aim is to replace this value by another one, it is done simply in the declaration of the constant maximum_lives . This section then establishes a list of names that are going to represent a series of numeric constants. This section must obligatory start with the reserved word CONST and then, for every declared constant, its name followed by the symbol = (assignment symbol) and a constant expression (numeric value) must appear. After the declaration of every constant, the symbol ; (semicolon) must appear. Example: PROGRAM my_game; CONST maximum_lives=3; BEGIN //... END - Once a value has been assigned to a constant, it won't later be possible to modify the former in the program. ---See: Syntax - Glossary Definition of a constant. A constant is a constant value or a numeric expression. As values, only integers within the range ( min_int ... max_int ) can be used. The constant numeric expressions are mathematical formulas in which it is possible to use: Constants previously defined. Numeric values . Arithmetic or logical operators . Literals (texts in inverted commas). The sizeof() function. These expressions will be evaluated when the program is compiled and their result will be used in the program's execution. The operators that can be used in a constant expression are the following ones (the synonymous of the operator, if they exist, are shown in brackets). + Addition - Subtraction (or negative sign) * Multiplication / Division MOD Module ( % ) << Rotation to the right >> Rotation to the left NOT Binary and logical negation ( ! ) AND AND binary and logical ( & , && ) OR OR binary and logical ( | , || ) XOR Exclusive OR ( ^ , ^^ ) == Comparison <> Different ( != ) > Greater than >= Bigger or equal ( => ) < Less <= Less or equal ( =< ) OFFSET Direction or offset ( & ) ( ) Brackets Now, some examples of valid constants are shown: ** 0** ** -1000** ** 2+2** ** \"Hello!\"** ** 4 (2+1) * ... ---See: Syntax - Glossary Declaration of global data. GLOBAL ; ... This section of the programs is optional. Global data, the data that can be used from any point of the program , are declared in this section. A section must obligatory start with the reserved word GLOBAL followed by a series of declarations of data finished with a symbol ; (semicolon). In general, all those data that establish general conditions of the game related to several processes are declared as global data. An example could be the score obtained by the player, that could be stored in the score global variable. Thus, any process of the game could increment it, if necessary. A declaration of global data will define a single data that can be used for all the program's processes. But, a declaration of local data will define a variable of this kind and name for each of the program's processes. Example: PROGRAM my_game; GLOBAL score=0; BEGIN //... END - ---See: Syntax - Glossary Declaration of local data. LOCAL ; ... This section of the programs is optional, as local data, the data that all the program's processes have are declared here, each one with its own values (as the x and y predefined local variables determine the coordinates of all the processes). A section must obligatory start with the reserved word LOCAL followed by a series of declarations of data finished with a symbol ; (semicolon). In general, the important information of the processes, the data to be consulted or modified from other processes, are declared as local data. The energy remaining a process (a spacecraft, a shotgun, the character, etc.) could be an example. This information could be stored in the energy local variable, so any process can access or modify the energy of the rest (for instance, on colliding with them, energy could be subtracted). Example: PROGRAM my_game; LOCAL energy=0; BEGIN //... END - If a variable declared as local is to be used only inside one process, then the former can be defined as a private data (inside the section PRIVATE of that process). ---See: Syntax - Glossary Declaration of private data. PRIVATE ; ... These sections of the programs are optional. Private data, data that are going to be used exclusively inside a process , can be declared in this section. This section is defined just before the BEGIN of the process that is going to use these data and must start with the reserved word PRIVATE followed by a series of declarations of data finished with a symbol ; (semicolon). The main program is also considered as a process. Its declaration of private data can go just before its BEGIN . In general, all the data that are going to contain information necessary only for a process, as well as those that can not be accessed from any other process, are declared as private data. Those variables that are going to be used as counters in a loop, variables to contain angles or secondary identifying codes, etc. are normally defined as private data. Example: PROGRAM my_game; PRIVATE n; BEGIN FROM n=0 TO 9; //... END //... END PROCESS my_process() PRIVATE id2; angle2; BEGIN id2=get_id(TYPE my_process); IF (id2<>0) angle2=id2.angle; //... END //... END - If you need to consult or modify a variable declared as private from another process (variable.identifier), then that data will have to be declared local (inside the program's section LOCAL ). Thus, all the processes will have the data and every process can access its value or the value that this data has in another process. ---See: Syntax - Glossary Declaration of a variable. In a declaration of a variable, three different kinds of objects can be shown: In general, a variable will store a simple numeric value. A table will store a list of numeric values. And a structure will store a list of records of several fields (such as a list of index cards with varied information). All the data will be declared with a name which, from that moment, will become the means to access or modify the information contained in those data. Each data will belong to a specific area, depending on the fact that its declaration has been made inside the GLOBAL , LOCAL or PRIVATE .. sections. It is possible to access all the global data from any point of the program. Local data belong to all the processes (every process has its own value in them). Finally, private data belong to a single specific process. ---See: Syntax Declaration of a variable. (or, if the aim is to initialise) = To declare a variable inside a GLOBAL , LOCAL or PRIVATE section, suffice will be to indicate its name inside that section. In this case, the variable will be initialised at 0 (zero). To initialise the variable at other values, the symbol = (assignment) will be put after the name of the variable. The constant value at which the variable is intended to be initialised will be put after this symbol. A variable is a cell (or position) of the computer's memory to which we refer by its name and that can contain whole numeric values within the range ( min_int ... max_int ). ---See: Syntax - Glossary Declaration of a table. [] (or, if the aim is to initialise the table) [] = (or, if it is initialised without defining its length) [] = To declare a table inside a GLOBAL , LOCAL or PRIVATE section, suffice will be to indicate its name followed by the length of the table in square brackets (symbols [] ). In that case, all the positions of the table will be initialised at 0 (zero). The table's length is expressed as the maximum value of its index. That is to say, all the tables range from the position 0 to the position indicated in the square brackets in their declaration. For instance, a table declared as my_table[9] , will be a table of length 10 (of 10 positions, from my_table[0] to my_table[9]). If the aim is to initialise the different positions of the table, it is necessary to put the symbol = (assignment) after the previous declaration and, after this symbol, a list of constants . If the table is initialised with a list, then it is not necessary to indicate the table's length in square brackets, as the compiler will create a table with as many positions as the number of values included in the list. A table is a series of cells (or positions) of the computer's memory that is called by its name, appearing after it, in square brackets, the number of cell inside the table intended to be accessed. Every table's cell is a variable that can contain whole numeric values within the range ( min_int ... max_int ). For instance, if we declare a table as the following one: my_table[]=33, -1, 6, -3, 99; We will be declaring a table whose name is my_table and that has 5 cells (or positions), from cell no. 0 to cell no. 4. In the previous declaration, cell 0 ( my_table[0] ) is initialised with the value 33 , cell 1 ( my_table[1] ) with the value -1 , etc. The language allows us to access cell 0 simply with the name of the table ( my_table ), as if it was a variable, omitting the zero in square brackets that should appear after. That is to say, for the compiler, my_table[0] will be the same as my_table (the first cell of the table). ---See: Syntax - Glossary Declaration of a structure. STRUCT [] ; ... END (or, if you initialise the structure) STRUCT [] ; ... END = To declare a structure inside a GLOBAL , LOCAL or PRIVATE section, it is necessary to put the reserved word STRUCT preceding its name. After it, the number of records of the structure must be indicated, in square brackets (symbols [ ] ). After this head defining the name of the structure and the number of records, all the data that belong to the structure and that will comprise its fields, will be declared. Finally, the reserved word END must appear to finish the declaration. The records' number of the structure is expressed as the maximum records' number of the structure. That is to say, all the structures have from record 0 to the record indicated in the square brackets. For instance, a structure declared as STRUCT my_structure[9] , will be a structure of 10 records (from the record my_structure[0] to my_structure[9]). A structure is like an index card file (records), each of them with different written information (fields). For instance, a structure in which we could include the initial and final positions of a series of processes of a game could be as follows (an index card file with 10 cards, each of them indicating the (x, y) initial and the (x, y) final of a process): STRUCT movement_enemies[9] x_initial; y_initial; x_final; y_final; END This structure, that would be accessed with the name movement_enemies , has ten records and four fields in each record (two coordinates that determine the initial position of the process [x_initial ,y_final], and two that determine the final position [x_final, y_final]). Movement_enemy[0].x_final would be used to access the x final of the first enemy. The language allows us to access the record 0 of the structure simply with the name of the structure ( movement_enemies.x_final ), omitting the zero in square brackets that should come later. That is to say, for the compiler movement_enemies[0].x_final will be the same as movement_enemies.x_final . Each field of the structure may be a variable, a table or another complete structure, with its different records and fields. If the aim is to initialise the structure (establishing the initial values of its fields in the different records), the symbol = (assignment) must be put after the reserved word END followed by a list of constants . If the structure is not initialised in this way, all the fields will be put at 0 by default. Keep in mind that , in order to initialise a structure, the first values will be the values of the fields of the first record, the following ones those of the second record, and so on. For instance, if the following declaration is made: STRUCT a[2] b; c[1]; END = 1, 2, 3, 4, 5, 6, 7, 8, 9; First, it must be taken into account that the structure a has 3 records (from a[0] to a[2]) and that there are three fields (b, c[0] & c[1]) in each record. Then, the previous declaration will initialise the structure in the following way: a[0].b=1; a[0].c[0]=2; a[0].c[1]=3; a[1].b=4; a[1].c[0]=5; ... ---See: Syntax - Glossary Definition of a list of constants. A constant is a constant value or numeric expression (see ). The lists of constants are basically a series of constants separated by commas (,) and they are used to initialise the values of tables or structures. An example of a list of constants is shown below: 1, 2, 3, 4, 5; But, besides this basic definition, the use of the operator DUP is allowed to repeat a series of constants a specific number of times. For instance, the following list: 0, 100 DUP (1, 2, 3), 0; It is a list of 302 constants (0, 1, 2, 3, 1, 2, 3, ..., 1, 2, 3, 0). That is to say, that the operator DUP (duplication) allows us to repeat the sequence appearing after it in brackets, the indicated number of times. It is possible to nest operations DUP . For instance, the following list: 2 DUP (88, 3 DUP (0, 1), 99); would be equivalent to: 88, 0, 1, 0, 1, 0, 1, 99, 88, 0, 1, 0, 1, 0, 1, 99; Moreover, the omission of the operator DUP , that 2 DUP (0, 1) is equivalent to 2(0, 1) , is allowed. The operator DUP is specially useful to initialise structures. If, for instance, the aim is to initialise the following 100 record structure: STRUCT a[99] b; c[9]; d[9]; END With the fields b initialised at 0 , the fields c[9] at 1 and the fields d[9] at 2 , the following list of initialisation would be used: 100 DUP (0, 10 DUP(1), 10 DUP(2)); ---See: Syntax Declaration of libraries. IMPORT The creation of libraries of functions for the language is a very advanced issue, only for programmers with broad experience in the C language and/or Assembler . The libraries must be distributed with two files: the first one, with extension DLL , containing the own library and, the second one, with the same name but with extension TXT , that must be a text file ascii (MS-DOS), explaining the purpose and working of the library. All the provided functions, the installation process and the use of the library must be explained in the second file. The libraries must be imported from the language, by inputting the reserved word IMPORT (after the declaration of local and global data) followed by the path of the file DLL . If the file with extension DLL has been copied in the directory of DIV Games Studio , then it is not necessary to specify the library's path. Example: PROGRAM my_game; IMPORT \"hboy.dll\"; BEGIN //... END - From the moment when the libraries of functions can freely be developed, {the correct working of DIV Games Studio is not guaranteed if external libraries DLL are used}. The incorrect working of the programs' debugger can be usual when a DLL which modifies vital parts of the library of functions or of the processes' manager of DIV Games Studio is stored in a game. Note 1: In the first version of the DIV programming language, this declaration had to be done between the LOCAL and PRIVATE sections of the program. Note 2: The libraries prepared for the first version of the language {will not function correctly} in later versions, you must first re-compile these libraries with the new declarations. In other words, the font code of the libraries will still be valid, but they must be re-compiled with new the headline files (because they contain the declarations for the new data and structures which exist in the language). Note 3: If you are a programming expert in C and Assembler, you can get more information about the creation of new libraries in the file DLL\\SOURCE\\Readme.TXT on the DIV CD. ---See: Syntax Main code. BEGIN ; ... END The main code of a program starts with the reserved word BEGIN . After it, any number of statements may appear. The main code finishes with the reserved word END . This code controls the main process of the program, which initialises the program, controls the loops of the menu and game, and finishes the program. Example: PROGRAM my_game; GLOBAL option; // Option chosen in the menu. BEGIN // Beginning of the main code. set_mode(m640x480); // Beginning. set_fps(24, 4); // ... // Loads files, sounds, etc. REPEAT // Beginning main loop. option=0; // Control loop of the options menu. //... // Begins the options menu. REPEAT // ... IF (key(_enter)) option=1; END // Playing is chosen. IF (key(_esc)) option=2; END // Finishing is chosen. FRAME; UNTIL (option>0); IF (option==1) // If the playing option has been chosen. // Starts regions, scroll, etc. // Creates the game processes. // Loop of game's control, expecting for its end. END UNTIL (option==2); // End of the main loop. let_me_alone(); // Finishes all the processes. END // End of the main code. // ... // Declaration of the program's processes. - The end of the main code's execution does not imply the end of the program's execution, as it will continue if there are alive processes. To force the end of the program when the code finishes, it is possible to use, for instance, the let_me_alone() function just before the END that marks the main code's end, to eliminate the rest of processes that may remain alive. The execution of the program can also be finished at any of its points with the exit() function, which will automatically eliminate all the processes. ---See: Syntax Declaration of processes. Two types of code blocks exist (besides the main code ): the PROCESS blocks (which will be detailed below), and the FUNCTION blocks. PROCESS ( ) BEGIN ; ... END A process must start with the reserved word PROCESS followed by its name and its call parameters in brackets. The parameters are a list of data in which the process is going to receive different values. The brackets are obligatory even if the process has no parameters. After this header, a PRIVATE section, declaring data to be used by the process exclusively, may be put optionally. And finally, the process code, that is a sequence of statements between the reserved words BEGIN and END , will be specified. A process normally corresponds with a kind of object of the game, such as a spacecraft, an explosion, a shot, etc. Inside the process' code, a loop (in which all the necessary values to display this object, such as graphic, coordinates, etc., will be established) is normally implemented. Then, with the FRAME statement, the order to display the object with the established attributes is given. Example: PROGRAM my_game; PRIVATE id2; BEGIN load_fpg(\"help/help.fpg\"); id2=my_process(160, 100); write_int(0,150,10,4,offset id2); write(0,100,10,4,\"Process ID=\"); // ... END PROCESS my_process(x, y) PRIVATE n; BEGIN graph=100; FROM n=0 to 99; x=x+2; y=y+1; FRAME; END END - As it can be noticed in this example, when a process is called, it returns its identifying code (that, in the example, is stored in the PRIVATE variable of the main program id2 ). If the aim is to implement a process in the style of the functions of other languages that returns a numeric result, then it is necessary to use the RETURN( ** statement, not using the FRAME statement inside the process, as this statement returns to the father process (caller), returning the process' identifying code as return value. ---See: Syntax - The blocks FUNCTION Declaration of statements. A statement is an order to be executed by the computer in a program. The possible types of statements are the following ones: Assignment statements = Control statements IF SWITCH Loop statements LOOP FROM REPEAT WHILE FOR Break statements BREAK CONTINUE RETURN Special statements FRAME CLONE DEBUG Call statements Call to a process The statements always appear as a group of statements, from none (which makes no sense) to as many as necessary. All the statements will sequentially be executed (the first one, the second one, the third one ...), with the exception of the statements that can control the flow of the program (control, loop and break statements). ---See: Syntax Parameters of a process. The parameters of a process are basically a list of data in which the process will receive different information every time it is called or used from another process. The processes can receive parameters in the following types of data: A predefined local variable (such as x , size , flags , ...). A local variable defined inside the LOCAL section. A global variable defined inside the GLOBAL section. A process' private variable declared inside the PRIVATE section of the process itself. A private variable not declared inside the PRIVATE section. In all these cases, it is understood that a variable may be referred to a variable, to a specific position of a table or to an element inside a structure. As an example of the different types of parameters, a program with a process that receives five parameters different from the types respectively indicated in the previous list, is now shown. Example: PROGRAM my_game; GLOBAL score=0; LOCAL energy=0; BEGIN my_process(1, 2, 3, 4, 5); // ... END PROCESS my_process(x, energy, score, n, m) PRIVATE n; BEGIN // ... END - The process my_process receives five parameters in five variables: predefined local, local, global, private declared and private not declared variables. Receiving a parameter (such as the GLOBAL score variable) in a global data is equivalent to make the assignment ( score=3; ) and then, call the process. ---See: Syntax Assignment statement. The assignment statements are used to calculate expressions and to assign them to a variable. = ; The data in which the result of the expression is going to be stored must be indicated, followed by the symbol = (symbol of the assignment ), as well as the numeric or logical expression to evaluate when the statement is executed. After this statement, the symbol ;(semicolon) must always be put. In an assignment statement it is only allowed to assign values to objects such as any kind of variables, to a position of a table , or to an element of a structure . It is not possible to assign a value to a constant , to a function or to a process or, in general, to any numeric or logical expression . Now, a program with several assignments is shown. Example: PROGRAM my_game; BEGIN x=x+1; angle=(angle 3)/2-pi/2; size=(x+y)/2; z=abs(x-y) 3-pow(x, 2); // ... END - This is the basic form of the assignments, even if there are other symbols of assignment that, instead of assigning a new value to the referred variable, modify its value. These are the symbols of operative assignments : += Adds to the variable the result of the expression x=2; x+=2; -> (x==4) -= Subtracts from the variable the result of the expression x=4; x-=2; -> (x==2) *= Multiplies the variable by the result of the expression x=2; x*=3; -> (x==6) /= Divides the variable by the result of the expression x=8; x/=2; -> (x==4) %= Puts in the variable the remainder of dividing it by the result of the expression x=3; x%=2; -> (x==1) &= Performs an AND (binary and/or logical) between the variable and the result of the expression, assigning it as a new variable's value x=5; x&=6; -> (x==4) |= Performs an OR (binary and/or logical) between the variable and the result of the expression, assigning it as a new variable's value x=5; x|=6; -> (x==7) ^= Performs an exclusive OR (XOR binary and/or logical) between the data and the result of the expression, assigning it as a new variable's value x=5; x^=3; -> (x==3) >>= Rotates the variable to the right as many times as indicated by the result of the expression (each rotation to the right is equivalent to dividing the variable by 2) x=8; x>>=2; -> (x==2) <<= Rotates the variable to the left as many times as indicated by the result of the expression (each rotation to the left is equivalent to multiplying the variable by 2) x=2; x<<=2; -> (x==8) Within the category of assignment statements, the increments and decrements of a variable are also allowed. For instance, if we wanted to add 1 to the local variable x we could do it either with the x=x+1; or x+=1; statements, or with the operator of increment: x++; o ++x; . That is to say, increments ( ++ ) or decrements ( -- ) of a variable are accepted as assignment statements. ---See: Syntax IF statements IF ( ](#)) ; ... END (or) IF ( ](#)) ; ... ELSE ; ... END The IF statement is used to run a block of statements optionally, when a condition is complied. In the second aforementioned variant, another block of statements will also be executed (inside the ELSE section) when the condition is not complied. A program with several IF statements is now shown. Example: PROGRAM my_game; BEGIN IF (key(_esc)) exit(\"Good by!\", 0); END IF (x>100 AND x<220) y=y+4; ELSE y=y-8; END IF (size>0) size=size-1; END IF (timer[5]>1000) z=1; ELSE z=-1; END // ... END - It is possible to nest IF statements with no limits. That is to say, more IF statements can be put inside the part that is running when the condition is complied ( IF part ) or inside the one that is executed when the condition is not complied (part ELSE ). ---See: Syntax SWITCH statement SWITCH ( ](#)) CASE : ; ... END ... DEFAULT : ; ... END END A SWITCH statement is made up with a series of CASE sections and, optionally, of a DEFAULT section. When a SWITCH statement is executed, the expression is first evaluated and then, if the result is within the range of values included in the first CASE section, its statements will be executed and the statement will finish. If the result of the expression is not in the first CASE , it will be looked for in the second, third, etc. CASE . Finally, if there is a DEFAULT section and the result of the expression has not coincided with any of the CASE sections, then the statements of the DEFAULT section will be executed. Example: PROGRAM my_game; BEGIN SWITCH (x) CASE 1: x=-1; END CASE 2: x=-2; END CASE 3: x=-3; END CASE 99: x=-99; END DEFAULT: x=0; END END END - The SWITCH statement of this program will change the sign of the x variable if it is equal to 1 , 2 , 3 or 99 . Otherwise, the statement will put the variable at 0 . Range of values of a case section --- A value, a range of values (minimum .. maximum), or a list of values and/or ranges separated by commas (,) may be specified in a case section. For instance, the previous statement could have been expressed as follows: SWITCH (x) CASE 1..3, 99: x=-x; END DEFAULT: x=0; END END Once one of the CASE sections of a SWITCH statement has been executed no more sections will be executed , even if they also specify the result of the expression, for instance, in the following statement: SWITCH (2+2) CASE 3..5: x=x+1; END CASE 2, 4, 6: y=y-1; END END The x=x+1; section will be executed and then, the statement will finish and the y=y-1; section won't be executed as, even if the result of the evaluated expression ( 4 ) is included in it, it is also included in the previous section, (as 4 is within the range 3..5). It is not necessary to arrange the CASE sections according to their values (smaller to larger, or larger to smaller), but it is indispensable that the DEFAULT section (if it exits) is the last section. There can only be one DEFAULT section. It is possible to nest SWITCH statements with no limits. That is to say, new SWITCH statements (and any other kind of statement) can be put inside a CASE section. ---See: Syntax WHILE statement WHILE ( ](#)) ; ... END The WHILE statement implements a loop . That is to say, it is capable of {repeating a group of statements a specific number of times}. In order to implement this loop, the condition that has to be complied for the group of statements to be executed must be specified in brackets, after the reserved word WHILE . All the statements that necessarily have to be repeated will be put after the specification of this condition. Finally, the end of the loop will be marked with the reserved word END (It doesn't matter whether more words END appear inside the loop when they belong to internal statements of that loop). When a WHILE statement is executed, the specified verification will be carried out. If the result is true, the internal statements will be executed. Otherwise, the program will continue from the END , that marks the end of the WHILE . If the internal statements have been executed (what is called to make a loop's iteration ), the condition will be verified again. If it is true, another iteration will be made (the internal statements will be executed again). This process will be repeated until it is verified that the condition of the WHILE is false. If the condition turns to be false directly while a WHILE statement is executed, then the internal statements will never be executed. Example: PROGRAM my_game; BEGIN x=0; WHILE (x<320) x=x+10; FRAME; END END - In this example, the x local variable ( x coordinate of the process) will be put at zero and then, providing that x is less than 320, 10 will be added to x and a FRAME will be performed. A BREAK statement inside a WHILE loop will immediately finish it, continuing the program from the following statement to that loop. A CONTINUE statement inside a WHILE loop will force the program to verify the initial condition immediately and, if it is true, to execute again the internal statements from the beginning (after the WHILE ). If the condition turns to be false, the CONTINUE statement will finish the loop. The internal statements of a WHILE loop can be as many as desired, and of any kind, obviously including new WHILE loops. ---See: Syntax REPEAT statement REPEAT ; ... UNTIL ( ](#)) The REPEAT (REPEAT ... UNTIL( ... )) statement implements a loop . That is to say, it is capable of repeating a group of statements a specific number of times . In order to implement this loop, it is necessary to start with the reserved word REPEAT , followed by the statements that you want to repeat once or more times, and the end of the statement will be determined by putting the reserved word UNTIL , followed by the condition that has to be complied for the statement to finish . When a REPEAT statement is executed, the internal statements (those placed between the REPEAT and the UNTIL ) will be executed first and then, the condition specified in the UNTIL will be verified. If it is still false, the internal statements will be executed again. The process will be repeated until the condition of the UNTIL turns to be true, continuing then the execution of the program after this statement. Every time that the internal statements are executed, a loop's iteration has been made. The REPEAT ... UNTIL (the is complied) statement will always execute the internal statements at least once, so it always verifies the condition after the execution. Example: PROGRAM my_game; BEGIN x=0; REPEAT x=x+10; FRAME; UNTIL (x>320) END - In this example, the x local variable (x coordinate of the process) will be put at zero and then, 10 will be added to x and a FRAME will be performed until x becomes a number bigger than 320. A BREAK statement inside a REPEAT loop will immediately finish it, continuing the program from the following statement to that loop. A CONTINUE statement inside a REPEAT loop will force the program to immediately make the verification of the UNTIL and, if it is true, it will execute again the internal statements from the beginning (after the reserved word REPEAT ). If the condition turns to be true, the CONTINUE statement will finish the loop. The internal statements of a REPEAT ** loop can be as many as desired, and of any kind, obviously including new REPEAT** loops. ---See: Syntax LOOP statement LOOP ; ... END The LOOP statement implements an infinite loop . That is to say, it indefinitely repeats a group of statements . In order to implement this loop, it is necessary to start with the reserved word LOOP , followed by the statements intended to be repeated continuously, putting the reserved word END at the end. When a LOOP ... END statement is found in a program, all the internal statements of that loop will repeatedly be executed from this position. In order to finish a LOOP loop, it is possible to use the BREAK statement which, on being executed inside a loop of this kind, will force the program to continue from the END . Every time that the internal statements are executed, a loop's iteration has been made. The CONTINUE statement inside a loop will finish the current iteration and will start the following one (the program will go on running after the reserved word LOOP . Example: PROGRAM my_game; BEGIN x=0; LOOP IF (key(_esc)) BREAK; END x=x+1; FRAME; END END - In this example, the x local variable (x coordinate of the process) will be put at zero and then, 1 will be added to x and a FRAME will continuously be done. If the escape key ( ESC ) is pressed, then the BREAK statement will be executed, finishing the LOOP loop. The internal statements of a LOOP loop can be as many as desired, and of any kind, obviously including new LOOP loops. ---See: Syntax FOR statement FOR ( ](#)) ; ... END The FOR statement (replica of the C language) implements a loop and is capable of {repeating a group of statements a specific number of times}. In order to implement this loop, three different parts must be specified in brackets, separated by symbols ; (semicolon) after the reserved word FOR . These three parts, that are optional (they can be omitted), are the following ones: Initialisation . An assignment statement is normally codified in this part. This kind of statement establishes the initial value of the variable that is going to be used as a counter of the loop's iterations (each execution of the inner group of statements is called a loop's iteration ). The assignment statement x=0 , that would put the x variable at zero at the beginning of the loop (value for the first iteration), is an example. Condition . A condition is specified in this part. Just before each iteration, this condition will be checked and, if it is true, the group of statements will be executed. If the condition is false, the FOR loop will finish, continuing the program after the END of the FOR loop. An example of condition can be x<10 , that would allow the inner group of statements to be executed only when the x variable is a number less than 10 . Increment . The increment of the variable used as a counter for each iteration of the loop is indicated in the third part. It is normally expressed with an assignment statement. For instance, the x=x+1 statement would add 1 to the x variable after each iteration of the loop. The group of inner statements of the loop that are going to sequentially be repeated while the condition of continuance (second part) is complied, must appear after the definition of the FOR loop with its three parts. After this group of statements, the reserved word END will determine the end of the FOR loop. When a FOR statement appears in a program, the part of the initialisation will be executed first, checking the condition. If it is true, the inner group of statements first and, the part of the increment then, will be executed, being the condition checked again, etc. If, before any iteration, the condition turns to be false, the FOR loop will immediately finish. A program with a FOR loop containing the three parts mentioned in the previous sections is now shown. Example: PROGRAM my_game; BEGIN FOR ( x=0 ; x<10 ; x=x+1 ) // The internal statements would be put here. END END - This loop would first run with the x variable equal to 0 , the second one equal to 1 , ..., and the last variable equal to 9 . The part of the increment would be executed after this iteration, becoming x equal to 10 . Then, on checking the condition of continuance in the loop ( x is less than 10 ), if it is false, the loop would finish. As it has been mentioned, the three parts in the definition of the loop are optional. If the three were omitted: FOR ( ; ; ) // ... END Then, this loop would be equivalent to a LOOP ... END loop. Moreover, several parts of initialisation, condition or increment can be put in a FOR loop, separated by commas ( , ). At first, all the initialisations will be executed. Then, all the conditions of continuance will be checked (if any of them turns to be false, the loop will finish). The inner statements and, after every iteration, all the increments, will finally be checked. Example: PROGRAM my_game; BEGIN FOR ( x=0, y=1000 ; x<y ; x=x+2, y=y+1 ) // The internal statements would be put here. END END - A BREAK statement inside a FOR loop will immediately finish it, continuing the program from the following statement of this loop. A CONTINUE statement inside a FOR loop will force to execute the part of the increment directly and then, to verify the condition of continuance. If it is true, then the inner statements will be executed again from the beginning. If the condition turns to be false, then the CONTINUE statement will finish the FOR loop. A FOR loop is practically equivalent to a WHILE loop, implemented in the following way: Example: PROGRAM my_game; BEGIN x=0; WHILE (x<10) // The internal statements would be put here. x=x+1; END END - With the only exception that a CONTINUE statement, inside this WHILE loop, would not execute the part of the increment, while it would do so inside a FOR loop. If, after the execution of the initialisation, the condition turns to be false directly inside a FOR loop, no inner statements will ever be executed. The internal statements of a FOR loop can be as many as desired, and of any kind, obviously including new **FOR ** loops. ---See: Syntax BREAK statement A BREAK statement inside a loop will immediately finish it, continuing the program from the following statement to that loop. This statement can only be put inside the following loops: LOOP ... END FROM .. TO .. STEP .. ... END REPEAT ... UNTIL ( ](#)) WHILE ( ](#)) ... END FOR ( ](#)) ... END A BREAK sentence will make the program continue its execution after the END or the UNTIL of the loop closer to the statement. If there are several nested loops (one inside another one), the BREAK statement will only exit the inner loop. Example: PROGRAM my_game; BEGIN LOOP REPEAT IF (key(_esc)) BREAK; END //... FRAME; UNTIL (x==0); //... END END - In this example, the BREAK statement will exit the REPEAT ... UNTIL (when the ESC key is pressed), but not the LOOP ... END . Important --- The BREAK statement is not valid to finish IF , SWITCH (or the CASE sections of this statement), or CLONE statements. BREAK can only finish the statements that implement a loop. ---See: Syntax CONTINUE statement A CONTINUE statement inside a loop will force the program to finish its current iteration and start the following iteration. We call iteration to each execution of the set of statements internal to a loop (the statements between a LOOP and its END , for instance). This statement can only be put inside one of the following loops: LOOP ... END A CONTINUE inside this loop will jump to the LOOP. FROM .. TO .. STEP .. ... END A CONTINUE inside this loop will perform the increment (STEP) and, if the value indicated in the TO has not been passed, the program will continue at the beginning of the loop. REPEAT ... UNTIL ( ](#)) A CONTINUE inside this loop will jump to the UNTIL. WHILE ( ](#)) ... END A CONTINUE inside this loop will jump to the WHILE. FOR ( ](#)) ... END A CONTINUE inside this loop will perform the increment and the comparison. If the latter is true, the program will continue at the beginning of the loop. But if it is false, the program will continue after the END of the FOR. If there are several nested loops (one inside another), the CONTINUE statement will take effect only in the inner loop. Example: PROGRAM my_game; BEGIN FOR (x=0, y=0;x<10;x++) IF (x<5) CONTINUE; END y++; END END - In this example, after the whole loop has been executed, x will be equal to 10 and y will be equal to 5 as, providing that x is less than 5, the CONTINUE statement prevents the y++; statement from being executed. Important --- The CONTINUE statement is not valid inside IF , SWITCH (or the CASE sections of this statement), or CLONE statements (as these statements do not implement loops and, therefore, they do not make iterations). ---See: Syntax RETURN statement The RETURN statement immediately finishes the current process, as if the END of its BEGIN was reached. When this statement is included in the main code, it will finish the current process. But if there are alive processes, they will go on running. For instance, the exit() function can be used to finish a program and all its processes. A RETURN inside a process will finish it, killing this process. Example: PROGRAM my_game; BEGIN LOOP IF (key(_esc)) RETURN; END FRAME; END END - In this example, the RETURN statement will be executed by pressing the escape key ( ESC ), finishing the program. Use of RETURN to return a value --- It is possible to design processes with a performance similar to the functions of other programming languages, that {receive a series of parameters and return a value}. For instance, a process receiving two numeric values and returning the biggest one. For that, this statement must be used with the following syntax: RETURN( ) It is also important not to use the FRAME statement inside the process, as this statement will immediately return to the calling process. When the compiler finds the FRAME statement inside a PROCESS , it directly classes it as a process, ruling out its hypothetical use as a function. Important: To return a value with the RETURN statement after execution of one or more FRAME statements , you must make a block of this type, ie. a FUNCTION . The example proposed before is shown now: an implementation of the mathematical function max that returns the greater of its two parameters. Example: PROGRAM my_game; BEGIN x=max(2, 3)+max(5, 4); END PROCESS max(a, b) BEGIN IF (a>b) RETURN(a); ELSE RETURN(b); END END - After the execution of this program, the x variable of the main process will be equal to 8 (3+5). Important --- By default, if the RETURN statement is used without the expression in brackets or the FRAME statement is used in a process, its return value will be its identifying code of the process}. ---See: Syntax FRAME statement The FRAME statement is an essential part of the language. A program's working is described below in general terms: The main program starts its execution. This process may create more processes (objects of the game) at any point. All the processes may finish at any moment, and they may create or eliminate other processes. The games will always be displayed frame by frame. In each frame, the system will execute all the processes existing at that moment, one by one, until each one executes the FRAME statement, which will indicate that it is ready for the next display (frame). In the preparation of each frame, all the processes will be executed in the established priority order (the priority local variable of the processes determines this order). Therefore, this statement is similar to an order for the processes to be displayed. If a process starts its execution and it neither finishes nor executes this statement, then the program will become blocked, as there is a process that is never ready for the next display. Therefore, the system won't be capable of showing the following frame. Example: PROGRAM my_game; BEGIN my_process(); my_process(); LOOP IF (key(_esc)) my_second_process(); END FRAME; END END PROCESS my_process() BEGIN LOOP FRAME; END END PROCESS my_second_process() BEGIN LOOP END END - In this program, the main process (a my_game type process) creates other two processes ( my_process type). From that moment, the three processes will continuously be executed, each one to their FRAME statement. But if the escape key ( ESC ) is pressed, then the main process will create a new process ( my_second_process type) that will remain in a LOOP loop indefinitely, without executing any FRAME . Consequently, the program will be interrupted (the system will report such a situation after few seconds; see max_process_time ). Basically, all the processes that correspond with objects of a game construct a loop inside which, every frame establishes all its display values ( x , y , graph , size , angle , ...), executing then the FRAME statement. Synchronisation of processes --- It is possible to use this statement with the following syntax: FRAME( ) By putting in brackets a whole percentage, from 0 to 100 or bigger, after the reserved word FRAME . This figure will indicate the percentage of the following frame, completed by the process. That is to say, the absence of this percentage is equivalent to putting FRAME(100) (100% of the work previous to the following display has been completed by the process). For instance, if a process executes the FRAME(25) statement in a loop, it will need to execute it 4 times before it is ready for the next display (as 4*25% is the 100%). On the other hand, if a process executes the FRAME(400) statement inside its loop, after its first execution, it will have completed 400% the display. Therefore,even after the display, a completed 300% of display will still be missing. For that, in the preparation of the following 3 frames the system won't execute this process, as it is ready for the display. Then, this process would be executed just once every 4 frames (unlike the example of the previous paragraph, in which it was executed 4 times every game's frame). The processes won't reach the next display unless they give 100%, at least . For instance, if a process always executes FRAME(80) statements, it will execute them twice before the first display, so it will have completed 160% (2 80%) the display. Therefore, it will have pre calculated 60% (160%-100%) for the next display. For that reason, in the second display it will only require a FRAME(80) * statement to be displayed, as this 80%, plus the remaining 60% of the first display, will be equal to a 140% completed. Therefore, it will immediately be displayed ,and a 40% will be left to prepare the next frame. A FRAME(0) statement completing a 0% of the next display only makes sense in the two following cases: It can be a way to force the system to execute in this point the rest of the processes having the same priority as the current one and, after them, the system will execute the latter again. It can also be a way to initialise functions such as get_id() or collision() , as they return some specific values for every frame. If the aim is to obtain values again, it is possible to execute a FRAME(0) statement that will be interpreted as a new frame by these functions. ---See: Syntax CLONE statement CLONE ; ... END This statement creates a new process identical to the current one, with the exception that the statement between the reserved words CLONE and END will only be executed in the new process, but not in the current one. For instance, if any process of the program, with specific coordinates ( x , y ) and with a specific graphic ( graph ), executes the following statement: CLONE x=x+100; END A new process will be created, identical to the former, with the same graphic and the same values in all its variables, with the exception of the x coordinate that, in the new process, will be placed 100 pixels farther to the right. This statement is used to create replicas of a process, dividing it into two processes (almost) similar. Example: PROGRAM my_game; BEGIN // ... x=0; y=0; CLONE x=x+10; END CLONE y=y+10; END // ... END - In this example, the 2 CLONE statements will create 3 copies of the main process (and not 2, as it could have been expected). On executing the first CLONE statement, a new process will be created. Thus, there will be 2 processes: one in (x=0, y=0) and the other in (x=10, y=0). These two processes will execute the second CLONE statement. The first one (the original one) will create a new process in (x=0, y=10), and the second one will create the new process in (x=10, y=10). To create only 2 copies of the original process, the program could have been constructed, for instance, in the following way: Example: PROGRAM my_game; BEGIN // ... x=0; y=0; CLONE x=x+10; CLONE y=y+10; END END // ... END - The original process (x=0, y=0) will create one in (x=10, y=0) and the latter will create another one in (x=10, y=10). Therefore, only two copies of the original will be created. Much care must be taken when it comes to using the CLONE statement sequentially or inside a loop , as it is necessary to take into account that the first ' clones ' may also create new ' clones '. This statement can be used without putting statements between the words CLONE and END . But, intending to have two identical processes with the same coordinates, the same graphic and executing the same code, seems to make little sense, at least at first. ---See: Syntax DEBUG statement The DEBUG statement will call the interactive debugger when it is executed. It is normally used to debug programs, to find possible errors of the programs. On some occasions, it is normally put in the following points. Where you want to verify that a part of the program has done what was expected. After the execution of that part, DEBUG will call the debugger, from which it is possible to check all the active processes and the value of all their variables. When you are not very sure whether something can happen in a program, you can put this statement in that point to report you whether what we are expecting actually happens. This statement is only used temporarily, until the error that is looked for is found. From that moment, the statement won't be necessary. Thus, it can be removed from the program since it has no additional effect. Example: PROGRAM my_game; BEGIN // ... IF (x<0) DEBUG; END // ... END - In this example, it is verified that, in a specific point of the program, the x coordinate of the process is not a negative number (less than zero). If this happens, the debugger will be called to find out why it has happened. When this statement is executed, a dialog box appears, offering us the following options: To disable the DEBUG statement, preventing it from being activated in this execution of the program. To stop the program and enter the debugger, to be able to examine all the processes and their variables. Or to finish the execution of the program immediately, returning to its edition in the windows' graphic environment. Moreover, if the escape key ESC is pressed in that box, the DEBUG statement will simply be ignored, and the program will continue to be executed as usual. When a program is executed from the windows' graphic environment, the debugger can be called at any moment by pressing the F12 key. On invoking the debugger in this way, the program will always be interrupted just before starting the processing of a new frame. All the processes to be executed will appear before the next display. ---See: Syntax List of functions of the language. Process interaction functions collision() get_angle() get_dist() get_distx() get_disty() get_id() let_me_alone() signal() Geometry functions advance() fget_angle() fget_dist() near_angle() xadvance() Path finding functions path_find() path_free() path_line() Mathematical functions abs() acos() asin() atan() atan2() cos() pow() sin() sqrt() tan() Random number functions rand() rand_seed() Graphics functions clear_screen() get_pixel() map_block_copy() map_get_pixel() map_put() map_put_pixel() map_xput() new_map() put() put_pixel() put_screen() screen_copy() xput() Primitive graphics drawing functions delete_draw() draw() move_draw() Audio system functions change_channel() change_sound() reset_sound() set_volume() Sound effect functions is_playing_sound() load_pcm() load_wav() sound() stop_sound() unload_pcm() unload_wav() CD music functions is_playing_cd() play_cd() stop_cd() Digital music functions get_song_line() get_song_pos() is_playing_song() load_song() set_song_pos() song() stop_song() unload_song() Input functions get_joy_button() get_joy_position() key() Palette control functions convert_palette() fade() fade_off() fade_on() find_color() force_pal() load_pal() roll_palette() set_color() Mode7 and scroll functions move_scroll() refresh_scroll() start_mode7() start_scroll() stop_mode7() stop_scroll() Mode 8 Functions (3D mode) get_point_m8() get_sector_height() get_sector_texture() get_wall_texture() go_to_flag() load_wld() set_env_color() set_fog() set_point_m8() set_sector_height() set_sector_texture() set_wall_texture() start_mode8() stop_mode8() Text display functions delete_text() load_fnt() move_text() write() unload_fnt() write_int() write_in_map() String handling functions char() lower() strcat() strchr() strcmp() strcpy() strdel() strlen() strset() strstr() upper() String conversion functions calculate() itoa() Animation functions end_fli() frame_fli() reset_fli() start_fli() Screen region functions define_region() out_region() Graphics information functions get_point() get_real_point() graphic_info() Initialisation functions set_fps() set_mode() Resource handling functions load_fpg() load_map() load_pcx() unload_fpg() unload_map() unload_pcx() save_map() save_pcx() Data IO functions load() save() File-handling functions fclose() filelength() flush() fopen() fread() fseek() ftell() fwrite() Directory-handling functions chdir() disk_free() get_dirinfo() get_fileinfo() getdrive() mkdir() remove() setdrive() File compression functions compress_file() uncompress_file() File encryption functions decode_file() encode() encode_file() System functions exit() ignore_error() system() Dynamic memory allocation functions free() malloc() memory_free() Network functions net_get_games() net_join_game() Note: To obtain help about a specific function directly, place the edit cursor on the name of the function (in the programs editor) and press F1 . ---See: Syntax Call to a process ( ) To call a process, put the name of the process, followed by a list including as many expressions separated by commas (,) , as parameters of the process, in brackets () . The brackets are obligatory, even if the process has no call parameters . A call to a process will always return a value that depends on which one of the following actions is performed first by the called process. If the FRAME statement is executed, then the process will return its identifying code . If the process executes the RETURN ( ](#)) statement, then the former will return the result of this expression. If the process finishes, either because the END of its BEGIN is reached or because a RETURN statement is executed with no expression, the process will return the identifying code of itself, but as the process has now finished (killed), it is necessary to take into account that this identifying code can be assigned by the system to any new process created from now on. The return value can be ignored, assigned to a variable or used inside an expression. Example: PROGRAM my_game; PRIVATE id2; BEGIN my_process(0, 0); id2=my_process(320, 200); // ... END PROCESS my_process(x, y) BEGIN LOOP FRAME; END END - In this example, the main process my_game makes two calls to the process my_process , which receives two parameters in its x and y local variables. As the process executes the FRAME statement, it will return its identifying code . It can be noticed how the value returned in the first call to the process is ignored (it is not used at all), and how, in the second call, the identifying code of my_process(320, 200) is assigned to the private variable of the main process id2 . When a call to a process is made, the execution of the current process is momentarily stopped, and the code of the called process is executed, until it is returned through one of the three mentioned cases (until it finishes or executes a FRAME or RETURN statement). If the process has finished with a FRAME statement, it will be displayed in the following frame according to the values established in its local variables ( x , y , graph , ...) and, in the preparation of the following frame, this process will go on running from the FRAME statement. ---See: Syntax - Parameters of a process Reference to a variable A reference to a variable is any expression making reference to a cell or a position of the computer's memory. It is normally understood as one of the following aspects: If the variable is a variable, in order to refer to the variable in this way, we must simply specify its name. Example of a reference to a variable: x If the variable is a table, reference to it is normally made with its name followed by an expression in square brackets ( [ ] ).That expression will determine the position of the table intended to be accessed. If the index in square brackets is omitted, the first position of the table (position 0) will be accessed. Example of a reference to a table: timer[0] If the variable is a structure, reference to it will be made with its name followed by an expression in square brackets ( [ ] ) that will determine the number of records that will be accessed. After it, the symbol . (period) will be put, preceding the specific name of the structure's field that is going to be accessed. If the record number in square brackets is omitted, the first record of the structure (number 0) will be accessed. Example of a reference to a structure: scroll[0].z These three cases deal with accessing data of the process itself or global data. To access an alien variable (a local variable of another process), it will be preceded by the identifying code of the alien process and the symbol . (period) , operator of access to local data and structures). Example of a reference to an alien local variable: father.x ---See: Syntax Definition of an expression An expression is basically a mathematical formula involving one or more operands ( x , 2 , id , ...) through different operators ( * , AND , >> , ...); some examples of expressions would be: 2 , 2+3 or (x 4)/-3 *. Only integers within the range ( min_int ... max_int ) can be used as values. The result of the expression will always be truncated within this range. These expressions will be evaluated when the statement containing them inside the program is executed. The operands that can be used in an expression are the following ones: Constants . Numeric values . Literals (texts in inverted commas). Variables, tables or structures of any kind. Any kind of function or process. Identifying code of the process. Type of process ( type ). The operators that can be used in an expression are the following ones (the synonymous of the operator, if they exist, are shown in brackets): + Addition - Subtraction (or sign negation) * Multiplication / Division MOD Module ( % ) << Rotation to the right >> Rotation to the left NOT Binary and logical negation ( ! ) AND Binary and logical AND( & , && ) OR Binary and logical OR( | , || ) XOR Exclusive OR ( ^ , ^^ ) == Comparison <> Different ( != ) > Greater than >= Bigger or equal ( => ) < Less <= Less or equal ( =< ) OFFSET Direction or offset ( & ) ++ Operator of increment -- Operator of decrement POINTER Addressing operator ( * , ^ , [ ] ) ( ) Brackets Click on \" Evaluation of an expression \" to see the order in which the calculations are made inside an expression and when the brackets must be used. Some examples of valid expressions are now shown: ** -33** ** 44-2 22 * ** id** ** x+1** ** (angle 3)/2-pi/2 * ** (x+y)/2** ** abs(x-y) 3-pow(x, 2) * ... ---See: Syntax - Evaluation of an expression Evaluation of an expression It is important to know the way in which the expressions are evaluated in order to know where it is necessary to put brackets indicating the way in which the expression is intended to be evaluated. In the language, an expression can contain operators of different levels of priority. In the evaluation of an expression, the operators of priority 1 (if they exist), will always be processed first, and then, those of priority 2 , priority 3 and so on. Priority 1 ( ) Brackets, beginning and end of a sub expression Priority 2 . Period, access' operator to local data and structures Priority 3 NOT Binary and logical negation (#1045, ! ) OFFSET Offset (#1050, & ) POINTER Addressing operator ( * , ^ , [ ] ) ** -** Sign negation ++ Operator of increment -- Operator of decrement Priority 4 * Multiplication / Division MOD Module ( % ) Priority 5 + Addition - Subtraction Priority 6 << Rotation to the right >> Rotation to the left Priority 7 AND Binary and logical AND ( & , && ) OR Binary and logical OR ( | , || ) XOR Exclusive OR ( ^ , ^^ ) Priority 8 == Comparison <> Different ( != > Greater than >= Bigger or equal ( => < Less <= Less or equal ( =< Priority 9 = Assignment += Addition-assignment -= Subtraction-assignment *= Multiplication-assignment /= Division-assignment %= Module-assignment &= AND-assignment |= OR-assignment ^= XOR-assignment >>= Rotation to the right-assignment <<= Rotation to the left-assignment The operators of priority 3 are known as unary operators. They do not link two operands (unlike the binary operators such as, for instance, a multiplication), but they just affect the value of an operator. Inside the unary operators, those closest to the operand will be executed first. For instance, in the expression: NOT -x The operand x has two unary operators, the negation of sign - and the logical and/or binary NOT . Among them, the negation of sign will be executed first, as it is closer to the operand. From priority 4 , all the operators are binary and they will be executed according to their level of priority. Therefore, when in an expression there is more than one operator of the same level (for instance, a multiplication and a division, both of priority 4), they will be processed from left to right. That is to say, in the following expression: 8/2*2 The division will be executed first and then, the multiplication (it is the natural way to evaluate the expressions mathematically). The only exception are the operators of priority 9 ( assignment operators), that will be evaluated from right to left (instead of from left to right). That is to say, in the expression: x=y=0 y=0 will be processed first ( y will be put at 0 ) and then, x=y ( x will also be put at 0 , as y will now be equal to 0 ). As it can be noticed, the assignments work like an operator After the assignment, they return the value they have assigned as a result of the operation. ---See: Syntax - Definition of an expression Definition of a condition The conditions are expressions normally similar to the following ones: x<320 size==100 AND graph>10 y==0 OR (x>=100 AND x<=200) ... In general, any expression is valid as a condition. In the language, all the ODD expressions are interpreted as true and all the EVEN expressions are interpreted as false . Example: PROGRAM my_game; BEGIN IF (20 2+1) x=x+1; END END - * In this example, the x=x+1; statement will always be executed, as the expression 20*2+1 is equal to 41 , an odd number. All the available operators are valid inside a condition. It is even possible to perform assignments inside a condition (the assignments are operations that return the assigned value as a result). All the identifying codes of processes are odd numbers. That is to say, all of them are true . Therefore, it is possible to implement conditions as the following one (supposing that id2 has been declared as a variable, and that shot is a type of process of the program). id2=get_id(type shot); WHILE (id2) id2.size=id2.size-1; id2=get_id(type shot); END In the id2=get_id(type shot) condition, the result of the get_id function is being assigned to the id2 variable. If that function has returned an identifying code , it will be an odd number and the condition will be evaluated as true (if get_id() does not find (more) identifiers of \" shot type\" processes, then it will return 0 (an even number), and the condition will be interpreted as false , finishing the WHILE statement. The previous statements would decrement the size variable of all the shot type processes existing in the program. ---See: Syntax - Definition of an expression Ways to obtain the identifying code of a process. All the processes have their own identifying code in ID (reserved word in the language that is equivalent to the identifying code of the process). When a process is created (is called), it returns its own identifying code as return value, unless it has finished with a RETURN ( ](#)). That is to say, a process will always return its identifying code when it finishes (when its END is reached), when it executes the FRAME or the RETURN statements without expression in brackets. In the following example, a process ( my_process type) is created from the main program, and its identifier is stored in the id2 variable. Example: PROGRAM my_game; PRIVATE id2; BEGIN id2=my_process(); // ... END PROCESS my_process() BEGIN // ... END - All the processes have the following local variables predefined with identifiers of other processes: father - father, identifier of the process that created it (the one that made the call). son - son, identifier of the last process created by it (last called process). bigbro - Elder brother, identifier of the last process created by the father before creating it. smallbro - Younger brother, identifier of the following process created by the father after having created it. These variables can be equal to 0 if they have not been defined (for instance, son will be equal to 0 until a process is not created or if this process has disappeared). The processes' identifying codes allow us to access their local variables ( . ) and, as father , son , etc. are also local variables, it is possible to make combinations such as son.bigbro to access the identifier of the penultimate process created (as son is the last one; therefore, its elder brother will be the penultimate one). Besides creation or direct relationship, there are other ways to obtain identifying codes of processes, as indicated below: The get_id() function to obtain the identifiers of the processes of a specific type (spacecraft, shot, etc.) existing at a specific moment in the game. The collision() function to obtain the identifiers of the processes with which it is colliding. When a specific process needs to access from many others, as it is an important process such as, for instance, the protagonist spacecraft of a game, then it can be more useful to assign its identifier to a GLOBAL variable of the program (that can be accessed by any process at any point). Thus, any process will be able to interact with it, as it will have its identifier. Example: PROGRAM my_game; GLOBAL id_spacecraft; BEGIN id_spacecraft=spacecraft(); // ... END PROCESS spacecraft() BEGIN // ... END PROCESS enemy() BEGIN // ... id_spacecraft.z=0; // ... END - In this example, at a specific point the enemy type processes access the z variable of the spacecraft created by the main program, using for that purpose its identifier, that is included in the id_spacecraft global variable. ---See: Identifying codes of processes. Identifying codes of processes. A process is an object independent of the program, that executes its own code and that can have its own coordinates, graphics, etc. Processes of a program can be, for instance, a shot, spacecraft or enemy. When something similar to what is below is input inside a program: PROCESS shot( ... ); BEGIN ** // statements ...** END The statements that are going to execute the \" shot type\" processes (the code ruling their performance), are specified. As it can be noticed, more than one shot type process may exist in a program. Then, how can they be distinguished? Simply by their identifying code. Every time that a new process is created in a game, an identifying code is assigned to this process. This code is going to be the exclusive reference of the process until it disappears. Two different processes will never have the same identifying code at the same time. However, the code that belonged to a process that has already disappeared can be assigned to a new process (something similar to what happens in relation to an i.d.). The identifying codes are always whole, positive, odd numbers, like 471, 1937 or 10823. All the processes have their own identifying code in ID , that is something similar to a process' local variable local, with the proviso that it can not be modified. Moreover, the processes have the identifying code of the process that created them (that called them) in father . They have the identifying code of the last process they created (the last one they called) in son . And so on. (see Hierarchies of processes ). What are the identifying codes for? --- Normally, all the processes need the identifying code of the other processes in order to interact with them (to see where they are, to modify them, ...). For instance, it is not possible to subtract energy from the \" enemy type\" process, as many or none of this type of processes may exist. It is necessary to have the specific identifying code of the enemy process from which you want to subtract energy. A process accesses all its own variables simply by their names, such as x , size or graph . Thus, if the identifier of a process is known (in son , father or any variable defined by the user, such as id2 ), then it is possible to access the variables of that process, like ( son.x , father.size or id2.graph ). That is to say, the syntax to access local variables of another process is as follows: . These variables can normally be used to consult them modify them. It is not at all possible to access PRIVATE variables of another process at any rate . In order to access a private variable of another process, it is necessary to change its declaration to the LOCAL section to transform it into a local variable. Then, any process will be able to access that variable just having the identifying code of the process, as all the processes will have that variable. The identifiers have more utilities other than the access to alien local variables, such as the signal() function, that can send specific signals to a process if its identifying code is known (for instance, to eliminate the process). There are also other functions, such as collision() , used to detect collisions with other processes. When this function detects a collision, it returns the identifying code of the process with which it is colliding. Once this code is known, it is possible to access the variables of the process and send them signals. The get_id() function operates in a similar way to collision() , obtaining the identifying code of a process. But in this case, no collision with it is necessary. ---See: Ways to obtain the identifying code of a process. States of a process. Processes are the different elements of a program (objects of the game). They may experience different states on creating, destroying or receiving specific signals with the signal() function. alive or awake. process A process is alive when it is running (when it is interpreting the statements located between its BEGIN and its END ). dead. process A process is dead when it finishes (either because its END is reached in the execution, a RETURN is executed or because it receives a signal s_kill or s_kill_tree ). asleep. process A process may receive the signal s_sleep (or s_sleep_tree ), then becoming asleep. In this state, this process will appear to be dead. But it is not as, at any moment, it may receive a signal s_wakeup and return to the alive or awake states. It is also possible to kill an asleep process. frozen. process The signal s_freeze (or s_freeze_tree ) freezes a process. In the frozen state, the process, that is still visible, remain blocked. It may be detected by the rest of the processes (for instance, as for collisions), but it is not executed (it stops interpreting its code statements). It will remain in this state until it receives another signal that changes its state or that kills it. A frozen process may be controlled (moved) by another process, directly manipulating its variables. When a signal is sent to a process, aiming at changing its state, this signal will have no effect before its following display ( FRAME ) is reached if the process is running. If the process is not running, then the signal will have an immediate effect. No signal must be sent to nonexistent processes (to an identifying code that does not correspond with any process). This signal will be ignored when the aim is to put a process in the state in which it is already. ---See: Hierarchy of processes. Hierarchies of processes. A process is an independent object of the program, that executes its own code and that may have its own coordinates, graphics, etc. For instance, a shot, spacecraft or enemy can be processes of a program. When a program starts to run there is only one process: the initial process, which starts the execution of the main code's statements. But, from this moment, this process can create new processes that, at the same time can create other processes, destroy them, etc. In order to clarify the events appearing through a program, we use a simile, treating the processes as if they were alive beings that are born and killed (when they are created or destroyed). For that reason, the following terms are established: Father , name given to the process that has created another one (mother would have been a more appropriate name). Son , process created by another one. Brothers , processes created by the same father. Orphan , process whose father has died (as it has been either eliminated or finished). This vocabulary may be spread as far as your imagination desires grandfathers , grandsons , uncles , etc. All the processes have direct access to the identifying codes of the processes with which they have direct relationship (see: Ways to obtain the **#1039,identifying code of a process**. Occasionally, reference is made to actions performed by \" the system \". This process, called div_main , controls the rest. Therefore, it is in charge of creating the initial process at the beginning of the execution, of setting the speed execution, the debugger, etc. All the processes that are orphaned become sons of this process. The div_main identifier can be obtained with get_id(0) . It can be used to send a tree signal to all the processes, but this process won't be displayed on screen , even if its x , y , graph , etc. variables are defined. ---See: States of a process Types of processes. The blocks of the programs starting with the reserved word PROCESS determine the performance of a specific process type. Then, when the program is executed, any number of processes of this type will be able to exist at a specific moment. Each of these processes will have a different identifying code , but all of them are of the same type. Example: PROGRAM my_game; BEGIN // ... END PROCESS spacecraft() BEGIN // ... END PROCESS enemy() BEGIN // ... END PROCESS shot() BEGIN // ... END - In this example, four types of processes are defined: my_game (the type of the program's initial process), spacecraft , enemy and shot . The number of processes of each of these types existing in the game depends on the number of calls made to these processes. All the processes of spacecraft type will always execute the statements defined in the PROCESS spacecraft() of the program. A \"process type\" is a numeric code referred to the name of the PROCESS that determines how the process works during the game. This numeric code can be obtained with: TYPE . TYPE is an operator defined in the language that, applied to a process name, returns this numeric code. For instance, TYPE spacecraft will be equivalent to a specific numeric constant and TYPE enemy will be equivalent to another one. All the processes have a local variable containing this numeric code, which is: reserved.process_type . What is the process type for? --- The process type is used for several things, as it is mentioned below: For the get_id() function that receives a process type (for instance, get_id(TYPE enemy) ) as a parameter and returns the identifying codes of the processes of this type existing in the game at that moment. For the collision() function is similar to the previous one, with the proviso that it returns the identifying codes of the processes with which it is colliding (the graphics of both processes are partially superposed). For the signal() function, that may send a signal to all the existing processes of a specific type. Or to verify, from a process' identifying code , what kind of process it is (type spacecraft, type shot, etc.). The operator TYPE can only be used preceding a process name of the program or the word mouse , to detect collisions with the mouse pointer (with collision(TYPE mouse) ). ---See: Identifying codes of processes. FROM statement FROM = TO ; ; ... END (or) FROM = TO STEP ; ; ... END The FROM statement implements a loop . That is to say, it is capable of repeating a group of statements a specific number of times . A GLOBAL , LOCAL or PRIVATE variable of the process itself that can be used as a loop counter is needed to implement this loop. The reserved word FROM must be put before the statements that will comprise the inner group of statements. This word will be followed by the name of the counter variable , the symbol of assignment ( = ), the initial value of the variable, the reserved word TO and, finally, the final value of the variable. The symbol ; (semicolon) must be put after this declaration of the loop FROM . The inner group of statements that is intended to be repeated a specific number of times is put after this head defining the conditions of the loop. Finally, the reserved word END will be put. The name of iteration of the loop is referred to the number of times that the inner set of statements is executed. The first iteration will be performed with the initial value in the variable used as a counter. After this iteration, 1 will be added to this variable (if the initial value is less that the final value). Otherwise 1 will be subtracted from it. After having updated the value of the variable, it is necessary to pass to the following iteration, provided that the value of this variable has not reached (or exceeded) the final value of the loop. The reserved word STEP can be put as second meaning of the FROM statement, after the initial and final values of the statement. This word must be followed by a constant value indicating the increment of the counter variable after every iteration of the loop, instead of 1 or -1 , which are the increments that will be performed by default if the STEP declaration is omitted. The following example shows a program with two loops FROM : one without STEP declaration (with increment or decrement by default) and the other with it. Example: PROGRAM my_game; BEGIN FROM x=9 TO 0; // Inner statements ... END FROM x=0 TO 9 STEP 2; // Inner statements ... END END - The first loop will be executed 10 times with the x variable . Its value will range between 9 and 0 in the different iterations. By default, 1 will be subtracted from the variable each time, as the initial value (9) is bigger than the final value (0). In the second loop, constant 2 is indicated as the increment of the variable. Thus, the loop will be executed 5 times with the x variable, whose values will be 0 , 2 , 4 , 6 and 8 , respectively, in the consecutive iterations. As it can be noticed, no iteration will be performed with x being equivalent to 9 , even if it is the loop's final value . By default, if 2 had not been specified as STEP of the loop, 1 would have been added to the x variable after each iteration. A loop FROM can always be performed with the FOR statement, as it is now shown (with two loops equivalent to those of the previous example). Example: PROGRAM my_game; BEGIN FOR ( x=9 ; x>=0 ; x=x-1 ) // Inner statements ... END FOR ( x=0 ; x<=9 ; x=x+2 ) // Inner statements ... END END - The initial and final values of a loop FROM must be different. If the initial value is less than the final value, it is not possible to specify a negative value in the STEP declaration. If the initial value is bigger than the final value, it is not possible to specify a positive value in the STEP declaration. A BREAK statement inside a loop FROM will immediately finish it, continuing the program from the following statement to this loop (after the END ). A CONTINUE statement inside a FROM loop will force the program to increment the variable used as a counter immediately and then, if the final value has not been exceeded, to start the following iteration. The statements inner to a loop FROM may be as many as desired, of any kind, obviously including new loops FROM . ---See: Syntax Use of angles in the language. In the language, all the angles are specified in degree thousandths. For instance: 0 is 0 degrees (to the right) 90000 are 90 degrees (up) ** -45000 are -45 degrees** (down right diagonal) If 360 degrees (360000) are added to or subtracted from any angle, an equivalent angle is obtained. For instance, the angles -90000 and 270000 are equivalent (the angles of -90 degrees and 270 degrees go both downwards) The constant PI predefined as 180000 , 3.1415 radians or, what is the same, 180 degrees , can be used as reference. For instance, PI/2 will be equal to 90 degrees (90000). Some of the functions dealing with angles are mentioned below: get_angle() get_distx() get_disty() fget_angle() near_angle() advance() xadvance() All the processes have a predefined local variable called angle which, by default, will be equal to 0 . If its value is modified, the display's angle of the graphic of the process will be changed (the graphic will rotate in the indicated degrees, from the original graphic). ---See: Syntax NOT ! Unary operator of logical and binary negation used in expressions and conditions. The reserved word NOT and the symbol ! are synonymous. NOT logical: If the operand is true , on applying this operator to it, a false expression will be obtained, and vice versa. TRUE -> FALSE FALSE -> TRUE NOT binary: Changes all the bits of the operand. That is to say, it passes 0 to 1 and 1 to 0. Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). On changing the NOT operator, all the bits also change the last one, transforming then the even numbers into odd numbers (false expressions into true ones) and the odd numbers into even numbers (true expressions into false ones). ---See: Syntax - Expression - Condition <> != Logical operator [ different from ] used in conditions. The symbols <> and != are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If both expressions have the same result (if these two expressions are equivalent), as they ARE NOT different. True - If the expressions have different results, as they ARE different. Examples: 2+2 <> 4 will return false . 0 <> -1 will return true . ---See: Syntax - Condition \" ' Symbols delimiting literals. Literals are the texts in inverted commas . Literals may start and finish with the character [ ' ] or even with the character [ \" ] (but they have to start and finish with the same character). There are two ways to include the character [ \" ] in a literal, supposing that the aim is to define a literal containing the text: a\"B\"c Duplicating the character: \"a\"\"B\"\"c\" Defining it with the simple inverted comma: 'a\"B\"c' It happens the same regarding the character [ ' ], that can be included in a literal if it is duplicated, or if the literal is delimited with the character [ \" ]. All the literals must be closed in the same line as they started. It is not possible to define literals occupying more than one line. Literals of several lines. It is possible to define the literals over several lines, to do this you just need to divide the text into several lines, and put them successively (do not separate them with any symbol). For example, you could define a constant as: salute=\"\u00a1Ho\" ** \"la!\";** This also can be used to initiate the data of type STRING . There is no limit in the number of lines. Only Comments can appear between two successive literals. ---See: Syntax MOD % Arithmetic operator of module or remainder of a whole division . The reserved word MOD and the symbol % are synonymous. This operator is used in the arithmetic expressions between two operands, to obtain the module of the first one divided by the second one. For instance, 7 MOD 3 will return 1, as the whole division of 7 by 3 give us 2 as quotient and 1 as remainder . That is to say, n MOD m will always return a number within the range (0..m-1). To understand easily how to obtain the remainder of an operation n MOD m , the following steps may be followed: Step 1 - If n is less than m , then the result of the operation MOD is n . Step 2 - (When n is bigger than or equal to m ), subtract m from n and go to step 1 . Use: On some occasions, this operator is used in the programs requiring that a counter variable always changes between 0 and other number . For instance, if the aim is that the x variable indefinitely varies between 0 and 319 (x=0, x=1, x=2, ..., x=319, x=0, x=1, ...), then there would be the following option: x=0; LOOP ** x=x+1;** ** IF (x==320) x=0;** ** // ...** END But many programs replace these statements by the following ones: x=0; LOOP ** x=(x+1) MOD 320;** ** // ...** END that fulfills the same function, as the operator MOD will truncate the expression when it is bigger than or equal to 320 at a lesser value. The quotient of a whole division is obtained through the operator / (division). ---See: Syntax - Expression %= Operative assignment. Operation of module or remainder of a whole division . The assignment statements are used to calculate expressions and to assign them to a variable. = ; If the symbol %= is used instead of = to perform the assignment, the following module or remainder of the division will be assigned to the variable: [ previous_value_of_the_variable ] / [ result_of_the_expression ] Example: x=3; x%=2; -> (x=1) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, a n %= m; type statement will be equivalent to this other n = n MOD m; statement. See the operator MOD for further information about the module . ---See: Syntax - Assignment & Bi functional symbol, that has two different uses depending on whether it is used as an unary or binary operator. An UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator & will be a synonymous of OFFSET . Example: &x is equivalent to OFFSET x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator & will be a synonymous of AND . Example: x&2 is equivalent to x AND 2 ---See: Syntax - OFFSET - AND AND && Binary operator of the logical product used in expressions and conditions. The reserved word AND and the symbol && are synonymous. AND logical: The conditions to the right and left of the operator are first evaluated and, if both are true , this operator will return true . Otherwise, the operator will always return false . FALSE AND FALSE = FALSE FALSE AND TRUE = FALSE TRUE AND FALSE = FALSE TRUE AND TRUE = TRUE These are used to verify that more than one condition is satisfied; for instance: (x>0 AND x<100) To verify that the variable is bigger than 0 AND less than 100. AND binary: Evaluates the bits of the expressions appearing before and after the operator, returning the value of the bits that are common to both expressions as follows: 0 AND 0 = 0 0 AND 1 = 0 1 AND 0 = 0 1 AND 1 = 1 This rule will be applied to all the bits of the operands (in the language, these are 32 bit integers). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator AND will only leave the last bit at 1 (it will only return true as a result} when both operands have this bit at 1 (when both are true expressions). Note: The symbol & can also be used as another synonymous of AND and ** &&**. ---See: Syntax - Expression - Condition &= Operative assignment. Binary operation of logical product ( AND ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol &= is used instead of = to perform the assignment, the following logical product will be assigned to the variable: [ previous_value_of_the_variable ] AND [ result_of_the_expression ] Example: x=5; x&=6; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n &= m; type statement will be equivalent to this other n = n AND m; statement. See the operator AND for further information about the logical product . ---See: Syntax - Assignment ( ) The symbols ( and ) , called brackets, must always appear in pairs and in this same order. They are used to delimit some calculations, parameters or conditions of the programs, marking their beginning with the symbol ( and the end with the symbol ) . Inside an expression, they indicate that the calculation within them must be done before the calculation out of them. For instance, the expression 2*3+2 will be evaluated as 8 , as the multiplication (2 by 3 equals 6) will be done first and then, the addition (6 plus 2 equals 8). Using brackets, it is possible to force to do the addition at first, expressing the calculation as 2*(3+2) , that will be evaluated as 10 , as now the addition (3 plus 2 equals 5) will be done first and then, the multiplication (2 by 5 equals 10). The brackets are also use to delimit the call parameters of the processes or the functions and inside the syntax of different statements of the language. ---See: Syntax - Expression * Arithmetic operator of whole multiplication . This operator is used in the arithmetic expressions between two operands, to obtain the result of their multiplication. For instance, 2 * 8 will return 16 , 99 * 0 will return 0 , 2 * -1 will return -2 , etc. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the multiplication must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. This symbol is bi functional; it has two different uses depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator * will be a synonymous of POINTER . Example: &x is equivalent to POINTER x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator * will be the arithmetic operator of multiplication** previously explained. ---See: Syntax - Expression - POINTER *= Operative assignment. Arithmetic operation of multiplication . The assignment statements are used to calculate expressions and to assign them to a variable. = ; If the symbol = * is used instead of = to perform the assignment, then the following multiplication** will be assigned to the variable: [ previous_value_of_the_variable ] * [ result_of_the_expression ] Example: x=2; x*=3; -> (x=6) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, a n *= m; type statement will be equivalent to this other n = n * m; statement. See the operator * for further information about the multiplication . ---See: Syntax - Assignment + Arithmetic operator of addition . This operator is used in the arithmetic expressions between two operands, to obtain their addition. For instance 2 + 6 will return 8, the result of 2 plus 6. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the addition must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. ---See: Syntax - Expression ++ Operator of increment. This operator, derived from the C language, allows us to increment the value of a variable (to add 1 to it) without requiring an assignment statement for that purpose. The variable can be a variable, a position of a table , or a field of a structure . This operator can be included in an expression with two forms: pre-increment and post-increment . Operator of pre-increment. When the symbol ** ++ is put just before a variable, 1 will be added to it before the execution of the statement**. As examples, see the following statements: ** ++x; - statement that will add 1 to the x** variable. ** z=++x+y; - statement that will add 1 to the x variable and then, it will assign the addition between x (already incremented) and y to the z** variable. Operator of post-increment. When the symbol ++ is put just after a variable, 1 will be added to it after the execution of the statement . As examples, see the following statements: ** x++; - statement that will add 1 to the x** variable. ** z=x+y++; - statement that will assign the addition between x and y to the z variable, incrementing then the y** variable. Summary: Generally, a ++variable; or variable++; type statement is always equivalent to the following statement: variable=variable+1; (or variable+=1; ). The difference between the pre-increment and the post-increment is that in the first case, the value of the variable already incremented is taken to evaluate the rest of the expression, while in the second case, the expression is evaluated with the value that the variable had before being incremented. ---See: Syntax - Expression - Decrement(--) += Operative assignment. Arithmetic operation of addition . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol += is used instead of = to perform the assignment, the result of the following addition will be assigned to the variable: [ previous_value_of_the_variable ] + [ result_of_the_expression ] Example: x=2; x+=2; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n += m; type statement will be equivalent to this other n = n + m; statement. See the operator + for further information about the addition . ---See: Syntax - Assignment , The symbol of the comma ( , ) is used inside the programming language, in different points of a program, to separate two consecutive elements of a list. It is used, for instance, in the following points: In the lists of constants to separate their different numeric values. In the definition of the parameters of a process to separate the names of the different parameters. In the call to a function and in the call to a process to also separate different expressions that will be assigned to the parameters of the function or process. In the FOR statement to separate different initialisations, conditions or increments. In the SWITCH statement to define the different values accepted in a block CASE ... END . The symbol of the comma can also be used to separate several declarations of data , instead of finishing each of them with a symbol semicolon ( ; ). ---See: Syntax - Arithmetic operator of subtraction . This operator is used in the arithmetic expressions between two operands, to obtain the result of this subtraction. For instance, 2 - 6 will return -4, the result of subtracting 6 from 2. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the subtraction must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. This symbol is bi functional. That is to say, it has two different uses depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator ** - will be the minus sign**. Example: -7 the negative integer minus seven . A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator - will be the arithmetic operator of subtraction previously explained. ---See: Syntax - Expression -- Operator of decrement. This operator, derived from the C language, allows us to decrement the value of a variable (to subtract 1 from it) without requiring an assignment statement for that purpose. The variable can be a variable, a position of a table , or a field of a structure . This operator can be included in an expression with two forms: pre-decrement and post-decrement . Operator of pre-decrement. When the symbol -- is put just before a variable, 1 will be subtracted from it before the execution of the statement . As examples, see the following statements: ** --x; - statement that will subtract 1 from the x** variable. ** z=--x+y; - statement that will subtract 1 from the x variable and then, it will assign the addition between x (already decremented) and y to the z** variable. Operator of post-decrement. When the symbol -- is put just after a variable, 1 will be subtracted from it after the execution of the statement . As examples, see the following statements: ** x--; - statement that will subtract 1 from the x** variable. ** z=x+y--; - statement that will assign the addition between x and y to the z variable, decrementing then the y** variable. Summary: Generally, a --variable; or variable--; type statement is always equivalent to the following statement: variable=variable-1; (or variable-=1; ). The difference between the pre-decrement and the post-decrement is that, in the first case, the value of the variable already decremented is taken to evaluate the rest of the expression, while in the second case, the expression is evaluated with the value that the variable had before being decremented. ---See: Syntax - Expression - Increment(++) -= Operative assignment. Arithmetic operation of subtraction . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol -= is used instead of = to perform the assignment, the result of the following subtraction will be assigned to the variable: [ previous_value_of_the_variable ] + [ result_of_the_expression ] Example: x=4; x-=2; -> (x=2) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n -= m; type statement will be equivalent to this other n = n - m; statement. See the operator - for further information about the subtraction . ---See: Syntax - Assignment . -> Operator of access to structures or to alien local data. The symbols . and -> are synonymous. Therefore, they can indistinctly be used. Access to structures. To access a field of a structure, this operator must be used in the following way: [ ] . (or, using the other symbol) [ ] -> Examples: scroll[0].camera m7[1]->z Note: Keep in mind that the record number in square brackets can be omitted when record number 0 is accessed. For instance, scroll[0].camera will always be equivalent to scroll.camera . Access to alien local data (belonging to another process). To access a LOCAL variable of a process from another one, the identifying code of the process whose variable is going to be read or modified must be known. Then, it will be possible to access it in the following way: . (or using the other symbol) -> Examples: father.x son->graph ---See: Declaration of a structure - Identifying codes - Syntax .. Range of values of a section CASE --- The symbol .. (double period) is used to define a range of values. That is to say, to express the numbers ranging between two values (inclusive). This symbol is only used in the SWITCH statements , inside the sections CASE , to specify a range of values. It doesn't matter to express a range either as minimum..maximum or as maximum..minimum . For instance, the range defined as -2 .. 1 would be made up of the numbers -2 , -1 , 0 & 1 . ---See: Syntax - SWITCH statement / Arithmetical operator of whole division . This operator is used in the arithmetic expressions between two operands, to obtain the quotient of the first one divided by the second one. For instance 7 / 3 will return 2 as, on doing the whole division of 7 by 3, the quotient will equal 2 (and the remainder will be 1). That is to say, n / m will always return the result of the division of n by m , but with no decimals (as all the variables are 32 bit integers with sign in the language). The remainder of a whole division is obtained through the operator MOD (module). ---See: Syntax - Expression /= Operative assignment. Operation of whole division . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol /= is used instead of = to perform the assignment, the whole result (quotient) of the following division will be assigned to the variable: [ previous_value_of_the_variable ] / [ result_of_the_expression ] Example: x=8; x/=2; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n/-= m; type statement will be equivalent to this other n = n / m; statement. See the operator / for further information about the whole division . ---See: syntax - Assignation : The symbol : (colon) is used to finish a CASE or DEFAULT declaration of a SWITCH statement . Actually, the symbols : (colon) and ; (semicolon) are synonymous in this language. That is to say, they can be used indistinctly. However, similarly to what happens in other programming languages, the symbol semicolon is normally used to finish statements and the symbol colon is normally used inside the syntax of the SWITCH statement . ---See: Syntax - CASE - DEFAULT - SWITCH statement ; The symbol ; (semicolon) is used in many points of a program to indicate always that a statement or any kind of declaration finishes. This is called finishing symbol, whose only purpose is to indicate the end of something. In the language, the following points of the program must be indicated with semicolon: The end of the PROGRAM declaration . The end of a declaration of a variable . The end of an IMPORT declaration . The end of the following statements: Assignments or increments of data . Calls to processes . Calls to functions . FRAME , RETURN , DEBUG , BREAK and CONTINUE . The end of the beginning of a loop FROM . And separating the different parts of a FOR statement. The compiler will indicate the lacking of the symbol ; in any of these points. It is also possible to put this symbol in other specific points of the programs, such as after any other kind of statement, even if it will be optional in this case and, therefore, the compiler won't report its lacking. Actually, the symbols ; (semicolon) and : (colon) are synonymous in this language. That is to say, they can be used indistinctly. However, similarly to what happens in other programming languages, the symbol semicolon is normally used to finish statements and the symbol colon is normally used inside the syntax of the SWITCH statement . ---See: Syntax < Logical operator [ less than ] used in conditions. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T less than the second one. True - If the first expression IS less than the second one. Examples: 2+2 < 4 will return false . 1 < 2 will return true . ---See: Syntax - Condition << Binary operator of rotation to the left . This operator is used in the arithmetic expressions , between two operands, to obtain the result of rotating the first operand to the left as many times as indicated by the second. For instance, the following rotation: n << m Will return n rotated to the left m times. Every rotation to the left is equivalent to multiplying the number by 2. That is to say, rotating to the left once, is equivalent to multiplying by 2; rotating to the left twice is equivalent to multiplying by 4; 3 times is equivalent to multiplying by 8, and so on. Or, what is the same, (the POW function (2, m) returns 2 raised to m ): n * POW(2, m ) For instance, 2<<3 will return 16, 4<<1 will return 8, 100<<0 will return 100, etc. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the rotation must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. The operator of rotation to the right (the contrary operation) is the symbol >> . ---See: Syntax - Expression <<= Operative assignment. Binary operation of rotation to the left . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol <<= is used instead of = to perform the assignment, the result of the following rotation will be assigned to the variable: [ previous_value_of_the_variable ] << [ result_of_the_expression ] Or, what is the same, (the POW function (2, n) returns 2 raised to n ): [ previous_value_of_the_variable ] * POW(2, [ result_of_the_expression ] That is to say, if the result of the expression is: 0 -> the variable will maintain its value. 1 -> the variable will be multiplied by 2. 2 -> the variable will be multiplied by 4. 3 -> the variable will be multiplied by 8. ... Example: x=2; x<<=2; -> (x=8) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n <<= m; type statement will be equivalent to this other n = n << m; statement. See the operator << for further information about the rotation to the left . ---See: Syntax - Assignment <= =< Logical operator [ less than or equal to ] used in conditions. The symbols <= and =< are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T less than or equal to the second one. True - If the first expression IS less than or equal to the second one. Examples: 2+2 <= 3 will return false . 2+2 <= 4 will return true . ---See: Syntax - Condition = The symbol = (symbol of assignment ) is used in the language inside the data declarations to initialise them to their initial value. In the assignment statements , this symbol is used to separate the reference to the variable from the assigned expression. Inside an expression, this operator can be used as a conventional binary arithmetic operator, which is placed between two operands, returning the second operand's value as a result (besides assigning this result to the variable defined as first operand). This operator represents an imperative order according to which, on executing the statement that contained it, the first operand (before the symbol) will take the value of the second operand (or expression after the symbol). On evaluating an expression, the assignment operands are always those of less priority (the last ones that are interpreted in the expression), being possible to use brackets to force a bigger priority. If, in an expression (or statement) several assignment operands have been used, they will be evaluated (executed) from right to left. For instance, in the statement: x=y=x+y; The addition ( x+y ) will first be done. Then, the result will be assigned as the new value of the y variable ( y=x+y ) and, finally, this same value will be assigned to the x variable ( x=y ). ---See: Syntax - Data declarations - Assignment statements == Logical operator [ equal to ] used in conditions. It must be used between two numeric expressions and it returns a logical result: False - If the expressions give different results, as they AREN'T equal (or equivalent). True - If both expressions give the same result (if they are equivalent expressions), as they ARE equal. Examples: 0 == -1 will return false . 2+2 == 4 will return true . Note: The symbol = can not be used to compare two expressions or numeric values, as it is the assignment symbol. ---See: Syntax - Condition >= => Logical operator [ bigger than or equal to ] used in conditions. The symbols >= and => are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T bigger than or equal to the second one. True - If the first expression IS bigger than or equal to the second one. Examples: 2+2 >= 3 will return false . 2+2 >= 4 will return true . ---See: Syntax - Condition > Logical operator [ bigger than ] used in conditions. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T bigger than the second one. True - If the first expression IS bigger than the second one. Examples: 2+2 > 4 will return false . 2 > 1 will return true . ---See: Syntax - Condition >> Binary operator of rotation to the right . This operator is used in the arithmetic expressions , between two operands, to obtain the result of rotating the first operand to the right as many times as indicated by the second one. For instance, the following rotation: n >> m Will return n rotated to the right m times. Every rotation to the right is equivalent to dividing the number by 2. That is to say, rotating to the right once, is equivalent to dividing by 2; rotating to the right twice is equivalent to dividing by 4; 3 times is equivalent to dividing by 8, and so on. Keep in mind that all the numbers used in this language are integers (with no decimals). Therefore, an integer will always be returned as a result of the division (for instance, 7 divided by 2 will return 3). Or, what is the same, (the POW function (2, m) returns 2 raised to m ): n / POW(2, m ) For instance, 16>>3 will return 2, 2>>1 will return 1, 100>>0 will return 100, etc. The operator of rotation to the left (the contrary operation) is the symbol << . ---See: Syntax - Expression >>= Operative assignment. Binary operation of rotation to the right . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol >>= is used instead of = to perform the assignment, the result of the following rotation will be assigned to the variable: [ previous_value_of_the_variable ] >> [ result_of_the_expression ] Or, what is the same, (the POW function (2, n) returns 2 raised to n ): [ previous_value_of_the_variable ] / POW(2, [ result_of_the_expression ] That is to say, if the result of the expression is: 0 -> the variable will maintain its value. 1 -> the variable will be divided by 2. 2 -> the variable will be divided by 4. 3 -> the variable will be divided by 8. ... Example: x=8; x>>=2; -> (x=2) The result of a rotation to the right will always be an integer, with no decimals or, what is the same, the quotient of the previous whole division. Example: x=9; x>>=2; -> (x=2) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n >>= m; type statement will be equivalent to this other n = n >> m; statement. See the operator >> for further information about the rotation to the right . ---See: Syntax - Assignment POINTER [ ] Addressing operator. This operator requires a slightly advanced level in programming techniques. The use of pointers is a characteristic of other languages that, even if it may be very useful, is not indispensable to make programs, no matter how difficult they are. The reserved word POINTER is used to make reference to a specific position of the computer's memory. Practical case. --- For instance, having a variable named my_variable with value 3 , which will be stored in an offset of the memory (all the variables have an offset), the operator OFFSET is used to obtain this offset. Supposing that there is another variable named offset_of_my_variable used to store the offset of the previous variable, which would be done with the following statement: offset_of_my_variable = OFFSET my_variable; This offset will be an integer, for instance 12345 . In order to obtain or modify the value of the variable ( 3 ), having only the offset (position) of the variable (and not its name) in the memory, the operator POINTER must be used. The statement to obtain the value of the variable from its offset would be as follows: my_variable = POINTER offset_of_my_variable; A series of expressions and their numeric equivalents are now shown in order to clarify the concepts of name of the variable , offset of the variable and value of the variable . my_variable = 3 OFFSET my_variable = 12345 offset_of_my_variable = 12345 POINTER offset_of_my_variable = 3 The offset of a variable may vary as a program is expanded (by adding new data and statements to it). In short, {the operator POINTER accesses the value that is in the position of the computer's memory indicated after it}. That is to say: POINTER 12345 = 3 It means that value 3 is in the offset 12345 of the computer's memory, as it is in this offset where the value of the my_variable variable is stored , and it is its value. The symbol * and the symbol ^ may be used as synonyms of the reserved word POINTER (in the previous example 12345 * = 3 or ^12345 = 3**). The square brackets (symbols [ ] ) work in a similar way to the operator POINTER , with the proviso that they access the variable whose offset is indicated in them (in the previous example [12345] = 3 ). The square brackets are also used to specify the index in the tables and structures. ---See: Syntax - OFFSET ^ This symbol is bi functional; it has two different uses, depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator ^ will be a synonymous of POINTER . Example: ^x is equivalent to a POINTER x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator ^ will be a synonymous of XOR . Example: x^2 is equivalent to x XOR 2 ---See: Syntax - POINTER - XOR ^= Operative assignment. Logical and binary operation of exclusive OR ( XOR ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol ^= is used instead of = to perform the assignment, the following exclusive OR will be assigned to the variable: [ previous_value_of_the_variable ] XOR [ result_of_the_expression ] Example: x=5; x^=3; -> (x=3) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n ^= m; type statement will be equivalent to this other n = n XOR m; statement. See the operator XOR for further information about the exclusive OR . ---See: Syntax - Assignment XOR ^^ Logical and binary operator of exclusive OR used in expressions and conditions. The reserved word XOR and the symbol ^^ are synonymous. XOR logical: The conditions on the right and left of the operator are first evaluated and, if (only one) is true , this operator will return true . Otherwise, the operator will always return false . FALSE XOR FALSE = FALSE FALSE XOR TRUE = TRUE TRUE XOR FALSE = TRUE TRUE XOR TRUE = FALSE It is used to verify that one (and only one) of the two specified conditions is complied; for instance: (y>0 XOR x>0) To verify either that the first variable is bigger than 0, or (exclusive\"or\") that the second variable (but not the first one) is bigger than 0. XOR binary: Evaluates the bits of the results of the expressions appearing before and after the operator, giving as a result a value of 1 only for those bits that had at 1 one (and only one) of the expressions. 0 XOR 0 = 0 0 XOR 1 = 1 1 XOR 0 = 1 1 XOR 1 = 0 This rule will be applied to all the bits of the operands (in the language, they are integers of 32 bits). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator XOR will only leave the last bit at 1 (it will only return true as a result} when one (and only one) of both operands have this bit at 1 (when only one of the two expressions is true ). Note: The symbol ^ can also be used as another synonymous of XOR ** and ^^**. ---See: Syntax - Expression - Condition - OR OR || | Binary operator of logical addition used in expressions and conditions. The reserved word OR and the symbols || and | are synonymous. OR logical: The conditions to the right and left of the operator are first evaluated and if, at least, one of them is true , this operator will return true . Otherwise, the operator will always return false (when both conditions are false ). FALSE OR FALSE = FALSE FALSE OR TRUE = TRUE TRUE OR FALSE = TRUE TRUE OR TRUE = TRUE It is used to verify that one of the specified conditions is complied; for instance: (x>0 OR y>0) To verify that, at least, one of both variables is bigger than 0. That is to say, it is verified that the first OR the second conditions are complied. OR binary: Evaluates the bits of the results of the expressions appearing before and after the operator, giving as a result a value that will have at 1 the bits that any of the expressions would have at 1. 0 OR 0 = 0 0 OR 1 = 1 1 OR 0 = 1 1 OR 1 = 1 This rule will be applied to all the bits of the operands (in the language, they are 32 bit integers). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator OR will leave the last bit at 1 (it will return true as a result) when one of any of the operands have this bit at 1 (when, at least, one of the two expressions is true ). ---See: Syntax - Expression - Condition - XOR |= Operative assignment. Binary operation of logical addition ( OR ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol |= is used instead of = to perform the assignment, the following logical addition will be assigned to the variable: [ previous_value_of_the_variable ] OR [ result_of_the_expression ] Example: x=5; x|=6; -> (x=7) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n |= m; type statement will be equivalent to this other n = n OR m; statement. See the operator OR for further information about the logical addition . Note: don't confuse this symbol with that of [ different from ] expressed as != , that is used to compare whether two expressions have different results. ---See: Syntax - Assignment OFFSET The reserved word OFFSET allows us to obtain the offset of a variable inside the computer's memory. All the data of a program correspond with any specific position of the memory in which its value is stored. The operator OFFSET allows us to obtain this position as a numeric value. This operator is mainly used in the parameters of any of the language's functions. Thus, these functions are able to modify these parameters. If you have a variable (called, for instance, my_variable ) with value 321 and this variable is passed, as a parameter, to a parameter function, the number 321 is being passed to the function. Then, the function won't be able to modify the variable, as it knows its value but not where the variable is (because many 321 values may exist in the whole computer's memory, and it won't know which of them is the variable). If OFFSET my_variable is passed to this function as a parameter, it is receiving information about the place in which the variable value is stored. Then, the function will be able to access this value in order to consult it or modified it. For further information about this operator, it is possible to access the operator POINTER that does the operation opposite to that of the operator OFFSET (it obtains the value stored in a specific position of the memory). The symbol & can be used as synonymous of the reserved word OFFSET . ---See: Syntax - POINTER BEGIN This reserved word shows the beginning of the program or process. That is to say, the word BEGIN is used to separate the area of data declaration of the main program or of a process, from the area of statements. The BEGIN declaration is obligatory in the main program and in all the processes. When a program or process are executed, they will always start with the statement coming after BEGIN . The BEGIN statement does nothing . It is only used as a delimiting element inside the structure of the programs. Every BEGIN is directly linked to an END that will mark the end of the area of statements of the program or process. ---See: Syntax - Main Code - Declaration of processes - FUNCTION CASE This reserved word is a part of the SWITCH statement. It is used as the beginning of the different sections of statements that can or can not be executed, depending of the result of the evaluated expression. Every CASE must have a word END indicating the end of the section. The SWITCH statement evaluates an expression, and the word CASE means \" in case that the result of the expression is ..., then the following statements must be executed ... \". ---See: Syntax - SWITCH statement DEFAULT This reserved word is a part of the SWITCH statement, that is used to begin a section of statements that must be executed when the result of the evaluated expression is not contemplated in any of the sections CASE of the statement. Every DEFAULT must have a word END indicating the end of the section. The SWITCH statement evaluates an expression. Every section CASE of the statement will contemplate one of several results in which that section must be executed. Finally, a section DEFAULT appears to express \" in case that the result of the expression is none of the previous ones, then the following statements must be executed ... \". ---See: Syntax - SWITCH statement DUP This word is used to define lists of constants (numeric values), by repeating a simple pattern. It is used to initialise the initial values of tables and structures. Its syntax is as follows: DUP ( ) It is equivalent of putting the the indicated . For instance, the sequence 1, 2, 3, 1, 2, 3, 1, 2, 3 would be equivalent to the sequence 3 DUP (1, 2, 3) . ---See: Syntax - Definition of a list of constants ELSE This word is a part of the IF statement, and is used to specify where the block of statements that must be executed starts when the condition specified in the IF is not complied. The format of the IF statement is the following one: IF (< condition >) // Code to execute when the condition is complied ELSE // Code to execute when the condition isn't complied END The meaning of ELSE is \" otherwise ... \". The section ELSE is optional. The IF statement can be formulated in the following way: IF (< condition >) // Code to execute when the condition is complied END When no statement is required to be executed in the opposite case . ---See: Syntax - IF statement END This reserved word marks the end of one of the following statements: BEGIN IF WHILE SWITCH CASE DEFAULT FOR FROM LOOP CLONE That is to say, the function of the word END is to delimit where a statement finishes . Keep in mind that the statements may be nested (they may be included one inside another). Therefore, if a program is not well structured (tabulating the code), it can be difficult to find out to which statement each END corresponds. For instance, in the following code it is possible to see clearly to which statement each END belongs. BEGIN IF (x>0) x=x-1; END END But this same code could have been expressed as follows: BEGIN IF (x>0) x=x-1; END END being much more complicated the reading of the program, even if for the compiler of the language both code blocks are exactly the same (the compiler will continue to interpret that the first END is that of the IF statement and the second one that of the BEGIN statement, even if they are incorrectly tabulated). ---See: Syntax ID The reserved word ID is used to obtain the identifying code of a process while executing. An identifying code is a numeric value that identifies each of the active processes at any moment (each of the game's objects). That is to say, ID is like a numeric constant, with the only difference that its value will be different for each consulted process. It is not possible to change the value of ID , as it is a simple object of reading. Normally, a process accesses this value when it intends to report to other processes its identifying code . ---See: Syntax - Identifying codes SETUP_PROGRAM This reserved word is used to designate special kinds of programs, related to the sound hardware setup . The special characteristic of these programs is that they start with the reserved word SETUP_PROGRAM instead of PROGRAM . This topic is very advanced, for expert users only. A program of this type can be observed in the SETUP directory of DIV Games Studio. These programs, once they have been compiled, will automatically be included in the installations of the rest of the programs, when the box \" Include sound setup \" is activated during the installation process. Note: In the installations, the last setup program compiled in DIV Games Studio will always be included. However, keep in mind that it is not indispensable to create sound setup programs, as the games created with DIV Games Studio will automatically detect whether the computer in which they are executed is provided with a sound card compatible with Sound Blaster or Gravis Ultrasound , providing that it is correctly configured. This kind of programs normally modify the setup global structure , that controls the parameters of the sound system. ---See: Syntax - Setup structure SIZEOF() SIZEOF( ) Returns: The numbers of elements contained in the variable. Description: The reserved word SIZEOF is used to calculate the number of elements that a table or a structure have. This reserved word is used as if it was a function of the language, indicating in brackets, the name of the variable and returning the number of elements (positions) of the latter. It can be used to obtain the number of elements of a variable but, in this case, SIZEOF will always return 1 as the number of elements (as a variable is a single element). Example program: PROGRAM example_sizeof; PRIVATE table1[]=0, 1, 2, 3; table2[]=4, 5, 6, 7, 8; variable=9; BEGIN // ... save(\"help.dat\", OFFSET table1, SIZEOF(table1)+SIZEOF(table2)+SIZEOF(variable)); // ... END - In this example, SIZEOF is used to obtain the number of elements of the following three data: table1 of 4 elements. table2 of 5 elements. variable ( 1 element). In this case, it is used to save in the help.dat file the contents of these three data with the save() function that requires the number of elements intended to be stored in the file, as a third parameter. In this case, 10 elements will be stored in the help.dat file, numbers from 0 to 9 , according to the initialisation of the data in the example. The save() statement of the previous example could have also been expressed without using SIZEOF , in the following way: save(\"help.dat\", OFFSET table1, 10); There is only one difference: if, in the program of the example, some elements were added to any of the two tables, it would be not necessary to modify the call to the save() function, as SIZEOF will always return the current size of the tables. ---See: Syntax - Declaration of a table - Declaration of a structure STEP The reserved word STEP is a part of the FROM statement and it is used to indicate the increment (step) that has to be made in every loop iteration. The FROM statement implements a loop, a group of statements that are going to be repeated a specific number of times. For that, it uses a variable as a counter of the number of repetitions. Both the initial and final values of the variable are defined. The loop will be repeated until the variable reaches the final value, starting from the initial value. By default, the variable will pass through all the whole numeric values ranging between the initial and final values. But it is possible to indicate a STEP declaration to establish a different variable increment. For instance, if a loop in which the x variable is going to have the values ranged from 1 to 10 is defined, this loop will be executed a total of 10 times. But if STEP is established as 2 , then the loop will only be executed 5 times, in which the x variable will take the 1 , 3 , 5 , 7 and 9 values, as it has been established that the variable must be incremented 2 by 2 . This loop would be implemented in the following way: FROM x=1 TO 10 STEP 2 // Statements that are going to be repeated five times END If the STEP declaration is omitted from the FROM statement, then the increment will always be 1 by 1, adding 1 to the variable after every loop iteration (or subtracting 1, in case that the final value is less than the initial value). Note: Only whole increments can be established. ---See: Syntax - FROM statement TO The reserved word TO is a part of the FROM statement and it is used to separate the constants that indicate the initial and final values that the variable used as a loop counter must take. The FROM statement implements a loop, a set of statements that are going to be repeated a specific number of times. For that, it uses a variable as a counter of the number of repetitions. Both the initial and final values of the variable are defined. The loop will be repeated until the variable reaches the final value, starting from the initial value. Example: FROM x=1 TO 10 // Statements that will be repeated 10 times END By default, the variable will take all the whole numeric values ranging between the initial and final values. But it is possible to indicate a STEP declaration to establish a different increment of the variable. ---See: Syntax - FROM statement - STEP UNTIL The reserved word UNTIL is a part of the REPEAT statement, whose syntax is, broadly speaking, the following one: REPEAT ; ... UNTIL (< condition>} ) The REPEAT statement implements a loop, it is capable of repeating a set of statements a specific number of times. The end of the statement is determined by putting the reserved word UNTIL followed by the condition that must be complied so that the statement finishes . ---See: Syntax - REPEAT statement GLOBAL STRUCT mouse STRUCT mouse; x, y; // Coordinates graph; // Graphic code file; // File code z; // Depth plane angle; // angle size; // Size (%) flags; // Mirrors indicator region; // Clipping region left, middle, right; // State of buttons cursor; // Emulation with cursors speed; // Speed of mouse END This global structure is used to control the mouse. It contains a series of fields related to the programming of this driver, such as the screen position, the pointer graphic, the state of the buttons, etc. In order to access these fields, the name of the field must be preceded by the word mouse and by the symbol . (period) . For instance, in order to access the field x (horizontal coordinate of the mouse pointer), it is necessary to use mouse.x . x , y - Horizontal and vertical coordinates of the mouse. It will be necessary to read only these two fields ( mouse.x and mouse.y ) to know the position of the mouse cursor on screen. To locate the mouse at other coordinates (to force its position), suffice will be to assign the new coordinates to these two fields. graph - Graphic code assigned as a mouse pointer. By default the mouse won't be visible . To make it visible, it is necessary to create the graphic that is going to be used as a pointer in the graphic editor , to load it in the program (with the load_fpg() or load_map() or load_pcx() functions, depending on whether this graphic has been stored in a file FPG or in an file MAP/PCX ) and finally, to assign its graphic code to this variable ( mouse.graph ). Then, the mouse pointer will be seen on screen. The centre of the graphic will appear at the mouse.x , mouse.y coordinates, unless its control point number 0 has been defined in the graphic editor . If this point (usually called hot spot ) is defined, then it will appear at the coordinates indicated in the fields mouse.x and mouse.y . For instance, if an arrow is created to depict the mouse pointer (as it happens dealing with the mouse pointer of DIV Games Studio), the hot spot (control point number 0 ) will be defined in the upper left corner of the graphic, as it is the active point inside the graphic. Then, when the mouse was located at the (0, 0) coordinates, for instance, the \" tip of this arrow \" would precisely be located at those coordinates file - File code containing the graphic. The file code containing the graphic of the mouse pointer is defined in this field. It is not necessary to indicate a value here if the graphic was loaded from an file MAP or PCX , or if it is stored in the first file FPG loaded in the program. Otherwise, mouse.file will have to be assigned the file code that returned the load_fpg() function on loading the file that contains the graphic of the mouse pointer. z - Priority of the graphic display. Indicates the depth plane in which the graphic of the mouse pointer must be displayed. By default this field will be equal to -512 , which implies that the pointer will be seen above the rest of graphics and texts . The bigger this field is, the deeper the mouse pointer will be located. If the aim was to make a graphic of a process appear above the mouse pointer, suffice would be to assign an integer lesser than -512 (for instance, -600 ) to the local z variable of that process. angle - angle with which the graphic of the mouse pointer will be seen. The value of mouse.angle by default is 0 , which implies that this graphic won't be seen rotated, unless a new angle is assigned to this field. Keep in mind that the angles must be specified in degree thousandths. For instance, the mouse.angle=90000; statement will make the pointer appear rotated 90 degrees (see the use of angles in the language ). size - Size of the graphic in percentage. By default, this field will be equal to 100 (the graphic will be seen 100%). Then, it is not necessary to indicate another value here, unless the aim is to scale the graphic (to display it expanded or reduced). If, for instance, the aim was to double the original size of the graphic (being displayed at 200%), the mouse.size=200; statement should be used. flags - In this field, different values will be indicated when the aim is to mirror the graphic of the mouse (horizontally or vertically inverted), or to display it as a (semi) transparent graphic. The possible values that can be assigned to the mouse.flags are the following ones: 0 -Normal graphic (value by default). 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Transparent and horizontal mirror. 6 -Transparent and vertical mirror. 7 -Transparent, horizontal and vertical mirror. region - Graphic's clipping region. A value must be assigned to this field just when the aim is to make the mouse pointer visible only inside a region (a rectangular zone of the screen). In order to achieve it, it is necessary first to define this region with the define_region() function and then, to assign the number of the region that has been defined to this field ( mouse.region ). By default, this value will be equal to 0 , that is a number of region referred to the entire screen. Therefore, the graphic will be seen on the whole screen. left , middle and right - These three fields store logical values ( 0 or 1 ) depending on whether the mouse buttons are pressed or not (they correspond with the left, central and right mouse buttons). Normally, only two buttons of the mouse ( left and right ) are activated, being ignored the state of the central button. This depends on the mouse driver installed in the computer. For instance, to perform an action in a program when the mouse left button is pressed ( mouse.left ), it is necessary to include the following statement in the code: IF (mouse.left) // Action to perform (statements) END cursor - indicates if the mouse emulator is active with the Cursors and Enter keys, you can move the pointer with the mouse or with the cursors. By default, this emulation will be deactivated ( mouse.cursor=0; ). If the program doesn't detect a mouse connected to the system, the emulation automatically in this case will be activated (this means, that if mouse.cursor values are 1 at the beginning of the program, then there is no mouse connected to the pc). speed - it is now possible to regulate the speed at which the mouse pointer functions in the programs. This is a value between 0 (maximum speed) and 9 (minimum), by default mouse.speed will have the value 2 . ---See: Global data GLOBAL STRUCT scroll STRUCT scroll[9]; x0, y0; // Foreground's coordinates x1, y1; // Background's coordinates z; // Depth plane camera; // Identifying code of the camera ratio; // Relative speed of the background speed; // Maximum speed of the foreground region1; // First screen region region2; // Second screen region END This 10 record structure contains certain fields related to changeable parameters of the scroll windows . These ten records have the same field names, but each of them modifies the parameters of a different scroll window (as up to 10 windows of this type can be activated). A scroll window could be defined as a screen region that only shows a part of a graphic bigger than that window (this graphic is normally the decor or background of the game). The scroll is the movement of that window through the graphic in any direction, being displayed the entire graphic little by little, section by section. For a record (from 0 to 9 ) of the scroll structure to make sense, that scroll window (from 0 to 9 ) must first be activated with the start_scroll function (for further information about the scroll windows, see this function}. It is understood that the fields of this structure are complementary to those of the call parameters of this last function. How to use the scroll structure: To access these fields, the field name must be preceded by the word scroll , the record's number in square brackets and the symbol . (period). For instance, if two scroll windows, number 0 and number 1, are initialised, it could be possible to access the camera field of both windows as scroll[0].camera and scroll[1].camera , respectively. Moreover, when the scroll window number 0 is accessed, it is possible to omit the window's number in square brackets. That is to say, the scroll.camera and the scroll[0].camera variables are, to all intents and purposes, the same for the language. A detailed description of every field is now shown. x0, y0 - Coordinates of the scroll's foreground, when the scroll ISN'T automatic (the camera field has not been defined), These are the fields that will have to be modified in order to move the scroll window's foreground . These two fields store the horizontal and vertical coordinates of the upper left corner of the scroll window (the point of the foreground's graphic that will be seen in the window's upper left corner). When the camera field of this structure has been defined, the movement of the scroll window will be automatic; thus, they are read-only fields. In order to check where the scroll is at every moment (see the move_scroll() function). x1, y1 - Background's coordinates, when a graphic for the background has been defined. When the scroll ISN'T automatic (the camera field has not been defined), these are the fields to modify in order to move the background of the scroll window . When the camera field of this structure has been defined, the movement of the scroll window will be automatic; thus, they will be read-only fields, and the definition of the background's movement speed will depend on the ratio field of the same structure. z - Scroll display priority, to indicate the depth plane in which this window must be painted, with respect to the rest of processes. By default, this variable will equal 512 , which implies that, as the processes have their local z variable at 0 by default, the scroll window will be painted in a greater (deeper) depth plane, being the graphics of the processes displayed above the window. In order to vary this situation, it is possible to modify either the z window's variable (for instance, putting it at -1 ) or the z processes' variable (for instance, putting it at 600 ). camera - It is not necessary to initialise this field, as it will be initialised when the aim is that the scroll is automatic , that the system deals with it to always follow a process (a game's graphic). For that, it is necessary to put the process' identifying code in this field. Thus, the shift of the scroll window will pass to be controlled automatically by the system, always trying to centre the graphic of this process in the window. This process must have the ctype local variable with the value c_scroll . By default, this field will equal 0 , which implies that the scroll won't follow any process, unless the identifying code of a process is assigned to camera . When it is done, this process will be known as the scroll's camera process . Note: A series of fields are now shown only for automatic scroll windows . It means that for those fields to make sense (and, therefore, effect), the camera field of this structure has to be defined previously with the identifying code of the process that is going to be centred in the scroll. These values will affect the way in which the process called scroll camera is going to be followed. ratio - Automatic scroll windows . When two scroll planes have been defined in the call to the start_scroll() function, in this field it is possible to define the movement speed of the background with respect to that of the foreground. By default, this value will equal 200 , which implies that the background will move half the speed of the foreground; if it is defined as 400 , it will move at the fourth part (four times slower), 100 at the same speed, 50 at double speed of the foreground, etc. speed - Automatic scroll windows . Maximum speed of the scroll foreground, which will equal 0 by default. It means that no speed limit is imposed. If a limit is imposed, specifying the maximum number of points that the foreground can be shifted for every game's frame, the camera process will be off centre in the scroll window when it is moved at a higher speed. region1 - Automatic scroll windows . Scroll lock region, whose value by default equals -1 , which means that there is no lock region. If this field is defined with a number of region (a rectangular zone of the screen previously defined with the define_region() function), then the system won't scroll as long as the camera process remained inside it. region2 - Automatic scroll windows . External region of the scroll. By default, its value is equal to -1 , which means that there is no external region. If this field is defined with a region's number and a maximum speed has been defined in the speed field, then the system will ignore that speed limit when the camera process is going to exceed from this region (it is done in order to continue to see the process (for its graphic to be visible always within the scroll window). Note: If the two regions ( region1 and region2 ) are defined, region 1 is normally lesser than region 2 (the first one is contained in the second one). It will imply that: The background won't shift (the scroll won't be performed) while the camera process' graphic is inside region 1. If a maximum speed has been defined, then a scroll will be performed to try to restore the graphic of the camera process to region 1, but without exceeding the imposed speed limit. If the graphic of the camera process tried to exceed from region 2, the imposed speed limit would be ignored in order not to allow it. ---See: Global data - start_scroll() - stop_scroll() GLOBAL STRUCT m7 STRUCT m7[9]; camera; // Identifying code of the camera height; // Height of the camera distance; // Distance of the camera horizon; // Height of the horizon focus; // Focus z; // Depth plane colour; // colour of the exterior END This 10 record structure contains certain fields dealing with changeable parameters of the mode 7 window . The ten records have the same fields names, but each of them modifies the parameters of a different mode 7 window (as up to 10 windows of this type may be activated). A mode 7 window could be defined as a screen region that shows a graphic plane three-dimensionally folded (for instance, like a sheet of paper with a picture horizontally positioned, displayed on screen with a virtual bottom (or top). For a record (numbered from 0 to 9 ) of the m7 structure to make sense, that mode 7 window (from 0 to 9 ) must first be activated with the start_mode7() function (see this function for further information about the mode 7 windows}. It is understood that the fields of this structure are complementary to the call parameters of this function. In order to observe a practical example of a mode 7, it is possible to access the help about the start_mode7() function. How to use the m7 structure: To access these fields, the field name must be preceded by the word m7 , the number of record in square brackets and the symbol . (period) . For instance, if two mode-7 windows, number 0 and number 1, were initialised the camera variable of both windows could be accessed as m7[0].camera and m7[1].camera , respectively. When the mode-7 window number 0 is accessed, it is also possible to omit the number of windows in square brackets. The m7.camera variable and the m7[0].camera variable are, to all ends, the same for the language. A detailed description of each field is now shown. camera - Identifying code of the process followed by the camera. To move the camera that controls the mode-7 view, only a mode-7 process must be created, a process having its local variable ctype = c_m7 , and its identifying code must be put in the camera variable of this structure. After so, only the x , y and angle local variables of this process must be modified and, for instance, the advance() function must be used to move forward the camera. For the mode 7 window to be activated, it is indispensable to initialise the camera field. Without this field, the window can not determine from where the folded plane must be seen . height - Height of the camera. This variable of the structure manages the distance to which the camera is placed from the bottom. By default, its value equals 32 . Any positive number will make the camera be placed upper as the number is greater. If a negative number (less than zero) is put in the height field of this structure, then the camera will be placed below the folded plane, showing a \" top \" instead of a \" bottom \". Two mode-7 must be created within the same region: one as top and the other as bottom (one with positive height and the other with negative height). In this case, it is important to establish the z variable of the m7 structure of both, to thus determine the depth plane in which each one must be painted. distance - Distance from the camera to the followed process. The perspective of the camera will always be positioned slightly behind the process whose identifier has been put in the camera field of the structure. This is done for the graphic of the process used as a camera to be seen, just in case this process has defined it (in its graph or xgraph local variable). By default, the camera will be positioned at 64 points behind the process. \"Behind\" means a point placed at the indicated distance from the graphic in the angle opposite to that one to which the process is orientated. For instance, if the process is facing right, 64 points to its left. horizon - Horizon's height. This is the same value as that indicated as last parameter of the start_mode7() function. Its initial value will equal to the one indicated in the call to this function. The utility of this variable is to make the horizon go up or down in every frame of the game, depending on the needs of the latter. On changing the horizon's height , the \" facing up \" and \" facing down \" effects will be obtained in the mode 7 window . focus - Focus for the camera. This variable controls the perspective of the camera. By default, its value equals 256, but any value ranging from 0 and 512 may be put, obtaining different distortion effects of the three-dimensional plane. This field controls the angle got by the camera focus. The greater this value is, the closer all the objects (processes) placed in the folded plane will be seen. z - Mode-7 display priority. To indicate the depth plane in which this window must be painted, with respect to the rest of processes. By default, this variable will equal 256 , which means that, as the processes have their local z variable at 0 by default, the mode-7 window will be painted in a greater (deeper) depth plane, being the graphics of the processes painted above the window. This situation may change by modifying the z variable of the window (for instance, putting it at -1 ) or the z variable of the processes (for instance, putting it at 257 ). colour - colour for the mode-7 exterior. When, in the call to the start_mode7() function, any external graphic is not specified (the fourth call parameter is put at 0 ), this variable will control the colour in which it is aim to paint the exterior. In other words, the colour that the screen must be painted in beyond the graphic that is being folded (beyond its limits). By default, this field is initialised at 0 , which is normally the black colour in the colour palette, Therefore, if this field is not assigned another value (and an external graphic is not defined) the screen will be seen in black beyond the foreground. ---See: Global data - start_mode7() - stop_mode7() GLOBAL STRUCT joy STRUCT joy; left; // Left control right; // Right control up; // Up control down; // Down control button1; // First button button2; // Second button button3; // Third button button4; // Fourth button END This global structure is used to control the joystick . It contains a series of logical fields related to the programming of this device: the state of the buttons (whether they are pressed or not) and the state of the main four control directions. To access these fields, the name of the field must be preceded by the word joy and the symbol . (period) . For instance, to access the left field (which indicates whether the left control is pressed), it is necessary to use joy.left . left - This field will be at 1 when the joystick is orientated to the left , and at 0 in the opposite case. right - This field will be at 1 when the joystick is orientated to the right , and at 0 in the opposite case. up - This field will be at 1 when the joystick is orientated up , and at 0 in the opposite case. down - This field will be at 1 when the joystick is orientated down , and at 0 in the opposite case. For instance, to perform an action in a program when the joystick is moved to the right ( joy.right ), a statement like the following one must be included in the code: IF (joy.right) // Action to perform (statements) END For diagonal positions, the two fields comprising this diagonal must be verified. For instance, to perform an action when the joystick is in the upper right diagonal, the following statement will be used: IF (joy.up AND joy.right) // Action to perform (statements) END button1 , button2 , button3 and button4 - These fields indicate the state of up to four joystick's buttons, being at 1 when the respective button is pressed, and at 0 , when it is not. Some joysticks only have 2 buttons. In this case, they will be buttons number 0 and 1. In computers with two connected joysticks, the second joystick will have the buttons number 2 and 3. Note: When an analogical reading of the joystick is required (to know the exact coordinates at which the joystick is located), it will be necessary to use the get_joy_position() function. Obviously, this function will only be useful in an analogical joystick , and it won't work in the digital ones. ---See: Global data - get_joy_position() - get_joy_button() GLOBAL STRUCT setup STRUCT setup; card; // Type of card port; // Access port irq; // Interruption request dma; // Direct memory access channel dma2; // 16 bit channel of access mixer; // Type of mixer rate; // Max frequency master; // Master (general) volume sound_fx; // Effects volume cd_audio; // CD audio volume END This is a very advanced data structure, which is not at all necessary to create a game, no matter how difficult it is, as DIV Games Studio's process manager will normally take charge of the sound hardware automatically. All the fields referred to the sound hardware are automatically updated by the program if you have a sound card, provided that the BLASTER or GRAVIS environment variable is properly initialised. This one record structure contains a series of fields divided into two groups: the first one, to activate new parameters of the sound hardware installed in the computer, and the second one to adjust the different volume controls managed by the sound system's mixer . Important: The reset_sound() function must be called to activate the new parameters of the sound hardware inserted in this structure (in the card , port , irq , dma and dma2 fields). The set_volume() function must be called to activate the new volume levels inserted in the structure (in the master , sound_fx and cd_audio fields). This structure is normally used inside the sound system setup programs (see setup_program ). Note: To access these fields, the field name must be preceded by the word setup and by the symbol . (period) . For instance, setup.master must be used to access the master field (which indicates the mixer's general volume level). A more detailed description of every field of this structure is now shown. card - Indicates the type of sound card installed in the computer. The program accepts cards of the Sound Blaster (tm) and Gravis Ultra Sound (tm) families, as well as all those 100% compatible with them. The values that this field can take are the following ones, depending on the sound card type: Without card or sound = 0 Sound Blaster 1.5 = 1 Sound Blaster 2.0 = 2 Sound Blaster Pro = 3 Sound Blaster 16 = 4 Sound Blaster AWE = 5 Gravis Ultra Sound = 6 Gravis Ultra Sound MAX = 7 port - Indicates the computer's communications port in which the data of the sound card must be written and read. The values that this field can take are the following ones, depending on the port assigned to the sound hardware: 0x210 = 0 0x220 = 1 0x230 = 2 0x240 = 3 0x250 = 4 0x260 = 5 irq - This field indicates the number of IRQ (Interrupt request) assigned to the active sound card. The values that this field can take are the following ones, depending on the IRQ used by the card: IRQ 2 = 0 IRQ 3 = 1 IRQ 5 = 2 IRQ 7 = 3 IRQ 10 = 4 IRQ 11 = 5 IRQ 12 = 6 IRQ 13 = 7 IRQ 14 = 8 IRQ 15 = 9 dma - The direct memory access (DMA) channel's number used by the sound card must be indicated in this field. This field can take values from 0 to 10, directly depending on the channel's number. dma2 - Some sound cards have a second direct memory access channel faster than the previous one, of 16 bits, commonly named HDMA, DMA2 or DMA16. Like in the previous field of this structure, this second channel can take values from 0 to 10 depending on the 16 bit channel's number used by the card. mixer - Type of mixer used by the sound system, can be one of these two constants: fast_mixer - Fast mixer with two sound channels (1). quality_mixer - Max quality mixer (2). By default, all programs will be initialised with the fast mixer setting activated ( setup.mixer=fast_mixer; ) because this is the faster mode. rate - Max permitted frequency (bit rate), a value between 11025 Hz (the min permitted quality of sound) and 44100 Hz (quality CD). By default, all programs are configured as 44100 ( setup.rate=44100; ), but it can be changed, because with the best quality, the sound system will be slower and will consume more processor time. The value specified in setup.rate is the max quality of sound, this means all loaded effects of sound will reconfigure to this quality if they have a better quality. This means, all effects saved to a frequency of 11025 will play with poor quality, although the max permitted frequency may be bigger. bits - Resolution of the digital effects samples and musical modules, this field can have one of these constants as its value : sound_bits_8 - 8 bit samples. sound_bits_16 - 16 bit samples. The effect is similar to the value specified in the field rate , the 8 bit sounds will sound worse (and occupy less space) than those of 16 bit quality. The value indicated in setup.bits indicates the max depth of the sample. By default, all programs activate 16 bit samples ({setup.bits=sound_bits_16;)), because the difference in quality is considerable. master - This field contains the output general or master volume of the card. A number ranging from 0 (minimum volume) and 15 (maximum volume) must be here indicated. By default, the value equals 15 , the maximum volume. Turning the master volume down will affect the sound effects' volume as well as the CD audio music reproduction's volume. sound_fx - This field controls the volume to which the sound effects executed with the sound() functions are reproduced. This volume is independent from that used with the sound functions. The former is general for all the sound effects. On the contrary, the latter (volume indicated in the functions) is specific for every sound. The values of this field also range from 0 (minimum volume) and 15 (maximum volume). By default, the value will be equal to the maximum volume. cd_audio - This field controls the volume of the music that will be reproduced from the audio tracks of a CD ROM or Compact Disc. Similar to the two previous fields, the values of this field can also rage from 0 (minimum volume) and 15 (maximum volume). By default, the value will be equal to the maximum volume. ---See: Global data - reset_sound() - set_volume() GLOBAL timer[] timer[9]; // Counters of time---. This is a 10 position global table, from timer[0] to timer[9] , and each of these 10 positions is a counter of second hundredth that is automatically incremented. At the beginning of the program, these 10 counters will be put at zero. They are use to time within a program. For that purpose, they can be put at zero at any time. There are 10 counters so that the user can dedicate each of them to perform a different action inside the game, no matter which ones of the 10 counters are used. Normally, if the program only needs one counter (most of the times), that numbered 0 ( timer[0] ) is used, as the language allows us to omit the zero in square brackets in this case. If only one counter is needed, it is possible to use timer simply. For instance, to implement a process that 5 seconds after the beginning of its execution (if it had been called) performed a specific action, it would be constructed in a way similar to the following one (by using, for instance, the counter timer[9]): PROCESS process_example(); BEGIN timer[9]=0; // ... LOOP IF (timer[9]>=500) // Action to perform ... END // ... FRAME; END END Note 1: As timing is performed in second hundredths, these counters can be incremented in 1 hundredth, 2 , 3 , 4 , etc. in every frame of the game In an example like the previous one, the user can not wait for timer[9] to equal 500 exactly, as a frame could indicate 497 hundredths passed (since it was put at zero with timer[9]=0; ) and the following frame 502 hundredths, without having passed through value 500 . Note 2: It is also important to underline that much care must be taken to prevent several processes of the program from using the same counter for different purposes. If, for instance, a process_example() (like the previous one) was created, in every frame of the game these processes would never manage to execute the action of the five seconds, as each of them would put the counter timer[9] at 0 at the beginning of their execution, thus invalidating the timing of the previous processes. Keeping in mind that the counter timer[9] is GLOBAL , it is the same for all the game's processes, if a process puts it at 0 , it will be put at 0 for the rest of the processes. Note 3: Finally, much care must be taken regarding the conditions similar to those of the previous example ( IF (timer[9]>=500) ... ), as these conditions won't only be activated once every 5 seconds , but they will be activated always after the first 5 seconds . To understand the problem better, a process performing one action, only once , five seconds after the beginning of its execution, is now shown. PROCESS process_example(); PRIVATE action_performed=FALSE; BEGIN timer[9]=0; // ... LOOP IF (timer[9]>=500) AND NOT action_performed) // Action to perform ... action_performed=TRUE; END // ... FRAME; END END A private variable called action_performed which, at first, will be false is used. To perform an action now, it will be necessary that more than five seconds have passed and that the action has not been performed yet . Therefore, after its performance the action_performed variable will become true . For the previous example to execute the action every five seconds (indefinitely), suffice will be to put the statement timer[9]=0; again after the action to perform , not being necessary, in this case, the action_performed private variable, as other 5 seconds would be necessary for timer[9] to be again bigger than or equal to 500 . ---See: Global data GLOBAL text_z text_z=-256; // Texts' depth planes---. The depth plane in which the texts must appear on screen is indicated in this global variable. It indicates what must appear above and below the text. The depth planes can be any integer within the range ( min_int ... max_int ) and, the greater the number is, the deeper the text or graphic will be placed. By default, the processes' graphics have their local z variable at 0 , the texts text_z at -256 and the mouse pointer has mouse.z at -512 by default. That means that, by default, if these values are not modified, the texts will appear above the processes' graphics and the mouse pointer above the texts. If, for instance, the aim was that the texts appeared above the mouse pointer (opposite to which has been established by default), two things could have been done: a) To place the pointer's plane lower than the texts' plane (a greater number), such as, for instance: mouse.z=-200; (as -200 is a number bigger than -256 ). b) To place the texts' plane upper that the pointer's plane such as, for instance, text_z=-600; as -600 is a number lesser than -512 and, thus, a less depth plane (less deep). Note 1: The text_z variable is GLOBAL for all the texts. It is not possible to define texts in different depth planes. Note 2: The texts can only be displayed with the write() (alphanumeric texts) function or with the write_int() (variables' numeric values) function. ---See: Global data - write() - write_int() GLOBAL fading fading=FALSE; // Indicator of screen fading---. This global variable indicates if a screen fading (a gradual change of the game's palette colours) is being performed at a specific moment. Its value will be: false (0) - If a fading is not being performed. true (1) - If a fading is being performed. The purpose of this variable is to be able to determine the end of a screen fading started with the fade() or fade_on() functions. On using these functions, a fading of the palette's colours will start, gradually coming closer to the definitive colours in the next frames of the game. In every FRAME statement a part of the fading will be performed. When a fading is started, the fading variable will automatically become equal to true (1) and when it is finished, it will recover its original value, false (0). Note 1: Generally, this variable is used to control the fade() function, and verify whether the fading has already been executed (performed). For instance, to stop the program's execution until the fading is finished, which can be done with a statement as follows (just after the call to the fade() function): WHILE (fading) FRAME; END Literally this statement defines: \" while the fading continues to be performed, a new frame must be displayed \". Note 2: All the programs perform a fading ( fade_on() ) at the beginning of their execution (automatically). Therefore, this variable will be put at true (1) at the beginning of all the programs until this initial fading doesn't finish (while the screen \" fading on \" is being performed). ---See: Global data - fade() - fade_on() GLOBAL shift_status shift_status=0; // State of the special keys---. The state of different special keys, such as [ ALT ], [ CONTROL ], etc. is indicated in this predefined global variable. Each of these keys have the following code assigned: Right SHIFT key = 1 Left SHIFT key = 2 CONTROL keys = 4 ALT and/or ALT GR keys = 8 SCROLL LOCK key = 16 NUM LOCK key = 32 CAPS LOCK key = 64 INSERT key = 128 The shift_status variable will contain the addition of all the codes of the pressed or activated keys . For instance, if the [ ALT ] key was pressed ant the [ CAPS LOCK ] was activated, the shift_status variable's value would equal 72 (8+64). In order to verify whether a key like [ ALT ] is pressed, it is not possible to check that shift_status is equal to 8 , as it would imply that [ ALT ] is the only pressed or activated special key. A correct verification would be carried out as follows: IF (shift_status AND 8 == 8) // The [ALT] key is pressed ... END Note: The key() function is normally used to verify whether a key is pressed. But it is not possible to determine with this same function whether keys such as CAPS LOCK are activated, but only if they are pressed or not. There are two variables containing the code of the last pressed key; scan_code ( scan code of the last pressed key) and ascii ( ascii code of the last pressed key). ---See: Global data - key() - ascii - scan_code GLOBAL ascii ascii=0; // ASCII code of the last pressed key---. This global variable always indicates the ASCII code of the last pressed key in the last game's frame. The ascii variable will be at 0 if no key has been pressed in the previous frame of the game. The ASCII codes are a list of characters (letters, numbers and symbols) numbered from 0 to 255 that have been standardised. The codes less than 32 are called control characters; from 32 to 127 appears the international set of characters; and from number 128, appears the expanded set of characters (according to the PC standard). The international and expanded ASCII characters are shown below. Summary of the standard PC ASCII codes. ---033 21 ! \u2502097 61 a \u2502161 A1 \u00ed \u2502225 E1 \u00df 034 22 \" \u2502098 62 b \u2502162 A2 \u00f3 \u2502226 E2 \u0393 035 23 # \u2502099 63 c \u2502163 A3 \u00fa \u2502227 E3 \u03c0 036 24 $ \u2502100 64 d \u2502164 A4 \u00f1 \u2502228 E4 \u03a3 037 25 % \u2502101 65 e \u2502165 A5 \u00d1 \u2502229 E5 \u03c3 038 26 & \u2502102 66 f \u2502166 A6 \u00aa \u2502230 E6 \u00b5 039 27 ' \u2502103 67 g \u2502167 A7 \u00ba \u2502231 E7 \u03c4 040 28 ( \u2502104 68 h \u2502168 A8 \u00bf \u2502232 E8 \u03a6 041 29 ) \u2502105 69 i \u2502169 A9 \u2310 \u2502233 E9 \u0398 042 2A \u2502106 6A j \u2502170 AA \u00ac \u2502234 EA \u03a9 * 043 2B + \u2502107 6B k \u2502171 AB \u00bd \u2502235 EB \u03b4 044 2C , \u2502108 6C l \u2502172 AC \u00bc \u2502236 EC \u221e 045 2D - \u2502109 6D m \u2502173 AD \u00a1 \u2502237 ED \u03c6 046 2E . \u2502110 6E n \u2502174 AE \u00ab \u2502238 EE \u03b5 047 2F / \u2502111 6F o \u2502175 AF \u00bb \u2502239 EF \u2229 048 30 0 \u2502112 70 p \u2502176 B0 \u2591 \u2502240 F0 \u2261 049 31 1 \u2502113 71 q \u2502177 B1 \u2592 \u2502241 F1 \u00b1 050 32 2 \u2502114 72 r \u2502178 B2 \u2593 \u2502242 F2 \u2265 051 33 3 \u2502115 73 s \u2502179 B3 \u2502 \u2502243 F3 \u2264 052 34 4 \u2502116 74 t \u2502180 B4 \u2524 \u2502244 F4 \u2320 053 35 5 \u2502117 75 u \u2502181 B5 \u2561 \u2502245 F5 \u2321 054 36 6 \u2502118 76 v \u2502182 B6 \u2562 \u2502246 F6 \u00f7 055 37 7 \u2502119 77 w \u2502183 B7 \u2556 \u2502247 F7 \u2248 056 38 8 \u2502120 78 x \u2502184 B8 \u2555 \u2502248 F8 \u00b0 057 39 9 \u2502121 79 y \u2502185 B9 \u2563 \u2502249 F9 \u2219 058 3A : \u2502122 7A z \u2502186 BA \u2551 \u2502250 FA \u2219 059 3B ; \u2502123 7B {{ }\u2502187 BB \u2557 \u2502251 FB \u221a 060 3C < \u2502124 7C | \u2502188 BC \u255d \u2502252 FC \u207f 061 3D = \u2502125 7D { }}\u2502189 BD \u255c \u2502253 FD \u00b2 062 3E > \u2502126 7E ~ \u2502190 BE \u255b \u2502254 FE \u25a0 063 3F ? \u2502127 7F \u007f \u2502191 BF \u2510 \u2502255 FF** ** 064 40 @ \u2502128 80 \u00c7 \u2502192 C0 \u2514 065 41 A \u2502129 81 \u00fc \u2502193 C1 \u2534 066 42 B \u2502130 82 \u00e9 \u2502194 C2 \u252c 067 43 C \u2502131 83 \u00e2 \u2502195 C3 \u251c 068 44 D \u2502132 84 \u00e4 \u2502196 C4 \u2500 069 45 E \u2502133 85 \u00e0 \u2502197 C5 \u253c 070 46 F \u2502134 86 \u00e5 \u2502198 C6 \u255e 071 47 G \u2502135 87 \u00e7 \u2502199 C7 \u255f 072 48 H \u2502136 88 \u00ea \u2502200 C8 \u255a 073 49 I \u2502137 89 \u00eb \u2502201 C9 \u2554 074 4A J \u2502138 8A \u00e8 \u2502202 CA \u2569 075 4B K \u2502139 8B \u00ef \u2502203 CB \u2566 076 4C L \u2502140 8C \u00ee \u2502204 CC \u2560 077 4D M \u2502141 8D \u00ec \u2502205 CD \u2550 078 4E N \u2502142 8E \u00c4 \u2502206 CE \u256c 079 4F O \u2502143 8F \u00c5 \u2502207 CF \u2567 080 50 P \u2502144 90 \u00c9 \u2502208 D0 \u2568 081 51 Q \u2502145 91 \u00e6 \u2502209 D1 \u2564 082 52 R \u2502146 92 \u00c6 \u2502210 D2 \u2565 083 53 S \u2502147 93 \u00f4 \u2502211 D3 \u2559 084 54 T \u2502148 94 \u00f6 \u2502212 D4 \u2558 085 55 U \u2502149 95 \u00f2 \u2502213 D5 \u2552 086 56 V \u2502150 96 \u00fb \u2502214 D6 \u2553 087 57 W \u2502151 97 \u00f9 \u2502215 D7 \u256b 088 58 X \u2502152 98 \u00ff \u2502216 D8 \u256a 089 59 Y \u2502153 99 \u00d6 \u2502217 D9 \u2518 090 5A Z \u2502154 9A \u00dc \u2502218 DA \u250c 091 5B [ \u2502155 9B \u00a2 \u2502219 DB \u2588 092 5C **\u2502156 9C \u00a3 \u2502220 DC \u2584** 093 5D ] \u2502157 9D \u00a5 \u2502221 DD \u258c 094 5E ^ \u2502158 9E \u20a7 \u2502222 DE \u2590 095 5F _ \u2502159 9F \u0192 \u2502223 DF \u2580 096 60 ' \u2502160 A0 \u00e1 \u2502224 E0 \u03b1 --- Therefore, an ASCII code is referred to the character that has been created with the last keystroke (or keystroke combinations, in those cases such as letters bearing a stress mark). Important: There is another predefined global variable, called scan_code , which also contains the code of the last pressed key. But, unlike ascii , this new variable stores the scan code of the key. This indicates which key has been pressed and not which character has been generated by it (like ascii ). There is a series of constants designating these keys codes (keytable scan codes). Access the help about these keys codes to observe, moreover, a sample program with the ascii and scan_code variables. The key() function of the language is normally used in order to verify whether a key is being pressed or not. This function receives one of these keys codes as a parameter, and returns 0 if the key is not pressed or 1 if it is pressed. ---See: Global data - scan_code - key() GLOBAL scan_code scan_code=0; // Scan code of the last pressed key---. This global variable always indicates the scan code of the last pressed key in the last frame of the game. The scan_code variable will be at 0 if no key has been pressed in the previous frame of the game. This variable is often used to wait in a program for the user to press any key with a statement similar to the following one: WHILE (scan_code == 0) FRAME; END This statement indicates that, while no key has been pressed in the previous frame (while scan_code equals 0 ), the frames of the game must continue to be displayed. The scan codes are simply a numeric list of the PC's keys. These codes can slightly vary (in any key) regarding different keytables, as there are keytables of different languages, with a varied number of keys, etc. However, almost all the codes of the main keys remain constant. There is a predefined list of constants (synonymous for these codes) in the language that can be seen by accessing the help about keys codes (or keytable scan codes). These numeric values will precisely be assigned to the scan_code variable when the respective keys are pressed in the program. Important: There is another predefined global variable, called ascii , which also contains the code of the last pressed key. But, unlike scan_code , this new variable stores the ASCII code (character) generated by the key. This indicates which character has been generated by the last pressed key and not which key has been pressed (like scan_code ). Access the help about the keys codes to observe a sample program with the ascii and scan_code variables. The key() function of the language is normally used in order to verify whether a key is being pressed or not. This function receives one of these keys codes as a parameter, and returns 0 if the key is not pressed or 1 if it is pressed. ---See: Global data - ascii - key() GLOBAL joy_filter joy_filter=10; // Filter applied to the joystick---. This global variable is used to define the filter applied to the read joystick's coordinates. It is defined as a percentage from 0 % to 99 % . By default, joy_filter will equal 10 (a 10% filter will be applied). The purpose of applying this filter to the joystick's coordinates is to make its movements gentler and to avoid possible \" irregularities \" in the coordinates' reading. Those joystick's coordinates must be obtained with the get_joy_position() function. The joy_filter variable will only be useful when the latter function is being used. The bigger the filter applied to the joystick is, the gentler the movements of the latter will be. But, at the same time, its answer will take longer. As the task performed by this \" filter \" is somewhat difficult to understand, an example is now shown. Example program: PROGRAM example_joy_filter; BEGIN write(0, 0, 0, 0, \"joy_filter=\"); write_int(0, 70, 0, 0, offset joy_filter); write(0, 160, 180, 1, \"The graphic is shown at the joystick's coordinates\"); write(0, 160, 190, 1, \"Use the up/down keys to vary the filter\"); load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; LOOP IF (scan_code==_up AND joy_filter<99) joy_filter++; END IF (scan_code==_down AND joy_filter>0) joy_filter--; END x=get_joy_position(0); y=get_joy_position(1); FRAME; END END - This program displays the graphic of a ball at the coordinates returned by the main joystick with the get_joy_position() function. It can be notice how, for small values of joy_filter , many \" irregularities \" appear in the reading, and for very big values (like 95%) the coordinates' read is much gentler and regular, but slightly slower. Note: It is indispensable to have a joystick (or gamepad) connected to the computer for this variable to be useful. If the joystick is connected during the program's execution, the system won't detect it (it must be connected from the beginning). See the joy_status global variable. ---See: Global data - get_joy_position() - joy_status GLOBAL joy_status joy_status=0; // State of the joystick--- The state of the joystick (or gamepad) connected to the computer is indicated in this global variable. These are the values that this variable takes by default: 0 - If the joystick reading system is disabled. This value means that a joystick connected to the computer either has not been found at the beginning of the program's execution, or has been disconnected. 1 - If the joystick reading system is active. This is the initial value by default, but if the joystick is disconnected (or there is no joystick connected), the reading system will be disabled (indicating 0 in the joy_status variable). If the system is disabled, it can be reactivated by simply assigning 1 to joy_status (with the joy_status=1; statement). But if, after a limited time, no joystick is detected, the system will be disabled again. There is a special mode in which the joystick reading system won't be ever disabled . This mode is simply defined by {assigning 2 to joy_status}. joy_status=2; // Activates special mode Nevertheless, much care must be taken as, if the joystick reading system is activated in this way, and there is no joystick connected to the computer, the game's execution may be slowed down . Note: To read the joystick in the programs, the global joy structure is normally accessed. This structure always indicates its offset and the state of its buttons (whether they are pressed or not). ---See: Global data - Joy structure - joy_filter GLOBAL restore_type restore_type=complete_restore; // Restoring type---. This global variable indicates the restoring type that must be performed after each frame on screen. The term background restoring means to recover the screen zones in which graphics have been painted or texts have been written in the previous frame. There are three applicable restoring types which directly correspond to three constants that can be assigned to the restore_type variable. no_restore - The fastest one, the background is not restored (-1) partial_restore - Average, partial restoring (0) complete_restore - The slowest one, complete restoring (1) By default, the value of restore_type equals complete_restore . If a different value is not indicated in this variable, a complete screen restoring will take place after each frame of the game. This restoring mode (complete) is the slowest one out of these three modes. Thus, it will surely be possible to gain speed in the game's execution (for it to be faster in slow computers), if a different value is assigned to this variable. For instance, the following statement must be used to indicate a partial restoring: restore_type=partial_restore; This statements orders the process' manager of DIV Games Studio to partially restore the screen background (only those screen zones where graphics or texts have been put) after the following frames of the game. The no_restore type (not restoring the screen background) is the fastest mode. However, it is only applicable when the game develops inside a scroll or mode 7 window occupying the entire screen. Otherwise, the graphics will leave signs (of the previous frames) on moving through the screen. The restoring mode can be changed under a program's execution as often as necessary, according to the requirements of the stages (or sections) under execution at each moment. Note: There is another global variable also related to DIV Games Studio's management on screen. This is called dump_type and it defines the type of frames dump that must be performed (what information must be sent to the monitor after every frame of the game). ---See: Global data - dump_type GLOBAL dump_type dump_type=complete_dump; // Type of dump--- This global variable indicates the frame dump on screen types that must be performed in every frame of the game. The term dump means that the game's frames are sent to the monitor (to the video memory of the graphic card). There are two applicable types of dump which directly correspond with two constants that can be assigned to the dump_type variable. partial_dump - When indicated with the following statement, partial dumps will be performed: dump_type=partial_dump; Only the graphics that are updated, that have changed with respect to the previous frame, will be dumped on screen in this mode. It is advisable to activate this dump in order to gain speed when a game (or one section of it) is programmed without a scroll or mode 7 window occupying the entire screen. complete_dump - When indicated with the following statement, complete dumps will be performed: dump_type=complete_dump; In this mode, the entire screen will be dumped no matter whether the graphics have changed or not. This mode is slower than the partial dump . Nevertheless, it must be used when the game has a scroll or mode 7 window occupying all the screen. By default, the value of dump_type is complete_dump . If no other value is indicated in this variable, complete dumps on the screen will be performed after each game's frame (which is normally slower than performing partial dump). The dump type can be changed during a program's execution as often as necessary, according to the requirements of the stages (or sections) under execution at each moment. Note: There is another global variable also related to DIV Games Studio's management on screen. This is called restore_type and it defines the type of restoring that must be performed on screen after every game's frame (which graphics or texts must be deleted). ---See: Global data - restore_type GLOBAL max_process_time max_process_time=500; // Maximum execution time---. Programs are provided with an anti-blocking system that will make the manager of processes of DIV Games Studio interrupts its execution when a process exceeds the maximum execution time in a game's frame. This maximum time is indicated in the max_process_time global variable in hundredths of second . By default, its value is 500 hundredths ( 5 seconds ). When a process takes longer than the indicated time in executing a FRAME statement (which indicates that the process is ready for the following frame of the game), an execution error will arise. Note: The utility of the possibility of changing this variable, assigning a new value to it, is to avoid this error in the programs in which there is a process that must be doing calculations for a long time. The following statement must be used to order the process' manager, for instance, not to interrupt a process, unless its execution in a frame is longer that 30 seconds: max_process_time=3000; As 30 seconds are 3000 hundredths of second. Important: Keep in mind that the time used by every computer to do the program's calculations is different. Therefore, this value must be defined with a certain margin, in order to avoid to exceed the maximum execution time when the game is executed in slower computers. ---See: Global data - FRAME statement LOCAL STRUCT reserved STRUCT reserved; process_id; // Identifier of the process id_scan; // Index of processes process_type; // Type of process type_scan; // Index of types status; // State of the process param_offset; // Offset of the parameters program_index; // Program counter is_executed; // executed process is_painted; // painted process distance_1; // Mode 7 reserved distance_2; // Mode 7 reserved frame_percent; // Percentage of frame box_x0, box_y0; // Beginning of the process' graphic box_x1, box_y1; // End of the process' graphic m8_object; // Object inside the world m8 old_ctype; // Old Ctype f_count; // Accumulating function counter caller_id; // Process or function caller stack_pointer; // Stack pointer for the process END In this structure, different variables of internal use (used by the manager of processes of DIV Games Studio ) are stored. They are local variables reserved for the system. It is not necessary to know these variables, as most of them are not useful to create programs. Important: The modification of the values of these variables will probably provoke crashing the computer, an incorrect working of the manager of processes or problems on using many of the internal functions. Therefore, no responsibility is assumed for the problems derived from an incorrect use of the reserved structure. A brief description of each of these fields is now shown, just for information. process_id - Identifying code of the process. This value is normally obtained with the reserved word ID and the value of this field must not be modified. id_scan - It is internally used for detecting collisions in order to save the identifying code of the last process that has collided with the current process. process_type - Type of the current process, normally obtained with the operator TYPE , later indicating the process name (see Types of processes ). type_scan - It is internally used to detect collisions or obtain identifying codes of processes of a specific type. status - Present state of the process. The values that this field can adopt are the following ones: 0 - non-existent process. 1 - process that has received a signal s_kill . 2 - alive or awake process (s_wakeup). 3 - asleep process (s_sleep). 4 - frozen process (s_freeze). param_offset - Offset of the computer's memory in which the parameters received by the process are located. program_index - Program's counter. Offset of the computer's memory in which the first statement that must execute the process in the next frame is located. is_executed - It indicates whether this process has already been executed in the current frame. is_painted - It indicates whether the graphic of the process has already been painted in the current frame of the game. distance_1 - Vertical distance of the process (reserved for processes displayed in a mode 7 window). distance_2 - Horizontal distance of the process (reserved for processes displayed in a mode 7 window). frame_percent - Percentage of the following frame completed by the process. This value will be useful when the FRAME statement is used indicating a percentage. Otherwise, it will simply be equal to 0 (0%) when the process has not been executed and 100 (100%) when it has already been executed. box_x0, box_y0 - Upper left coordinate of the graphic in the previous frame of the game (where the graphic was placed at screen coordinates). box_x1, box_y1 - Lower right coordinate of the graphic in the previous frame of the game. m8_object - number of object inside the mode 8, indicates an ordinal relative to the map of sectors. old_ctype - old value of the local variable ctype, is used to control changes in the coordinates of the process. f_count - accumulation counter of the function, to control the number of returns and level the battery for each process. caller_id - identification code of the process or function which invoked this. stack_pointer - pointer of local stack of each process, maintains the direction of the stack at the start of the process, with the stacked parameters ---See: Local data - Syntax LOCAL father father; // Identifying code of the father--- process. This is a predefined LOCAL variable, which means that each process will have its own value in its father variable. This variable always contains the identifying code of the process that created (called) the current process (the one that has this variable). Inside the language, father process is the name given to the process that calls another one. The process that has been called receives the name of son process. For further information, see the hierarchies of processes in the language. The DIV's manager of processes is the process named div_main . Its function is to create the main process of the program ( PROGRAM ) at the beginning of the game's execution. Therefore, it will be the father of the main program, as well as the father of all the processes that become orphan (processes whose father has been killed or finished before them, see states of a process ). Note: The identifying code of the son process is indicated in the predefined son local variable. ---See: Local data - Identifying code - Hierarchies of processes LOCAL son son=0; // Identifying code of the son--- process. This is a predefined LOCAL variable, which means that each process will have its own value in its son variable. This variable always contains the identifying code of the last process created (called) by the current process. Inside the language, father process is the name given to the process that calls another one. On the other hand, son process is the name given to the process that has been called. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 until the process makes a call to another process. At this moment, the new process will be created indicating its identifying code in son . Note: The identifying code of the father process is indicated in the predefined father local variable. ---See: Local data - Identifying code - Hierarchies of processes LOCAL smallbro smallbro=0; // Identifying code of the younger brother---. This is a predefined LOCAL variable, which means that each process will have its own value in its smallbro variable. This variable always contains the identifying code of the following process created by the father of the current process after it. Inside the language, younger brother is the name given to this process. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 until the father process makes a call to another process. At this moment, the new process (the younger brother of this one) will be created, indicating its identifying code in smallbro . Note: The identifying code of the elder brother is indicated in the predefined bigbro local variable. ---See: Local data - Identifying code - Hierarchies of processes LOCAL bigbro bigbro=0; // Identifying code of the elder brother---. This is a predefined LOCAL variable, which means that each process will have its own value in its bigbro variable. This variable always contains the identifying code of the process created by the father just before creating the current process after it. Inside the language, elder brother is the name given to this process. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 if the father process (the one that called the current one) has not created any other process before. If it has created one, or more than one, bigbro will indicate the identifying code of the last one. Note: The identifying code of the younger brother is indicated in the predefined smallbro local variable. ---See: Local data - Identifying code - Hierarchies of processes LOCAL priority priority=0; // Level of priority of the process---. This is a predefined LOCAL variable, which means that each process will have its own value in its priority variable. In the preparation of each frame, all the processes will be executed in the priority order established by the priority local variable. The higher the value of priority in a process is, the sooner it will be processed in each frame. The priority value may be established as any integer within the ( min_int ... max_int ) range. For instance, to establish the priority level of a process at 10 , the following statement must be used: priority=10; All the processes active in the program having the same level of priority will be executed in a undetermined order that, moreover, may vary from some executions of the game to others. By default, the priority local variable will be initialised at 0 in all the processes created in the program. Thus, it will be possible to execute them in any order, if the value of this variable is not defined. If the priority of a single process is fixed at a positive number, such as 1, it will be executed before the rest of the of the processes. On the other hand, if it is fixed at a negative number, such as -1, then it will be executed after the rest (supposing that the priority variable of the rest has not been modified, so its value is still equal to 0 ). When the processes priority must be established? --- When a process needs to use data of another process for its calculations, it is normally advisable to execute it after the latter, defining its lowest priority for the data of the second process to be updated when they are read. For instance, if process B must place its graphic 8 pixels lower than the graphic of process A , the priority of A must be greater than that of B , for the latter to be executed first. Thus, when process B obtains its y coordinate by adding 8 to the one of process A , this calculation is done with the y coordinate of process A already updated for the following frame (to ensure that in each frame, the y coordinate of process A first, and then that of process B will be established). For that purpose, suffice would be to define either the priority of A as 1 or the priority of B as -1 , since by default both priorities are at 0 . Note: The priority level of the process has nothing to do with the depth plane in which its graphic appears on screen, as this plane is indicated in the local z variable. ---See: Local data LOCAL ctype ctype=c_screen; // System of coordinates---. This is a predefined LOCAL variable, which means that each process will have its own value in its ctype variable. The system of coordinates used by the process is indicated in this variable. It is possible to use three different systems of coordinates, directly corresponding with three constants that can be assigned to the ctype variable. c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - Mode 8 coordinates By default, the ctype value is c_screen , used for the process' graphic coordinates to be interpreted as referred to the screen, where the upper left corner is (0, 0). With the following statement, c_scroll will be assigned to ctype : ctype=c_scroll; For the process' graphic coordinates to be interpreted as referred to a scroll window, with coordinates located above the foreground's graphic. With the following statement, c_m7 will be assigned to ctype : ctype=c_m7; For the process graphic coordinates to be interpreted as referred to a mode 7 window, with coordinates located above the main graphic, three-dimensionally folded in that window. c_m8 will be assigned to ctype with the following statement: ctype=c_m8; For the coordinates of the process graphic to be interpreted as referred a mode 8 window, with coordinates located above the main graphic, three-dimensionally folded in that window. Note: There is another local variable that also affects the way in which the process coordinates must be interpreted, This variable is resolution , which establishes the resolution (scale) in which the coordinates are defined. ---See: Local data - c_screen - c_scroll - c_m7 - c_m8 LOCAL x x=0; // Horizontal coordinate of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its x variable. The x and y local variables of the processes define where their graphic (defined in the graph local variable) must be placed. The x local variable defines the process' horizontal coordinate , which may be defined as an integer within the range ( min_int ... max_int ), putting the positive coordinates to the right and the negative ones, to the left. By default, these coordinates will be specified in pixels , referred to screen coordinates, where the upper left corner is the point placed at ( 0 , 0 ). Type of coordinates. --- There are several systems of coordinates that may be used by the processes and that are defined with the ctype local variable. The coordinates related to the screen are the system by default. Resolution of the coordinates. --- The resolution local variable indicates the precision of the process coordinates. By default, this variable will be equal to 0 and the ( x , y ) coordinates will be specified in pixels. The higher the value of resolution is, the smaller (and more precise) the drive in which the coordinates are interpreted will be. Some examples are now shown: resolution=1; - The coordinates are specified in pixels. resolution=10; - They are specified in tenths of pixels. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixel. ... Note: A different type and resolution of coordinates may be either defined for each process or changed while executing if necessary. Important: When a graphic is placed at some specific coordinates, it is the graphic centre that will normally be placed at these coordinates. This can be changed by defining in the graphic editor the control point number 0 of the graphic of the process (whose graphic code is indicated in the graph variable). If the control point has been defined, it will be placed at the specified coordinates. For instance, if control point number 0 is placed in the upper left corner of the graphic, and then, the graphic is put at the (100, 100) coordinates, the upper left corner of the graphic will be placed at these coordinates. ---See: Local data - ctype - resolution LOCAL y y=0; // Vertical coordinate of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its y variable. The x and y local variables of the processes define where their graphic (defined in the graph local variable) must be placed. The y local variable defines the process' vertical coordinate , which may be defined as an integer within the range ( min_int ... max_int ), placing the positive coordinates downwards and the negative ones, upwards. By default, these coordinates will be specified in pixels , referred to screen coordinates, where the upper left corner is the point placed at ( 0 , 0 ). Type of coordinates. --- There are several systems of coordinates that may be used by the processes and that are defined with the ctype local variable. The system by default defines the coordinates related to the screen. Resolution of the coordinates. --- The resolution local variable indicates the precision of the process coordinates. By default, this variable will be equal to 0 and the ( x , y ) coordinates will be specified in pixels. The higher the value of resolution is, the smaller (and more precise) the drive in which the coordinates are interpreted will be. Some examples are now shown: resolution=1; - The coordinates are specified in pixels. resolution=10; - They are specified in tenths of pixels. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixels. ... Note: A different type and resolution of coordinates may be either defined for each process or changed while executing if necessary. Important: When a graphic is placed at some specific coordinates, it is the graphic centre that will normally be placed at these coordinates. This can be changed by defining in the graphic editor the control point number 0 of the graphic of the process (whose graphic code is indicated in the graph variable). If the control point has been defined, it will be placed at the specified coordinates. For instance, if control point number 0 is placed in the upper left corner of the graphic, and then, the graphic is put at the (100, 100) coordinates, the upper left corner of the graphic will be placed at these coordinates. ---See: Local data - ctype - resolution LOCAL z z=0; // Depth plane of the process graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its z variable. The z local variable defines the depth plane in which the process graphic must be placed on screen (the graphic is defined in the graph local variable). Any integer within the range ( min_int ... max_int ) may be used as a depth plane. The greater the number is, the deeper the graphic will be placed. By default, the depth planes are arranged in the following way: ** (+) Greater depth** ** +512** - Scroll windows (see scroll[].z ) ** +256** - Mode 7 windows (see m7[].z ) ** 0 - Graphics of the processes (local z**) ** -256** - Texts (see text_z ) ** -512** - Mouse pointer (see mouse.z ) ** (-) Less depth** The z local variable that defines the depth plane of the processes' graphics will be initialised at 0 . The processes' graphics will be placed below the mouse pointer and texts, and above the scroll and mode 7 windows (if the values are not modified by default). All the objects (texts, graphics, windows, ...) placed in the same depth plane will appear on screen (on being superimposed) in an undetermined order , that may vary from some program's executions to some others. If the aim was, for instance, that the graphic of a process appeared above all the objects of the program, a depth plane could be fixed for it above the rest (as -1000}, with the following statement: z=-1000; At the beginning, all the processes have their z variable at 0 , then the graphic of the processes will appear in any order if the plane in which each of them must be placed is not defined. The depth plane of a process may be modified (by assigning a new value to its z variable) as often as necessary inside a program. The depth planes of the rest of the objects (windows, texts and mouse pointer) may also be modified at any stage of the program. Note 1: The processes that belong to a scroll window (having its variable ctype = c_scroll ) will be painted in the depth plane of the scroll window . Nevertheless, inside that window, all the graphics of the processes will appear in order, according to their depth plane . The process' depth plane (indicated as usual in the z variable) will be referred to the scroll window in which the process appears (see start_scroll() ). Note 2: The processes that belong to a mode 7 window (having its variable ctype = c_m7 ) will appear in that window in order, according to the depth order in the three-dimensional plane ignoring the value of their z local variable. The only sense of the z local variable in mode 7 processes is to define the order in which the processes exactly placed at the same coordinates of the folded plane must be superposed. If two processes are placed in the three-dimensional plane at the same coordinates, then it will be possible to define, through the z variable, which one must appear above the other (see start_mode7() ). ---See: Local data - mouse.z - scroll[].z - m7[].z - text_z LOCAL graph graph=0; // Code of the process graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its graph variable. Normally, most of the processes correspond with a graphic object displayed on screen that will be placed at the indicated coordinates in the x and y local variables. It is necessary to define which graphic corresponds with this process by assigning a graphic code to the graph local variable. By default, this variable will be equal to 0 , which implies that no graphic will be displayed for this process. The graphics must first be created in the graphic editor of DIV Games Studio (with the option \" New... \" of the maps menu) and then, they can be saved in an file MAP (containing this graphic), or in a file FPG together with other graphics (it is possible to create a new file with the option \" New... \" of the files menu). The graphics used in a program may come from an file MAP (that contain just one graphic) or from a file FPG (that may contain many graphics). Note: The same graphic may be used in a program by many processes at the same time. files MAP or PCX --- In order to use a graphic from an file MAP in the program, it must be loaded by calling the load_map() or load_pcx() function, which will return the graphic code that must be assigned to the graph variable. A GLOBAL variable is normally used to save this graphic code and then, it is assigned to the graph variable. Example program: PROGRAM example_graph; GLOBAL graphic1; BEGIN graphic1=load_map(\"help/help.map\"); graph=graphic1; // The graphic of the process is defined. LOOP x=mouse.x; y=mouse.y; FRAME; END END - Even if in the previous example, the graphic1 global variable could have been omitted, having directly assigned the code returned by the load_map() function to the graph variable with the following statement: graph=load_map(\"help/help.map\"); the graphic code returned by this function are simply integers from 1000 . Files FPG --- In order to include a graphic that has been done in the graphic editor in a file FPG , it is necessary to drag the graphic window to the file window (click on the graphic, move to the file and release). Then, the program will ask for the graphic code , so an integer ranging from 1 and 999 must be included here. Thus, to use the graphic in a program, the file FPG that contains it must first be loaded with the load_fpg() function, assigning then the graphic code to the graph variable. An example is now shown. Before, it is necessary to know that a brown ball graphic was stored in the file HELP.FPG indicating the graphic 100 code . Example program: PROGRAM example_graph; BEGIN load_fpg(\"help/help.fpg\"); graph=100; // The graphic of the process is defined. LOOP x=mouse.x; y=mouse.y; FRAME; END END - Several files FPG can be loaded in a program. In this case, it will be necessary to indicate, besides the graphic code in the graph local variable, the file code returned by the load_fpg() function in the file local variable. It won't be necessary if only one file is loaded, as the file variable equals 0 by default in all the processes and 0 will always be the first file's code loaded in the program. There are more local variables related to the graphic of a process. The most important ones are mentioned below: graph - Graphic code file - File code x , y - Graphic coordinates z - Depth plane angle - graphic angle size - graphic size flags - Mirrors and transparencies region - Display window ---See: Local data LOCAL flags flags=0; // Indicator of mirrors and transparency---. This is a predefined LOCAL variable, which means that every process will have its own value in its flags variable. The flags local variable indicates the mirrors and transparencies of the displayed graphic in the processes. The possible values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Transparent and horizontal mirror. 6 -Transparent and vertical mirror. 7 -Transparent, horizontal and vertical mirror. By default, the value of the flags variable is 0 . If it is not modified, the graphic will be displayed opaque (not transparent or mirror). The terms mirror and transparency are now defined: Horizontal mirror , the graphic will be horizontally flipped. If it was facing left, it will face now right and vice versa. Vertical mirror , the graphic will be vertically flipped. If it was facing up, it will face now down and vice versa. Transparency (or ghost-layering ), the graphic will be displayed semi-transparent. It will be possible to see what is placed behind the graphic, as if it was a coloured window, unlike the opaque graphics normally displayed. For instance, the following statement must be used to display a transparent graphic of a process: flags=4; Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data LOCAL size size=100; // Size (percentage) of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its size variable. The size local variable defines the size in which the graphic of the process must be seen. This size is a percentage related to its original size. By default, the value of this variable will be equal to 100 (100%) for all the processes, and when the graphic is modified, it will scale (reducing or expanding its size) to adjust to the new size. To double the size of the graphic displayed, it will be necessary to specify 200% . The following statement will be used for this purpose: size=200; Therefore, if this value is lesser than 100 , the graphic will be seen smaller; otherwise, it will be seen bigger. At first, there is no limit for the graphic size, but if the size local variable is put at 0 (0%), then the graphic of the process won't be seen. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data LOCAL angle angle=0; // angle of the process' graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its angle variable. The angle local variable defines the angle in which the graphic of the process must be seen, indicating an angle with regard to the original graphic in degree thousandths (see Use of angles in the language ). By default, the value of this variable will be equal to 0 (0 degrees) for all the processes, but when the graphic is modified, it will rotate to adjust to the new angle. The angle may be defined as any integer within the range ( min_int ... max_int ). Some examples of the angles that define certain values in the angle local variable are now shown (keep in mind that the angles are expressed in degree thousandths ): ... ** -180000** - Angle to the left ** -90000** - Angle downwards ** -45000** - Angle of the diagonal down/right ** 0** - Angle to the right ** +45000** - Angle of the diagonal right/up ** +90000** - Angle upwards ** +180000** - Angle to the left ** +270000** - Angle downwards ... Important: When the aim is to rotate the graphic of a process, it is advisable to paint it orientated to the right , as it will be displayed like this by default (with the angle local variable equal to 0 ). Thus, when another angle is specified, the graphic will appear exactly orientated towards it. For instance, a graphic that has been drawn to the right can be seen orientated upwards (to the angle of 90 degrees) by indicating the following statement: angle=90000; // 90 degree thousandths (90 degrees). If a graphic was painted orientated towards another angle, (for instance, downwards), it would become orientated downwards by default, in the angle 0 , which can provoke confusions when it comes to orientating the graphic towards another angle. To make the graphic of a process advance its coordinates ( x , y ) towards its angle (the one specified angle in the local variable of the process) a specific distance, the advance() function can be used. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data - Use of angles in the language LOCAL region region=0; // Screen region assigned to the process---. This is a predefined LOCAL variable, which means that each process will have it own value in its region variable. The region local variable defines the zone of the screen in which the graphic of the process must be visible, indicating the number of region . A region is a rectangular zone of the screen, such as a window, associated to a number. By default, this variable will be equal to 0 in all the processes, making reference to region number 0 that is the entire screen . By default the graphics of the process will be visible in the whole screen (at any point of the screen in which they are placed). At the beginning, only region number 0 is defined. To define new screen regions, it is necessary to use the define_region() function. For instance, for the graphic of a process to be visible only inside a 100 by 100 pixel box placed in the upper left corner of the screen (at the coordinates 0, 0), first the new region should be defined in the following way, supposing that region number 1 is defined: define_region(1, 0, 0, 100, 100); and then, the number of region ( 1 ) should be assigned to the region local variable of the process with the following statement: region=1; The regions may be redefined at any moment inside a program. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data - define_region() LOCAL file file=0; // File code of the process' graphic---. This is a predefined LOCAL variable, which means that every process will have its own value in its file variable. In the case that several graphics files files FPG have been loaded in a program, the file local variable indicates which file contains the graphic that the process is using. The graphic of a process must be indicated by assigning a graphic's code to the graph local variable. If just one file has been loaded in the program, it won't be necessary to assign any value to file , as the code of the first loaded file will equal 0 and this is the value of the variable by default. If the graphic has been loaded with the load_map() or load_pcx() function, it won't be necessary to assign any value to file either, as the graphics loaded with this function are used as if they belonged to file number 0 (to the first one that is loaded in the program). When more than a file is loaded, it is necessary to indicate in each process in which one its graphic is stored. It is done by assigning the file code returned by the load_fpg() function (on loading this file FPG ) to the file local variable. Note: Normally, if several files are sequentially loaded in a program, the first one will have the code 0 , the second, the code 1 , the third, the code 2 and so on. In general, if several files are used, it is a good practice to have the same number of global variables (named, for instance, file1 , file2 , ...) containing the code of each of the files, to use them in the processes when it comes to defining its file variable (the file FPG that must be used). The variables would be defined inside the section GLOBAL in the following way: GLOBAL file1; // First file's code file2; // Second file's code ... Next, these variables would be assigned the file codes on loading them with the load_fpg() function in the following way (supposing that the names of the files is name1.fpg , name2.fpg , etc.): file1=load_fpg(\"name1.fpg\"); // Files loading file2=load_fpg(\"name2.fpg\"); ... These files are generally loaded at the beginning of the program. Later, the used file would only have to be defined inside each process with the following statement (supposing that the process uses graphics stored in the file name1.fpg ): file=file1; // The first file is used Note: Keep in mind that defining the file local variable is futile, unless a graphic's code is assigned to the graph local variable. ---See: Local data LOCAL xgraph xgraph=0; // OFFSET of the process' graphic table---. This is a predefined LOCAL variable, which means that each process will have its own value in its xgraph variable. This is an advanced level variable. Thus, its use requires certain experience. The xgraph local variable ( extended graphic ) allows us to use multiple graphics . This variable is used to define the graphic of a process as a graphics set among which it is necessary to see the most appropriate with the process' angle (specified in the angle local variable). If the xgraph variable is defined, the graph local variable which normally defines the graphic of the process will be ignored and one graphic or another will be used depending on the angle variable. Therefore, on changing the process' angle the graphic of the process won't appear rotated , but it will use this angle to select the process' graphic (inside the defined set). By default the xgraph variable will equal 0 in all the processes, which indicates that they are not going to use multiple graphics . The utility of the multiple graphics lies on the possibility of creating games in perspective , where the change of an angle in the process doesn't implied a rotation of its graphic, but the replacement of the graphic by another one painted in a different perspective (painted with another angle inside that perspective). How to use the multiple graphics. --- 1 - First, the different pictures that are going to represent the process' graphic have to be painted with different angles in perspective. The latter will be a finite number of graphic's views, such as 4 , 8 , 12 , etc., (or any other integer bigger than 1 ). Take into account that if 4 views are defined, a different view will be defined every 90 degrees, if 8 views are defined, every 45 degrees, etc. 2 - It is necessary to put these graphics in order according to their angles. First, the graphic corresponding with angle 0 (towards the right) and then, the rest in a clockwise direction. 3 - A table, generally GLOBAL , must be created and initialised with the following values: Number of graphic's views , Graphic's code for angle 0 (first view) , Code of the following angle (second view) , ... Note: This table must contain simple data (of type INT , 32-bit whole numbers with sign). The name given to this table makes no difference. For instance, if a multiple graphic is defined with 4 views, which must be the graphics with the codes 10, 11, 12, and 13, the definition of the table could be as follows: GLOBAL table_graphic1[]=4, 10, 11, 12, 13; .... 4 - Finally, the offset of this table must be assigned inside the computer's memory to the xgraph local variable of the process, which is done with the following statement (inside the process in question): xgraph=OFFSET table_graphic1; The OFFSET operator is used to obtain the offset of a program's variable in the memory. Once the multiple graphic has been defined, in each frame of the game the system will use the graphic corresponding with the angle closest to the process' angle (the one indicated in its angle variable). The xgraph variable must be put at 0 again in order to disable the multiple graphic system in a process, Important: If any graphic's code is put with a negative sign inside the table that defines the set of graphics, then this graphic will appear horizontally flipped . If the graphic was facing right, it will appear facing left, and vice versa. Note: The multiple graphic system is normally used in mode 7 windows , as in the folded three-dimensional plane the graphics must be seen in a different way, according to the angle from which they are observed. For further information about this technique, see the start_mode7() function used to activate a mode 7 window in the program. ---See: Local data LOCAL height height=0; // Graphic's height (in mode 7)---. This is a predefined LOCAL variable, which means that each process will have its own value in its height variable. The local height variable is exclusively used in the processes that belong to mode 7 windows . That is to say, processes that have their coordinates' system inside a three-dimensional window (its local variable ctype = c_m7 ). It is used to define the height at which the graphics of the processes must be placed above the three-dimensional plane. The local z variable is not used for this purpose, as it is used to define the depth plane of the graphics (even if it is now useful only for processes placed at the same coordinates). The height of the process can be defined as any integer within the ( min_int ... max_int ) range, even if positive numbers are normally used, as the height of the bottom is 0 and processes are placed above it. By default, the value of the height variable is 0 for all the processes, which means that if another value is not specified, the graphics of the processes will appear just above the bottom of the mode 7 (above the plane three-dimensionally folded). The graphic's base will first be placed in the indicated height of the process, unless control point number 0 is defined. In this case, this point will be placed in that height. Note: For further information about the mode 7 windows and how to place graphics inside these windows, see the help about the start_mode7() function, which is used to activate them in the program. This variable can be used for any other purpose in the non mode 7 processes, as the system will completely ignore it. ---See: Local data - start_mode7() LOCAL cnumber cnumber=0; // Number of scroll or mode 7 windows---. This is a predefined LOCAL variable, which means that each process will have its own value in its cnumber variable. The local cnumber variable is exclusively used when, in a game, several scroll windows or several mode 7 windows simultaneously appear on screen. For further information about the scroll windows , see the help about the start_scroll() function, which is used to activate them in the program. For further information about the mode 7 windows , see the help about the start_mode7() function, which is used to activate them in the program. The cnumber utility lies on indicating in which of these windows the graphic of the process must be seen . Obviously, this variable must be defined only in processes visible inside the scroll windows or the mode 7 windows . This variable is useless for the rest of the processes (screen processes or processes with no graphics). If the process must be seen in all the windows , then it won't be necessary to modify this variable, as the value of cnumber ( 0 ) by default precisely indicates so. Up to 10 windows of both types may be activated, numbered from 0 to 9 . There are ten predefined constants used to define the value of cnumber . These are c_0, c_1, c_2, ..., c_9 and directly correspond with the 10 possible windows of these types. cnumber must be assigned the addition of the constants corresponding with the windows in which the process must be visible . For instance, if there are 4 scroll windows numbered 0 , 1 , 2 and 3 in a program, and the aim is to define that a specific process must be only visible in windows 0 and 2 , the following statement must be used: cnumber=c_0+c_2; The value of cnumber can be changed during the process execution if necessary. Note: Keep in mind that for the graphic of the process to be seen in all the windows, it is not necessary to do anything, as it is the option by default. ---See: Local data - c_0...c_9 LOCAL resolution resolution=0; // Resolution of the process coordinates---. This is a predefined LOCAL variable, which means that each process will have its own value in its resolution variable. Normally, the coordinates of a process (indicated in the x and y local variables) are defined in screen pixels. The resolution local variable must be used when the aim is to define the coordinates in drives smaller than the pixel. That is to say, this variable indicates the precision of the process' coordinates. By default, the variable will equal 0 and the coordinates will be specified in pixels. The greater the value of resolution is, the smaller (and more accurate) the drive in which the coordinates are interpreted will be. Some examples are show below: resolution=1; - The coordinates are specified in pixels (similar to resolution=0 , which is the value by default). resolution=10; - They are specified in tenths of a pixel. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixels. ... For instance, a process located at 160 , 100 with resolution equal to 0 (or 1 ), will be in the same position as a process located at 1600 , 1000 and with resolution equal to 10 . The value of resolution is normally defined as a positive integer multiple of 10 (10, 100, 1000, ...). In short, when the value of resolution is defined, the processes' manager of DIV Games Studio will divide the coordinates of the processes between resolution when it comes to painting their graphics on screen. Important: Much care must be taken when, in a program, there are several processes with different resolutions of coordinates, as some functions, such as get_dist() (used to obtain the distance between two processes), will return incorrect results when two processes using different resolution of coordinates are accessed. It is normally advisable that all the processes active in the game, at least all that interact (that are detected, modified or that can be collide) use the same resolution. ---See: Local data Control points. The control points are defined inside the graphic editor with the bar of control points, indicated with this icon. - - --- In order to access the graphic editor , suffice will be to \" double-click \" with the left mouse button on a graphic inside the environment (on a map window). The control points are simply points that can be placed inside a graphic for different purposes. The bar of control points allows us to position up to 1000 different points inside a graphic. Each of them will be identified by its number (from 0 to 999 ). In order to position one of these points, suffice will be to select the {number of point} with the left arrow and right arrow icons and then, to click on the graphic. In order to delete (unselect) a control point, it is necessary to click on the same graphic a second time. The only control point used by the system is control point number 0 (the first one). This point defines which is the virtual centre of the graphic and has many applications inside the language. When control point number 0 is not defined, the system will work as if the graphic's virtual centre was its real centre (a point located at half the width and height of the graphic). Note: Once the control points have been defined, for them to have effect in a program, it is necessary to save the file MAP or include the graphic again in the file FPG by dragging the former to the latter (depending on which one of both is loaded in the program). Videomodes Constants: m320x200 ... m1024x768 These constants are used to indicate the videomode in the set_mode() function. The whole list of constants is the following one: m320x200 m320x240 m320x400 m360x240 m360x360 m376x282 m640x400 m640x480 m800x600 m1024x768 Each constant indicates the videomode in the following way: first, the letter m and then, the horizontal and vertical resolution of the mode, separated by an x . The values defined for these constants are the following ones. m320x200 = 320200 m320x240 = 320240 m320x400 = 320400 m360x240 = 360240 m360x360 = 360360 m376x282 = 376282 m640x400 = 640400 m640x480 = 640480 m800x600 = 800600 m1024x768 = 1024768 Note: Besides these standard video modes, the global structure video_modes contains a list of all modes compatible with the VESA standard situated in the system's video adaptador. ---See: Constants - set_mode() - video_modes true Constant: true This constant is used to indicate true values, to initialise logical variables or to define logical parameters. That is to say, it must be evaluated as a condition. Its value is 1 and, as in the language all the odd numbers are interpreted as true , this constant will be evaluated as a condition that is always complied ( true ). The false constant is opposite to this one, and it is used to indicate logical false values. ---See: Constants - false false Constant: false This constant is used to indicate false values, to initialise logical variables or to define logical parameters. That is to say, it must be evaluated as a condition. Its value is 0 and, as in the language all the even numbers are interpreted as false , this constant will be evaluated as a condition that is never complied ( false ). The true constant is opposite to this one, and it is used to indicate logical true values. ---See: Constants - true s_kill Constant: s_kill This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 0 . This signal transmits the imperative order kill to the processes. It is used to eliminate processes in the program (to make certain objects of the game disappear). That is to say, on sending a signal s_kill to a process, the latter will be eliminated and will not appear any longer in the following frames of the game. The constant s_kill_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will eliminate the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_kill_tree s_wakeup Constant: s_wakeup This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 1 . This signal transmits the imperative order wakeup to the processes. It is used to restore the processes that have been made dormant (with the signal s_sleep ), or frozen (with the signal s_freeze ) to their normal state. That is to say, on sending a signal s_wakeup to a process, the latter will be reactivated in the following frames of the game (it will be seen and processed again). The constant s_wakeup_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will wake up the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_wakeup_tree s_sleep Constant: s_sleep This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 2 . This signal transmits the imperative order sleep to the processes. It is used to make a process dormant. An asleep process will not appear in the following frames of the game, but it won't be eliminated, as it happens with the signal s_kill . Indeed, this kind of process may wake up at any moment with a signal s_wakeup . That is to say, on sending a signal **s_sleep ** to a process, the latter will not appear in the following frames of the game (until it is awaken or eliminated). The constant s_sleep_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will make dormant the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_sleep_tree s_freeze Constant: s_freeze This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 3 . This signal transmits the imperative order freeze to the processes. It is used to freeze (immobilise) a process. A frozen process will continue to appear in the following frames of the game, but it won't be processed, so it will remain immobile. This process can be reactivated at any moment if a signal s_wakeup is sent to it. That is to say, on sending a signal s_freeze to a process, the latter will stop processing (stop interpreting its statements) in the following frames of the game (until it is activated or eliminated with s_kill ). The constant s_freeze_tree is directly linked to this constant, with the proviso that, on sending this signal, the indicated process as well as its sons (which are the processes created by it) will be frozen. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_freeze_tree s_kill_tree Constant: s_kill_tree This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 100 . This signal is used to eliminate a process and all the process created by it, by sending the imperative order kill to them. This is a version of the signal s_kill , which eliminates a process, but not the processes that it had created. That is to say, the signal s_kill_tree will eliminate the process and all its descendants. Thus, none of them will appear any longer in the following frames of the game. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_kill s_wakeup_tree Constant: s_wakeup_tree This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 101 . This signal is used to wake up a process and all the processes created by it, by sending the imperative order wakeup to them. This is a version of the signal s_wakeup , which wakes a process up, but not the processes that it had created. That is to say, the signal s_wakeup_tree will wake up the process and all its descendants. Thus, all these processes will return to their normal state in the following frames of the game. Processes that have been made dormant with the signal s_sleep_tree or frozen with the signal s_freeze_tree can be woken up (reactivated). The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_wakeup s_sleep_tree Constant: s_sleep_tree This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 102 . This signal is used to make a process and all the processes created by it dormant , by sending the imperative order sleep to them. This is a version of the signal s_sleep , which makes a process dormant, but not the processes that it had created. That is to say, the signal s_sleep_tree will make the process and all its descendants dormant. Thus, all these processes will disappear in the following frames of the game (but they won't be eliminated). These asleep processes can be woken up (reactivated) with the signal s_wakeup_tree . The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_sleep s_freeze_tree Constant: s_freeze_tree This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 103 . This signal is used to freeze (immobilise) a process and all the processes created by it, by sending the imperative order freeze to them. This is a version of the signal s_freeze , which freezes a process, but not the processes that it had created. That is to say, the signal s_freeze_tree will freeze the process and all its descendants. Thus, all these processes will stop processing in the following frames of the game (they will remain immobile, as they won't execute their statements). These frozen processes can be unfrozen (reactivated) with the signal s_wakeup_tree . . The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_freeze all_text Constant: all_text This constant is used as a parameter of the delete_text() function, to delete all the texts displayed in the program with the write() and write_int() functions. That is to say, the following statement must be executed in order to make disappear all the texts displayed on screen: delete_text(all_text); The value assigned to this constant is 0 . ---See: Constants - delete_text() all_sound Constant: all_sound This constant is used as a parameter of the stop_sound() function, to stop all the sound effects previously activated with the sound() function. That is to say, the following statement must be executed in order to stop all the sound channels, active at a specific moment: stop_sound(all_sound); The value assigned to this constant is -1 . ---See: Constants - stop_sound() - sound() g_wide Constant: g_wide This constant is used as a parameter of the graphic_info() function, to ask for information about the width (in pixels) of a specific graphic. Its value is 0 . The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info() g_height Constant: g_height This constant is used as a parameter of the graphic_info() function, to ask for information about the height ** (in pixels) of a specific graphic. Its value is 1**. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info() g_x_centre Constant: g_x_centre This constant is used as a parameter of the graphic_info() function, to ask for information about the horizontal centre of a specific graphic. Its value is 2 . The horizontal centre of a graphic will be half the width (in pixels), if control point number 0 (graphic centre) has not been defined in the painting tool. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info() g_y_centre Constant: g_y_centre This constant is used as a parameter of the graphic_info() function, to ask for information about the vertical centre of a specific graphic. Its value is 3 . The vertical centre of a graphic will be half the height (in pixels), if the control point number 0 (graphic centre) has not been defined in the painting tool. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info() c_screen Constant: c_screen This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 0 . This is the value by default of ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to the screen. The (0,0) coordinate is the upper left corner. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype c_scroll Constant: c_scroll This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 1 . This is the value assigned to ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to a scroll window, to coordinates with respect to the foreground's graphic. For further information about the scroll windows , it is possible to access the start_scroll() function used to activate them. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype - start_scroll() c_m7 Constant: c_m7 This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 2 . This is the value assigned to ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to a mode 7 window, three-dimensionally folded in that window. For further information about the mode 7 windows , it is possible to access the start_mode7() function used to activate them. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype - start_mode7() partial_dump Constant: partial_dump This constant is used to be assigned to the predefined dump_type global variable used to define the type of dump that will be performed on screen. Its value is 0 . The following statement is used: dump_type=partial_dump; This statement indicates to the manager of processes of DIV Games that the following dumps must be partial . Dump is the name given to the system of sending the game frames to the monitor (to the video memory of the graphics card). There are two types of dumps: Partial : Only the graphics that are updated and that have varied with regard to the previous frame will be dumped on screen. It is advisable to activate this dump in order to gain speed when programming a game (or a section of it) without a scroll or mode 7 window occupying the whole screen. That is to say, either when the game shows graphics movements against a fixed background or when the active scroll or mode 7 windows are smaller that the screen. Complete : All the screen will be dumped, irrespective of whether the graphics have changed or not. This is the dump by default and it is slower that the partial dump . However, the complete dump must be used when the game has a scroll or mode 7 window occupying the whole screen. The other constant used to designate the type of dump is complete_dump which, unlike this one, defines a complete dump. ---See: Constants - dump_type - complete_dump complete_dump Constant: complete_dump This constant is used to be assigned to the predefined dump_type global variable used to define the type of dump that will be performed on screen. Its value is 1 . This is the value by default of the dump_type variable. To establish this value, it is necessary to use the following statement: dump_type=complete_dump; This statement indicates that the following dumps must be complete to the manager of processes of DIV Games. Dump is the name given to the system of sending the game frames to the monitor (to the video memory of the graphics card). There are two types of dumps: Partial : Only the graphics that are updated and that have varied with regard to the previous frame will be dumped on screen. It is advisable to activate this dump in order to gain speed when programming a game (or a section of it) without a scroll or mode 7 window occupying the whole screen. That is to say, either when the game shows graphics movements on a fixed background or when the active scroll or mode 7 windows are smaller that the screen. Complete : All the screen will be dumped, irrespective of whether the graphics have changed or not. This is the dump by default and it is slower that the partial dump . However, the complete dump must be used when the game has a scroll or mode 7 window occupying the whole screen. The other constant used to designate the type of dump is partial_dump which, unlike this one, defines a partial dump. ---See: Constants - dump_type - partial_dump no_restore Constant: no_restore This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is -1 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. The following statement must be used to establish this value: restore_type=no_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game frames {it is not necessary to restore the screen background}. If the background is not restored, speed will be gained in the execution of the game (that will go faster in slow computers). But this mode of restoration ( no_restore ) can only be applied in games or in their sections in which there is a scroll or mode 7 window occupying the whole screen . The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type partial_restore Constant: partial_restore This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is 0 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. The following statement must be used to establish this value: restore_type=partial_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game frames only the screen areas in which graphics have been painted or texts have been written must be restored . This mode of restoration ( partial_restore ) is faster than a complete restoration (option by default), but it must only be applied in games, or in their sections, in which there ISN'T a scroll or mode 7 window occupying the whole screen . The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type complete_restore Constant: complete_restore This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is 1 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. This is the value by default of the restore_type variable and, it is the slowest mode of the three available restoration modes. The following statement must be used to establish this value: restore_type=complete_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game's frames the screen background must completely be restored . This mode of restoration ( complete_restore ) is the slowest one (and it is the option by default). Therefore, it can be changed by another one in order to gain speed in the execution of the game (so it will go faster in slow computers). As a matter of fact, this mode of restoration is only interesting for games (or for their sections) that DON'T have a scroll or mode 7 window occupying the whole screen, but that have a great number of graphics moving through the screen. The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type Numbers of window Constants: c_0 ... c_9 These constants are used to be assigned to the predefined cnumber local variable that is used to define the scroll or mode 7 windows in which the graphic of a process must appear. This will only be necessary when several scroll or mode 7 windows have been activated, and it ISN'T aimed to display the graphic of the process in all of them. Up to 10 windows of these types may be defined, numbered from 0 to 9 , and that directly correspond with the constants c_0 , c_1 , c_2 ... c_9 . For the graphic of a process to appear in one of these windows only, the corresponding constant must be assigned to its cnumber local variable. For instance, if the aim was for the graphic of a process to appear only in (scroll or mode 7) window number 3, the following statement would be included in its code: cnumber=c_3; If the aim for the graphic of a process is to appear in several of these windows, then the constants must be added. For instance, for a process to appear in the windows 0, 4, and 5, the following assignment will be performed: cnumber=c_0+c_4+c_5; For the graphic to appear in all the windows, suffice will be to assign 0 to the cnumber variable. It won't be necessary if this variable has not been modified, as it is its value by default. The values equivalent to these constants correspond with the following powers of 2: c_0 = 1 scroll / mode-7 number 0 c_1 = 2 scroll / mode-7 number 1 c_2 = 4 scroll / mode-7 number 2 c_3 = 8 scroll / mode-7 number 3 c_4 = 16 scroll / mode-7 number 4 c_5 = 32 scroll / mode-7 number 5 c_6 = 64 scroll / mode-7 number 6 c_7 = 128 scroll / mode-7 number 7 c_8 = 256 scroll / mode-7 number 8 c_9 = 512 scroll / mode-7 number 9 ---See: Constants - cnumber . Key codes Constants: Key codes These constants are normally used as a parameter of the key() function, to indicate which key is the one that the user wishes to know whether it is pressed. It can also be used to compare the scan_code global variable, that contains the code of the last key that has been pressed, with these values. The character _ (underlining) followed by the name of the key, is normally used to designate each constant. For instance, for the [ A ] key, the constant referred to its code will be _a . The whole list of these constants, with their respective values, is as follows (according to the standard arrangement of the keytable): _esc = 1 [ESC] or escape _f1 = 59 [F1] or function 1 _f2 = 60 [F2] or function 2 _f3 = 61 [F3] or function 3 _f4 = 62 [F4] or function 4 _f5 = 63 [F5] or function 5 _f6 = 64 [F6] or function 6 _f7 = 65 [F7] or function 7 _f8 = 66 [F8] or function 8 _f9 = 67 [F9] or function 9 _f10 = 68 [F10] or function 10 _f11 = 87 [F11] or function 11 _f12 = 88 [F12] or function 12 (DEBUGGER) _prn_scr = 55 [PRINT SCREEN] _scroll_lock = 70 [SCROLL LOCK] _wave = 41 [\u00ba] or [\u00aa] key _1 = 2 Number \"1\" key _2 = 3 Number \"2\" key _3 = 4 Number \"3\" key _4 = 5 Number \"4\" key _5 = 6 Number \"5\" key _6 = 7 Number \"6\" key _7 = 8 Number \"7\" key _8 = 9 Number \"8\" key _9 = 10 Number \"9\" key _0 = 11 Number \"0\" key _minus = 12 Symbol \"?\" key _plus = 13 Symbol \"\u00bf\" key _backspace = 14 Delete ( <- ) key _tab = 15 Tabulator [TAB] key _q = 16 Letter \"Q\" key _w = 17 Letter \"W\" key _e = 18 Letter \"E\" key _r = 19 Letter \"R\" key _t = 20 Letter \"T\" key _y = 21 Letter \"Y\" key _u = 22 Letter \"U\" key _i = 23 Letter \"I\" key _o = 24 Letter \"O\" key _p = 25 Letter \"P\" key _l_brachet = 26 Key [^] or ['] _r_brachet = 27 Key [*] or [+] _enter = 28 [ENTER] (Enter or Return) _caps_lock = 58 [CAPS LOCK] or capitals lock _a = 30 Letter \"A\" key _s = 31 Letter \"S\" key _d = 32 Letter \"D\" key _f = 33 Letter \"F\" key _g = 34 Letter \"G\" key _h = 35 Letter \"H\" key _j = 36 Letter \"J\" key _k = 37 Letter \"K\" key _l = 38 Letter \"L\" key _semicolon = 39 Letter \"\u00d1\" key _apostrophe = 40 [ { ] key _backslash = 43 [{}}] key _l_shift = 42 [SHIFT] or left capitals _z = 44 Letter \"Z\" key _x = 45 Letter \"X\" key _c = 46 Letter \"C\" key _v = 47 Letter \"V\" key _b = 48 Letter \"B\" key _n = 49 Letter \"N\" key _m = 50 Letter \"M\" key _comma = 51 Key [;] or [,] key _point = 51 [:] or [.] key _slash = 51 [_] or [-] key _r_shift = 54 [SHIFT] or right capitals _control = 29 [CONTROL] keys _alt = 56 [ALT] or [ALT GR] keys _space = 57 [SPACE] or spacebar _ins = 82 [INSERT] _home = 71 [HOME] _pgup = 73 [PGUP] or page up _del = 83 [DEL] or delete _end = 79 [END] _pgdn = 81 [PGDN] or page down _up = 72 Up cursor _down = 80 Down cursor _left = 75 Left cursor _right = 77 Right cursor _num_lock = 69 [NUM LOCK] or numeric lock _c_backslash = 53 Symbol [/] of the numeric keytable _c_asterisk = 55 Symbol [*] of the numeric keytable _c_minus = 74 Symbol [-] of the numeric keytable _c_home = 71 [HOME] of the numeric keytable _c_up = 72 Up cursor of the numeric keytable _c_pgup = 73 [PGUP] of the numeric keytable _c_left = 75 Left cursor of the numeric keytable _c_centre = 76 [5] key of the numeric keytable _c_right = 77 Right cursor of the numeric keytable _c_end = 79 [END] of the numeric keytable _c_down = 80 Down cursor of the numeric keytable _c_pgdn = 81 [PG DN] of the numeric keytable _c_ins = 82 [INS] of the numeric keytable _c_del = 83 [DEL] of the numeric keytable _c_plus = 78 Symbol [+] of the numeric keytable _c_enter = 28 [ENTER] of the numeric keytable It is indifferent to use these constants or the numeric values that they represent. That is to say, it is possible to call the key() function, to verify whether the [ A ] key is pressed, such as key(_a) or key(30) (in the previous list, it is possible to verify that 30 is the numeric value of the constant _a ). Important: Some of these codes can vary in certain keytables. In case of doubt it is possible to execute the following sample program, that shows a table on screen, corresponding to the key() function (indicating the codes of the keys that are pressed at any moment), besides the values of the scan_code , ascii and shift_status variables (also related to the reading of the keytable). Example program: PROGRAM example_codes_of_the_keytable; GLOBAL keys[128]; BEGIN write(0, 0, 0, 0, \"Codes of the pressed keys, according to key()\"); FROM x=0 TO 127; write_int(0, (x%16) 20, (x/16) 10+20, 0, OFFSET keys[x]); END write(0, 0, 160, 0, \"Code of the last key pressed (scan_code):\"); write_int(0, 320, 160, 2, OFFSET scan_code); write(0, 0, 180, 0, \"Code ASCII of the last key (ascii):\"); write_int(0, 320, 180, 2, OFFSET ascii); write(0, 0, 190, 0, \"State of the special keys (shift_status):\"); write_int(0, 320, 190, 2, OFFSET shift_status); LOOP FROM x=1 TO 127; IF (key(x)) keys[x]=x; ELSE keys[x]=0; END END FRAME; END END - This program may be used (by clicking on the text \" Example program: \" with the mouse and then, by pressing the [ F10 ] key) to find out the code that any specific key has. This numeric code can later be used as a parameter of the key() function, to verify in the game whether this key is pressed at a specific moment. ---See: Constants - key() - scan_code - ascii - shift_status min_int Constant: min_int This constant defines the minimum value that any variable can store in this language. This value is -2147483648 . All the data are 32 bit integers with sign in this language. For that reason, only integers within the range ( -2147483648 ... +2147483647 ) may be used. When the result of an arithmetic operation exceeds that range, the system won't report any error. In order to avoid this situation, much care must be taken. ---See: Constants - max_int max_int Constant: max_int This constant defines the maximum value that any variable can store in this language. This value is 2147483647 . All the data are 32 bit integers with sign in this language. For that reason, only integers within the range ( -2147483648 ... +2147483647 ) may be used. When the result of an arithmetic operation exceeds that range, the system won't report any error. In order to avoid this situation, much care must be taken. ---See: Constants - min_int pi Constant: pi This constant defines the equivalence in degree thousandths of the mathematical constant pi (approximately 3.14159265 radians). Its value is 180000 degree thousandths (180 degrees), equivalent to pi radians . It is normally used to define angles. For instance, 180 degrees could be defined as pi , -90 degrees as -pi/2 , 45 degrees as pi/4 , etc. ---See: Constants - Use of angles in the language Predefined global data Each of the predefined global data are now described. STRUCT dirinfo - List of files in a directory STRUCT fileinfo - Information about the file STRUCT joy - Parameters of the joystick STRUCT m7[9] - Control of the mode 7 windows STRUCT m8[9] - Control of the mode 8 windows STRUCT mouse - Parameters of the mouse STRUCT net - Parameters of the net hardware STRUCT scroll[9] - Control of the scroll windows STRUCT setup - Control of the sound card STRUCT video_modes[31] - Modes of video disposed argc - Number of arguments argv[] - Arguments of the program ascii - Reading of keytable ASCII codes {#1416,channel[31] - Sound Channels draw_z - Depth plane of the drawing dump_type - Dump type of the screen fading - Fading indicator of the screen fps - Number of frames per second joy_filter - Filter applied to the joystick joy_state - State of the joystick max_process_time - Max time of execution of the process num_video_modes - Number of detected video modes restore_type - Restore type of the screen scan_code - Reading of codes of the key-board shift_state - State of the special keys text_z - Depth plane of the texts timer[9] - time counter unit_size - Size of the unity of reading/writing vsync - vertical synchronisation ---See: Constants - Local data - Syntax Predefined local data Each of the predefined local data are now described. STRUCT reserved - Internal parameters of the processes father - Identifier of the process' father son - Identifier of the process' son smallbro - Identifier of the process' younger brother bigbro - Identifier of the process' elder brother priority - Priority of the process' execution ctype - Type of coordinates used by the process x - Horizontal coordinate of the process y - Vertical coordinate of the process z - Depth plane of the process' graphic graph - Code of the graphic assigned to the process flags - Indicators of mirror and transparency size - Size of the process' graphic angle - angle of the process' graphic region - Screen region assigned to the process file - File code of the process' graphic xgraph - OFFSET of the graphic table of the process height - Height of the process in mode 7 windows cnumber - Numbers of scroll or mode 7 windows resolution - Resolution of the process' coordinates m8_nextsector - Sector where the process is going next m8_sector - Number of sector the process is in m8_step - Height which the process can rise m8_wall - Wall number of map of sectors opposite with which you collided radius - Radius of the mode 8 processes ---See: Constants - Global data - Syntax Constants predefined Each of the predefined constants are now described. m320x200 .. m1024x768 - Videomodes true - True value false - False values s_kill - Signal to kill processes s_wakeup - Signal to wake processes up s_sleep - Signal to make processes dormant s_freeze - Signal to freeze processes s_kill_tree - Signal to kill processes and sons s_wakeup_tree - Signal to wake processes and sons up s_sleep_tree - Signal to make processes and sons dormant s_freeze_tree - Signal to freeze processes and sons all_text - Indicator of all the texts all_sound - Indicator of all the sounds g_wide - Indicator of width g_height - Indicator of height g_x_centre - Indicator of horizontal centre g_y_centre - Indicator of vertical centre c_screen - Screen coordinates c_scroll - Scroll window coordinates c_m7 - Mode7 window coordinates partial_dump - Partial background dump complete_dump - Complete background dump no_restore - Disabled screen restoration partial_restore - Partial screen restoration complete_restore - Complete screen restoration c_0 .. c_9 - Indicators of windows min_int - Minimum value of data max_int - Maximum values of data pi - Mathematical value of pi Key codes - Keytable codes _case_sensitive - Distinguish capital and small letters _extended_conditions - Extended conditions _free_syntax - Free syntax _hidden - Hidden file _ignore_errors - Ignore all errors _max_process - Max number of processes _no_check - Do not check execution errors _no_id_check - Do not check the identifiers _no_null_check - Do not check accesses to NULL _no_optimization - Do not optimise the codes _no_range_check - Do not check the rank _no_strfix - Do not enlarge the text strings _normal - file normal _simple_conditions - Simple conditions _subdir - Subdirectory _system - system file _volid - Volume etiquette all_drawing - Indicator of all drawings seek_cur - Current position of the file seek_end - Final position of the file seek_set - Beginning of file ---See: Global data - Local data - Syntax Program debugger See: Index - Help about the menus system --- The programs debugger is an advanced tool, whose use first requires a correct understanding of all the programming concepts explained from chapter number 5 of the DIV Games Studio's book (User's Handbook). The debugger is a dialog box that can be activated in programs' run time for one of the following reasons: The program was entered with the option programs \\ debug program . The F12 key was pressed in a program's run time. An error of execution arose in the program. A debug statement was found in the executed program. This tool allows us to execute the program statement by statement, verifying the value taken by the different program's data when necessary. It is useful because, on checking the program's execution step by step, it can find the mistakes eventually made by the programs. As it is a dialog with a great deal of information, each of its sections are now described separately. - Upper information line Two messages are reported in the upper part of the window. To the left, there is one indicating the number of processes active in the program out of the total that can be created . For instance, if it reports 23/3201, it means that there are 23 processes active in the program and that up to 3201 could be created before using up the available memory for processes. The maximum number of processes vary from some programs to others, depending on the number of their local and private variables. The identifying code of the process selected in the list, as well as its current state (normal, killed, asleep or frozen) are indicated to the right. List of active processes This list appears in the upper left part of the debugger with a scrolling bar to its right. All the active processes in the program are shown in it. By active processes we mean the processes that have been created and that still have not been disappear. The following information appears for each process: The process name in the program. Its identifying code in brackets (occasionally, there is no space to put it entirely). A letter indicating its state ( A -Normal, K -killed, S -Asleep and F -Frozen). The percentage of accomplished execution for the following frame. The scrolling bar must be used to move through the processes' list. Important : One of the processes appears with a white tip arrow pointing out its name. This is the process that is being executed in the program currently. Therefore, the next statement of the program will belong to this process. One of the processes appears tagged with a black band. This is the process about which information is shown in the right part of the window (close to this list of processes). This process may be selected with the mouse, by clicking on the list. It is very important to distinguish between the process in execution and the process about which the information is shown, as they don't have to necessarily be equal. For the information about the process in execution to be shown, it is necessary to select it (that of the white arrow) by clicking on the list with the left mouse button. Information box about the indicated process To the right of the previous list, information about the program tagged with a black band in the list (not the process in execution) is shown. Its identifying code and its state was shown in the uppermost line. The complete process name is shown in a dark background's box. Below it there is another box with the graphic of this process (when it is bigger, it will be reduced to fit this box). The button See data appears to the right of the graphic. This button allows us to access another dialog box in which all the data of the process must be consulted and modified. It will be later explained in the section Inspecting data . The ( x , y ) coordinates of the process, the system of coordinates used by it (referred to the screen , to a scroll or to a mode 7 ) and the mirrors or transparencies applied to the graphic of the process are always shown following this button.. Finally, four buttons allow us to access the father process (the process that called the one is selected), the son process (last process called by the selected one), the younger brother ( smallbro , the last one called by the father before it) and the elder brother ( bigbro , the following one called by the father after it). If these buttons don't lead to any other process, that is because there is no process with that relationship. Partial execution controls Two buttons called Exec.Process and Next FRAME below the previous information box allow us to execute the program partially. Execution of the process . This first button allows the program to continue just to the end of the process currently under execution (the one pointed with the white arrow in the list). All its statements will be executed until it reaches the next FRAME (until the process is ready for the next frame of the game). Next FRAME . The second button will execute the program to its next frame, first executing all the pending processes and displaying the next frame of the game (in the debugger's background). The debugger will stop in the first statement of the first process to be executed in the new frame. It is possible to displace the dialog box with the debugger (by dragging its title bar) in order to contemplate the result of the previous frame of the game. Debugging box of the program's listing The code of the program is shown in the lower part of the debugger. The identifying code of the process under execution (again, the one pointed with the white arrow in the list) appears in the left upper corner. Below it, there are three buttons and, to its right, the code window. In the code window , another white arrow indicates the line including the next statement to be executed by the process. It can be notice how the statement also appears highlighted in white from the rest of the code. This window's contents can be displaced with the cursors keys. The program's lines can be tagged with a black band. Nevertheless, it is not possible to modify the program from the debugger. Indeed, to modify the program it is necessary to finish its execution (which can be done by pressing ALT+X ) and return to the editor of the environment. The first button called Process allows us to go in the code window to one of the processes of the program directly. A list containing all the processes found in the program will appear, being necessary to select the desired process with the mouse. However, it won't change the process currently under execution, which will continue to be the same. The second button allows us to establish a Breakpoint in the program. For that, it is first necessary to tag the line of the listing with the black band. On reaching this line (with the cursors), the program must stop. Then, this button must be activated, appearing the line in red. Breakpoints can not be established in all the lines of the program, but only in those for which the executable code has been generated (in which any action is performed). Many breakpoints can be established in the program. To execute the program until it reaches one of these points, suffice will be to close the debugger or press the ESC key. To disable a breakpoint, it is necessary to select the line and click on the same button again. The last button, Debug , is the one that really allows us to debug the program statement by statement. Every time it is clicked on, one of the program's statements will be executed. When a process finishes its execution, or completes a frame, you will pass to the first statement to be executed of the next process. Inspecting data By clicking on the button See data of the programs' debugger it is possible to access this other dialog box, in which the values of the program's data can be consulted (and even modified) in the point in which it has stopped, normally with the aim of carrying out tests in it. Most of this box is occupied by the data list. Each of them are shown with their name and numeric value. This list always appears in alphabetical order. The data set appearing in this list can be selected through a series of switches. The two upper switches define the two following sets. Predefined . When this switch is activated, all the data predefined in the language will be included in the list. Thus, it will be possible to access the predefined local data (such as x, y, angle, size, ...), the predefined global data and the predefined constants. Defined by the user . This switch selects all the new data defined in the program. These are the specific constants, variables, tables and structures of every program. Besides selecting the data depending on whether they are predefined or new, they can be selected according to the sphere in which they have been declared, with the following switches. CONST . This switch is used to include the constants in the list, even if the constants are not data, but synonymous of a numeric value. Therefore, they can not be modified. GLOBAL . On activating this switch, all the global data (accessible by all the processes) will be included in the list. LOCAL . When this switch is activated, the local data (the data that all the processes of the program have) will be included in the list. PRIVATE . This switch selects the specific data of the process tagged in the debugger window to include them in the list. These data exclusively are for the program's internal use. The list of data can be displaced with the vertical scrolling bar or with the cursors and Pg.Up / Pg.Dn keys. The button Change allows us to modify the value of the selected data; only the constants can not be modified. A new dialog will appear with a text box in which the new value of the variable must be input. Any variable of the list can be selected with the cursors or clicking on it. Below this button, there are other two buttons with the symbols - and + . They are used to modify the index of tables and structures , which can also be done with the right cursor and left cursor keys. The table or structure whose index is intended to change must previously be selected in the list. This is the way to observe or modify any element of a table or structure Finally, a series of buttons appears in the lower part of this dialog. These buttons, mentioned below, allow us to display the value of a variable in a specific way: Angle . This button allow us to display the variable as an angle. The angles are specified internally (in the programs) in degree thousandths. The value of the variable will be displayed as an angle in degrees and radians. Process . If the variable is the identifying code of a process, on selecting this display filter, the name of this process will appear in the list as a value of the variable. Text . When the variable is a text or a pointer oriented to a text (to a literal of the program), that text will be displayed in the list by clicking on this button. Logical . If a variable contains a logical value, on applying this filter to it, in the upper list will be shown whether it is false or true . In the language, on evaluating them as logical conditions, the odd numbers are considered true, and the even numbers are considered false. Once the display filter of a variable has been established, it will remain during the rest of the program's execution. The same button must be double-clicked to display again the contents of the variable as a numeric value. - Commands in the graphic environment Commands in the graphic environment ALT+X - To exit from the graphic environment to the operative system. ESC+Control - To exit the environment and programs directly. ALT+S - To execute a session of the MS-DOS operative system. ESC - To cancel a dialog box. TAB - To chose the selected control of a window or box. Enter - To activate the selected control. F1 - To invoke the help window. F2 - To save the selected program. F4 - To open a program. F10 - To save and execute the selected program. F11 - To compile the selected program. F12 - To save and debug the selected program. Control+ALT+P - To save a snapshot of the graphic environment (DIV_*.PCX) Common commands in the games Common commands in the games ALT+X - To exit the game. ESC+Control - To exit the game. Control+ALT+P - To save a snapshot of the game (SNAP*.PCX) F12 - To invoke the programs' debugger. Pause - To stop the game immediately. Commands in the programs' debugger Commands in the programs' debugger Cursors. - Shift through the listing. Pg.Up. - Previous page. Pg.Dn. - Following page. F4 - Execute until the selected line is reached. F5 - To see the listing of a process. F6 - To execute the current process. F7 - To see or edit data. F8 - To debug a statement. F9 - To set a breaking point. F10 - Execute the following statement or call a process. F11 - To see the timing profiles of the program. F12 - To invoke the debugger / To advance frames. F - To execute to the following frame. TAB - To select a button. Enter - To activate a button. ESC - To exit the debugger. Commands in the programs' editor Commands in the programs' editor Generic commands. F5 - To go to the beginning of a program's process. Control+Z - To zoom the selected program's window. Basic movement and edit commands. Cursors - Basic movement of the cursor. Home - To go to the beginning of the line. End - To go to the end of the line. Pgdn - Following page. Pgup - Previous page. Insert - To toggle between insert and overwrite. Delete - To delete the cursor character. Clear - To delete the character previous to the cursor. TAB - To go to the following tabulation. Shift+TAB - Distabulate. Control+Delete, Control+Y - To delete the current line. Control+Right - Following word. Control+Left - Previous word. Control+Pgup - To go to the beginning of the program. Control+Pgdn - To go to the end of the program. Control+Home - To go to the beginning of the page. Control+End - To go to the end of the page. Search and replacement commands. ALT+F, Control+F - To search for a text. ALT+N, F3, Control+L - To repeat search. ALT+R, Control+R - To replace a text. Blocks commands of type Q EDIT. ALT+A - To tag the beginning or the end of a permanent block. ALT+U - To untag the permanent block. ALT+C - To copy the block to the current position. ALT+M - To move the block to the current position. ALT+D, ALT+G - To delete the block. Blocks commands of type EDIT. Shift+Movement keys - To tag the volatile block (Movement keys: Cursors, Control + Right, Control + Left, Pg.Up, Pg.Dn, Home, End ). Shift+Insert - To paste block. Control+Insert - To copy block. Shift+Delete - To cut block. Control+X - To cut block. Control+C - To copy block. Control+V - To paste block. Delete - To delete block. Commands in the graphic editor Commands in the graphic editor Generic commands. F1 - To invoke the help window. ESC - To exit the graphic editor. Cursors, OP/QA - Movement of the cursor. Space bar - Equivalent to clicking with the left mouse button. Shift+Movement - 8 by 8 pixels movement. Shift+Left button - To take the colour from the screen. W, S - To choose colour within the current range. Shift+W, S - To choose current range. Control+Cursors - To choose colour and range. Backspace - To undo. Shift+Delete - To repeat action (redo). 0 - To select the transparent colour. B - To highlight the transparent colour. C - colours window. M - Mask window. T - Select a paintbrush. U - Select a texture. X - visualise a texture. Z - To change the zoom percentage. Commands of selecting tool. F2 - Pen, for hand drawing. F3 - Straight lines. F4 - Multi line, stringed lines. F5 - Curves b\u00e9zier. F6 - Multi curve, stringed curves. F7 - Rectangles and boxes. F8 - Circles and circumferences. F9 - Paint spray. F10 - Filling of surfaces. F11 - Blocks edit. F12 - Undo and redo actions. Shift+F1 - To write texts. Shift+F2 - To position control points. Shift+F3 - Dotting bar. Specific commands. Control - To move selection (bar: to select a block). D - To stump (bars: pen, lines, curves and spray). H - To hide the cursor (bar: offset block). K - Copy window (bar: select block). ** +, -** - To vary the strength (bar: multi curve). ** +, -** - Change the checkpoint (bar: checkpoints). Common help/ questions about DIV Where can I find information about DIV? The DIV Games Studio Environment has its own dedicated web site WWW.DIV-ARENA.COM , from here you can download upgrades and utility packages, get technical support, review / submit Games designs and chat to other DIV users about cool new games, hints on obtaining the best from DIV etc.. in fact talk about whatever you wish. How can I obtain help about ... ? All options accessible from options menus are described exclusively in the user manual for DIV Games Studio 2. How can I resolve a configuration problem ? For sound problems, incomplete installations, etc., see the chapter resolution of problems of this electronic help. What improvements have been made for this version? They are divided in two groups: the new language capabilities (explained in this help ), and the new environment (explained in the user's manual ). Why did I get the error message \"Can't recognise the file type\"? It is possible that you are attempting to load a file with an incorrect menu, which means, the palette menu serves only to load palettes, the files menu only loads graphics files (groups of graphics), the programs menu loads programs or text files, etc. You may also be attempting to load a PCX or BMP Map in true colour, this version of DIV can work only with 256 colour graphics, so these types of files are impossible to import. The graphics which you want to load into DIV must first be converted into 256 colours with another application. How can I stretch a graphic? To stretch a graphic you must press the left mouse button in the map window, not on the bar with its name, but on the proper graphic contained in the window. Then move the mouse to the position in which you want leave the graphic and let go of the left mouse button (you can stretch maps in files, to the trash, to the background, in other maps or in the fonts generator). How can I drag a graphic contained in another graphic out? You must select the part of the graphic which you want to drag out from the section blocks. The new section could be represented as a rectangle, painting contours, etc. - Once the selection has been extracted many new icons will appear on the toolbar, including the icon cut the window . After pressing on this the desktop creates a new map window and inserts the selected zone into it. - How can I cut and copy the graphics? See also the last question. To cut and move graphics you must access the toolbar , inside the picture window, selecting the icon which shows cutters. From the desktop some operations can be achieved, such as copying one graphic into another, this can be made by dragging the first one into the second. Also a copy of a graphic can be created if you drag it to the background (area of the desktop which doesn't contain any windows). What must I do if the system becomes unstable? DIV Games Studio is a very complex program and, although it is stable in its execution, it is possible that a module makes an error after completing a determined action, or crashes the PC. If this happens, to return the system to its original state, you must load DIV from the MSDOS prompt indicating the parameter /SAFE (introducing the command D.EXE /SAFE from the directory where the program was installed), to enter DIV in \"debug mode\". What must I do to learn the programming language ? The basic concepts are not explained in this help file, but in the user's manual for DIV Games Studio 2, in the chapters 4, 5 & 6. Also you can learn a lot from the Examples of the language functions (See the list of functions in the language help) and the tutorials, which are simple mini-games designed to simplify the learning of the language (you can find these tutorials in the directory PRG/TUTOR of DIV Games Studio 2). How are the graphics loaded into the games? In a game the graphics contained in the map (MAP or PCX files) can be used, loading them using the functions load_map() or load_pcx , or placing some graphics in FPG file of several graphics and then loading them with the function load_fpg() , this last option has an advantage because many graphics can be loaded at the same time in the game. Often the graphics are assigned to the variable LOCAL graph of the processes of the game. How to show a new graphic in the game? To create a new graphic or \"sprite\" in a game, first a new process ( PROCESS ) must be created with the commands which will manage its conduct in the game, then every time you want to create a process of this type, you must call the process (See how to make a call to a process ). How to undo a process? To undo or \"kill\" a process of the game, you can execute a RETURN statement from itself or, to kill a process from another process, send a signal s_kill (See the function signal() , which is used for this). Which are the functions that manage the mouse? The mouse is not controlled by any function, but by the global structure mouse , you can access the help file about language / global data to see the other structures which control other important aspects of the games. Where are all DIV files loading from ? When the function load_fpg( ... ) is called in a program the internal manager of DIV attempts to locate this file following this method (supposing that it intends to load the file \"DIR/file.EXT\"): First it checks where the executable (EXE) of the game is, or in the main directory of DIV (where D.EXE is) in case the game will be executed from this environment. Then the program attempts to open the file from the directory specified in the function (\"DIR/file.EXT\"). If the program has still failed to open the file, it will attempt to load the file inside a directory which has the same extension as the one specified, such as \"EXT/DIR/file.EXT\". If this is still not found, the program will try to load the file without a specific path, meaning \"file.EXT\". Finally, if the file was not found in any of those directories, the program will attempt to find the file in the directory whose name coincides with the extension of the file, ignoring the path passed to the function, such as \"EXT/file.EXT\". Help about the calculator How it functions? The calculator included in the environment functions differently from conventional calculators, it is made for programmers, and therefore functions as an evaluator of expressions. Its use is very simple, you write the mathematical expression and press the Enter key. Pressing F1 will always take you to this help page. For example, you can type in the calculator the expression 2+2 and press Enter ; the value 4 will appear in the results window. To introduce a new expression the previous one must first be rubbed out, this can be done by pressing the ESC key. It is possible to introduce complex expressions, using parentheses ( ) to indicate the priorities in the calculations. The operators which can be used in the calculator expressions are the following (indicates all symbols accepted in each operator): ** + -** Addition and Subtraction. ** * /** Multiplication and division. ** % MOD** Modulus, or remainder from whole division. ** < <<** Binary rotation to the left. ** > >>** Rotation to the right. ** ^ ^^ XOR** OR exclusive binary. ** | || OR** OR binary. ** & && AND** AND binary. ** ! NoT** Binary negation. ** SQRT** Square root. The calculator has two cells which can change their {mode of functioning}. Their options are the following: Int - If this cell activates, all operations will be rounded down to whole number values, as in the language DIV. For example, the result of the division 8/3 will be 2. Hex - When this cell is activated, the result will be shown in the hexadecimal system. Also numbers in this system can be introduced inside the expressions preceded by ' 0x ' (as in the language). Note: On the desktop as many calculators as necessary can be opened, so many different expressions can be visible simultaneously . compilation options These options modify the form in which DIV interprets a program and the code which it generates for DIVl. Normally it is not necessary to specify any options. To add one or more of these options to program the word COMPILER_OPTIONS must be specified as the initial statement of the program (commentaries in margin) followed by the names of the included options. If many options are included, they must appear separated by commas, adding always a semicolon at the end (after the last option). disposed compilation options : _max_process=x Where x is a whole positive number. This defines the max number of simultaneous processes permitted during execution. This can be set when a program is completed (when it is known how many processes it will have in one moment), to optimise memory during execution. When this value isn't defined, a min of 1 Mb (and a max of 2 Mb) will be reserved for the program memory. _extended_conditions Allows you to use assignations inside a condition (such as: IF(id2=get_id(...))...) ; it was permitted by default in the first version. It may be necessary to declare this option in order to ensure that programs written with DIV1 function in DIV2. _simple_conditions Interprets the symbol = as a comparison, when it appears inside a condition. This is the opposite case to previously (and incompatible with l), once this option is included you will be able to make comparisons like IF(x=0)... , instead of interpreting them as an assignation of the value 0 to the variable x. _case_sensitive This option Differentiates between capital and small letters. If this option is active Abc and abc will be two different names. It is important to know that, if activated, all reserved words of the language such as ( program , loop , frame , if , ...) must be put in small letters. _ignore_errors Forbids the appearance of error messages during the execution of the program. The majority of errors will be ignored (such as memory errors, file not found, divisions by zero, etc.) , we don't advise you use this option but, if you want it to be included, then do so only if the programs are finished, sufficiently checked, and without known errors, before compiling the installation (See the final considerations). _free_syntax Permits you to use free syntax. With this option the symbols ; (semicolon) at the end of the statements will no longer be necessary and parentheses are no longer required in statements like IF , WHILE or UNTIL . For example, in this mode statements such as: IF a<0 a=0 END (See before final considerations) will be valid. _no_strfix Will not finish automatically text strings. When you put a character in a variable of type STRING , normally the program inserts the character after the end of the string, and adds white spaces with the character NUL (ascii 0) at the end of the string. This option disables this characteristic. _no_optimization Do not optimise the generated code. By default the programs are optimised. This option can be included to disable these optimisation processes. This means, if this option is specified, the programs will go slower and will occupy more memory. _no_range_check Doesn't check that values accessed are out of the range of tables and structures. The compiler generates code to check during the execution that expressions used as indexes of a table or structure are in the permitted limits, and to show an error when a value is out of range. This option prevents this code being generated. _no_id_check Do not check the validity of the identification code. The compiler also generates code to check the validity of the identifier when it is used to access a local variable from another process (as in id2.graph ). If this option is specified at the beginning of the program, then this checking will not be done. _no_null_check Do not check the accesses to null pointers ( NULL POINTER ). This disables the checking of attempts to access memory with null pointers or undefined pointers. Including this option means the code to protect these accesses of reading or writing in memory will not be generated . _no_check Does not allow any security checking. This option unites the three previous options, and forbids the compiler to generate code to check any type of anomalous operation during the execution. The programs will run faster, but it is not recommended to use these options until the programs have been tested and are without errors. To use these options, for example, the program can be begun with the following statement: COMPILER_OPTIONS _max_process=64,_no_id_check; In this case the compiler is set to reserve memory for 64 simultaneous processes in the execution of the program, and no validity checks on the identifiers to local variables of other processes will be made (it is useful to switch off these checks, when the programmer has sufficient experience to know what he's doing). Important: considerations about some of the options. 1. New users of DIV or those with little programming experience can simplfy a little the conditions with the option _simple_conditions , so that two values with the symbol = (also with the symbol == ) can be compared. In contrast, users who have more experience, will probably prefer to activate the option _extended_conditions so that more complex conditions can be created, with assignations inside of them. 2. The options _ignore_error and all variants of _no_check must be used only by experienced programmers, and only in the finished version of the program. Otherwise we don't recommend you use it, because major execution errors can be produced, and it will be more difficult to find the cause without these error messages. 3. In general the programs are already optimised (the generated code is 60% faster than in the previous version), but any of these options will significantly change the speed of execution. The profiles of time of the debugger can be used to see the repercussions of each option. 4. The option _ignore_errors is often not the best, nearly always it is better to use the function ignore_error() to ignore selectively some predetermined errors the program is known to generate during execution. 5. The use of free syntax (with _free_syntax ) also has many dangers. Because there is no differentiation between lines and white spaces, and in some cases incorrect interpretations can be produced . For example, in the statement: IF right ++x END , the compiler will interpret that the symbol ++ is the post increment of right , instead of the pre increment of x (although this symbol is united with this last variable). Another similar anomaly can happen using C programming style pointers, for instance, with these two consecutive assignations: a=1 *ptr=2 , the compiler will interpret them as: a=(1*ptr)=2 (although they were in different phrases). But in general, if you are not using preincrements or C programming style pointers, there will be no problems with the free syntax (also parentheses or semicolons can be used in concrete cases, to resolve these small problems). 6. However, the option _max_process (which is the only one which must be followed by the the symbol = and a number value) is strongly recommended. If the number of processes which the program can have running simultaneously is known, then less memory needs to be reserved (leaving this free for graphics, sounds, etc.). types of data In DIV there exists data of the types INT ), STRING (text strings), WORD (16 bit whole positive values), BYTE (8 bit whole positive values) and POINTER (pointers, of all these types). Also tables and structures (also of any types) of 2 or 3 dimensions (see the declaration of a table )can be defined. INT - whole numerical data between -2147483648 and +2147483647 ( min_int ... max_int ). WORD - whole numerical data between 0 and 65535 (whole of 16 bit without sign). BYTE - whole numerical data between 0 and 255 (whole of 8 bit without sign). POINTER - Pointers to data of any type. STRING - strings of text (tables of 8 bit characters without sign, between 0 and 255) Note: The reserved word INT can be omitted, because all data will be of this type by default (32 bit whole numbers with sign). ---See: Declaration of data data of type INT Whole numerical data between -2147483648 and +2147483647 (values defined in the constants min_int ... max_int ). This is the basic data type of the language, when the type of the data is not otherwise specified , it will be INT by default. ---See: types of data - Declaration of a data data of type WORD Numerical whole data between 0 and 65535 (16 bit whole value without sign). Tables of type WORD can signify a big saving of memory, with respect to tables of type INT (which occupy twice as much memory). But the fastest will be operations with data of type INT . See the adjustment of data in memory , where the amount of memory occupied with the different types of data is shown. ---See: types of data - Declaration of a data data of type BYTE Whole numerical data between 0 and 255 (8 bit whole value without sign). The tables of type BYTE can signify a big saving of memory, with respect to the tables of type INT (which occupy 4 times more memory). But the fastest operations will be with data of type INT . See the adjustment of data in memory , where the amount of memory occupied with the different types of data is shown. ---See: types of data - Declaration of a data data of type POINTER Pointers to data of any type ( INT ), WORD , BYTE and STRING ). The pointers in the DIV language are different to other programming languages, for one thing they are more simple to use. These pointers are used as if they were mobile tables, that is, tables which can be defined where they are situated, assigning them an OFFSET (to the data). So you can access the data situated in this position from pointer[index] , for reading and writing of the values. different data of type pointer: INT POINTER - Pointer to whole number data. The word INT can be omitted, declaring a pointer to data of type INT as POINTER name; . WORD POINTER - Pointer to a list or table of data of type WORD . BYTE POINTER - Pointer to a list or table of data of type BYTE . STRING POINTER - Pointer to a string of text contained in a STRING . STRUCT POINTER - Pointer to a structure, which must be declared as {STRUCT POINTER name_structure ;}. Where will be the pointer to the structure. For example, if in a program there exist different tables of type WORD (declared as WORD t1[9], t2[9], t3[9]; ), then a denominated pointer ptr can be defined which permits you to access to any of the tables (as WORD POINTER ptr ;). In addition you must assign the direction or location of the specific table to the pointer (such as ptr = OFFSET t1; ) to access it. From then on you can access the values of the table with the pointer (you can access t1[n] using the term ptr[n] ). The functioning of the pointers INT ), WORD and BYTE are practically identical (they allow you to access a list of consecutive data). The pointers STRING permit you to access only one string of text (all characters contained in that string). In the declaration of the pointers of type STRUCT , the name of the structure to which the pointers refer must be declared. The pointers can give access to only one structure but, after assigning the OFFSET of the structure (or of any register) you than have access to all fields and successive registers, as if the pointer were a conventional structure. Note: To declare a pointer to a structure it is necessary to have previously defined the structure. It's enough to define the different fields, but it is not necessary to define the number of registers of the structure. Limitation in the access of the pointers. You can't access the written data before the OFFSET of the pointer is established. This OFFSET can't be assigned in the declaration of the pointer, it must be done in a statement of the program, until this statement is reached the pointer will value 0 ( pointer zero ). The access to data with the pointer zero will provoke an execution error. It is possible to limit the range of access of a pointer , indicating in its declaration the max value from the index permitted for it. For it must be only indicated in brackets, after the name of the pointer. For example, the following declaration: STRING POINTER s[32]; Defines the pointer to one string of text, but it will stop to access directly to its 33 (from 0 to 32) firsts characters. If it is intended to access out of these limits, the program will advert it indicating an access out of the rank. ---See: types de data - Declaration of a data - OFFSET data of type STRING The STRING tables are different to the other data types, for one thing their data can only be strings of text and they can only have 1 dimension . If a literal is not assigned to them, the string will stay initiated as \"\" ( empty string ). If a string is defined as STRING s=\"abc\"; , then when it is accessed by its name ( s ), it will refer to the contained string ( \"abc\" ). Also you can access any character of the string as if it were an element of a table (for Example, the statement s[3]=\"d\"; would add a \"d\" to the string). Note: It is not necessary to declare in brackets the length of the text strings (by default 256 characters will be set aside for the string). operations with strings of text. Inside a program, supposing the data s and r are of type STRING , then the following operations can be performed on the data. 1. data of type STRING can be used in all functions which require text (such as write (0,0,0,0,s), load_fpg (r), ...). 2. It is also possible to assign literals to a string by writing s=\"any text...\"; or assigning one string to another, as s=r; . 3. the strings Can be summed with statements such as s+=\"text to be added\"; or s=r+\"ho\"+\"the\"; . 4. Also a character can be added to a string with statements such as s+=ascii; or r+=\"a\"; . 5. A character can be deleted (from the end) of the string with s--; , s-=1; or r=s-1; . 6. Strings can be compared with conditions such as (s==\"hello\") , (s>=r) , (s<\"0\"+r) , etc. 7. And, finally, a great number of functions for text management exist (See the {#1032, list of functions of the language}). Literals of many lines. It is possible to define literals over many lines, for this you only need to divide the text into many texts, and place them one after the other (without any separation with symbols). For example, a constant can be defined as: greetings=\"\u00a1Ho\" ** \"the!\";** This can also be used to initiate data of type STRING . There is no limit in the number of lines allowed. Between two following literals only commentaries can appear. ---See: types of data - Declaration of data Adjustment of data in memory It is important to stress that all data in this language will be adjusted to 4 bytes of memory (the size of data of type INT . This means that the OFFSET of all data will always be situated in one area of absolute memory multiple of picture . It has direct implications for data of types WORD and BYTE . Because they occupy respectively 2 bytes and 1 byte . therefore, if you define a variable of type WORD , so, 2 bytes of memory won't be used, and if you define a variable of type BYTE 3 bytes won't be used (because the following data will also be adjusted to 4 bytes). Therefore, to use the PC memory better, we recommend you use these two types of data as tables (see the declaration of a table ), because the different elements of a table always save as the following, and don't adjust in memory. Examples of occupation of memory: BYTE b1; - required memory 1, occupied memory 4. WORD w1; - required memory 2, occupied memory 4. INT i1; - required memory 4, occupied memory 4. BYTE b2[7]; - required memory 8, occupied memory 8. WORD w2[2]; - required memory 6, occupied memory 8. BYTE b3[2]; - required memory 3, occupied memory 4. WORD w3[3] - required memory 8, occupied memory 8. As you can see, the occupied memory (in bytes) by data will always be a multiple value of 4. You must also remember this in the fields of the structures of data because for example; two consecutive variables of type WORD will occupy 8 bytes , while a WORD table with two elements occupies only 4 bytes . ---See: types of data - Declaration of data The FUNCTION blocks The new FUNCTION blocks behave the same way as the functions of any other programming languages, they execute sequentially (not in parallel as the PROCESS blocks do), not returning before they are finished. FUNCTION ( ) BEGIN ; ... END These blocks will continue to function in a similar way as the normal processes, but with one important difference: they will halt the calling process until the function has finished, in other words, the process which called these functions will be sleeping, until these functions return or their process will be finished. If the function doesn't use the statements FRAME , it will behave as a normal process, but if a function executes the statement FRAME , it will not return to the block from which it was called (as it would do in a normal process). Therefore, a function can always return a value with RETURN ( ) , including after executing one or more FRAME statements. successive programming. It is not recommended to program only with functions in a successive way, but it is useful to know how it is possible to simplify the understanding of programming DIV for programmers of other languages. It is possible to make a program in the traditional programming style using exclusively FUNCTION blocks, this way at each moment in the execution there will only be one process. After programming in this way, the statement FRAME converts in exactly the same order as it converts to video . Logically, if there is only one process executing, when it executes this order the system will show the following frame of the program. But, programming this way, could different graphics be shown on screen?. The answer is yes, because mini-processes can be created which will function as an instruction of the type \"paint the graphic for the following frame\" (different to functions such as put() , which paint a graphic forever). To show a graphic in the following frame a process must be constructed which receives the necessary visual parameters and only executes the FRAME statement, for example: PROCESS paint_graphic(x,y,graph) BEGIN ** FRAME;** END After calling this process {a temporal process will be created which will be painted in the next frame} and then disappear. Other parameters can be sent to this process (besides x , y , such as file , size , angle , z , ... (See the predefined local data ). It is clear that, after programming this way, a table of sprites needs to be created (normally in a global structure ) in such way that the program could manage all the graphics. This may seem difficult, but is the normal way games are programmed in any other language other than DIV. Applications in the main program. The statements which appear between the words BEGIN and END of the main program (after the declarations of data), control the main process of the program . It initiates the program, draws the images and graphics, controls the menu loops , the game loops (creating necessary processes), and closes the program. From the main program, it can be very useful to call the FUNCTION blocks. Because this way the main program will be temporarily stopped while the program executes the contents of this function. For example, the presentation sequence can be made in a function, the menu options in other, etc. Also, remember that functions can always, after finishing, return a value with the RETURN ( ) , which can be useful, for example in the menu to return the option number that was selected. Note: Reaching the end of execution of the main code doesn't mean the execution of the program is finished, so it will continue if any other processes are still active; if you want to force the program to close after this code has finished, you can use, for example, the function let_me_alone() just before the END of the main code , or also the function exit() (in any point of the program). ---See: Los blocks PROCESS - syntax GLOBAL argv[], GLOBAL argc argv[]; // Arguments of the program argc; // Number of arguments--- You can access the last parameters of the program (normally after executing it from MS-DOS), in a similar way to how it is done in the programming language C, in the global predefined data argc and argv[] . The variable argc will contain, after executing the program, a number of parameters. the min number of parameters is 1 , because the program always counts as a parameter the name of the game executable. The table argv[] is a list of text strings , and will contain as many elements as are indicated in the variable argc , but the name of the program will always be stored in argv[0] . Note: When a program executes from the DIV environment, it will not receive any more parameters, just the name of the executable. Therefore these variables will be useful only for the versions already installed in the programs. ---See: global data GLOBAL STRUCT net STRUCT net; device; // Connection mechanism com; // communications Port speed; // Speed of connection number; // Telephone number init; // Modem initiation string mode; // Mode (press or tone) server; // Indicates if the PC is a server max_players; // Max number of players num_players; // Current number of players END This data structure requires you to have extensive programming experience to know how to create a game oriented for net connection (you can find out more information in the user's manual ). It contains data about your PC's net hardware, which are needed in conjunction with the functions net_join_game() and net_get_games() . The structure net has only one register. In its different fields are established the parameters which define the type of connection. device - Mechanism with which the connection will be established, it can be one of three values: 1 - Connection in one local net , with protocol IPX. 2 - Connection by cable (only two crews). 3 - Modem connection (only two crews). For the connection mechanism to function the fields of the structure net must be initiated, because many of these parameters are needed to control the mechanism. com - communications port used for the connection, it means, the number of COM mechanism (from COM1 to COM4), indicating it as numerical value between 1 and 4 . This field only needs to be defined for connections by cable or modem. speed - speed in bauds (number of bits per second), up to 115000. This speed must correspond to the cable or modem's capabilities, and to the amount of data the program requires to run. This field only needs to be defined for cable or modem connections. number - Telephone number, of course this field is necessary only for modem connections. For example, the telephone number which the modem needs to dial must be assigned with a statement like the following: net.number=\"912345678\"; . init - Initiation string, it is a field only required for modem connections; for example a statement like: net.init=\"ATZ\"; . mode - mode in which the modem connection must be established (also only for this connection mechanism), the values can be one of the following: 0 - Pulse. 1 - Tones. server - indicates if a PC (computer) is the server. This (field is only for reading, it can't be modified). In a connection, only one PC will have the field net.server being the value 1 , this PC will be the server of the game, and will coordinate and control the most important actions of the program. max_players - The max number of players which is allowed per game, from 2 to 16 . This field is useful only for LAN (local area network) connections, because in cable or modem connections the max number of players will always be 2 . This number must coincide with the max number of registers the global structure has used in its communication parcels between the different PCs. num_players - The current number of players connected to the game, from 1 to net.max_players . This is a dynamic value, which changes as (players connect and disconnect from the current game) in real time. The game program must predetermine if players can dynamically enter and exit from the game as they wish, or if all of them must be connected before the game starts. ---See: global data - net_join_game() - net_get_games() GLOBAL STRUCT m8 STRUCT m8[9]; z; // Priority of impression camera; // Camera identifier height; // Camera height angle; // Vertical angle END This structure of 10 registers contains certain fields concerning the modifiable parameters for mode 8 windows . The ten registers have the same field names, but each one of them modifies the parameters of a mode 8 window differently (because up to 10 mode 8 windows can be activated). A mode 8 window can be defined as a region of the screen which shows a three-dimensional map of sectors. For a register (from 0 to 9 ) of the structure m8 to have any sense or purpose, you must first activated its corresponding mode 8window (from 0 to 9 ) with the function start_mode8() (see this function for more information about mode 8 windows}. The fields of this structure are complementary to the call parameters for this last function. To see a practical example of a mode 8 window, you can look up help about the function load_wld() or about start_mode8() . form of use for an m8 structure : To access these fields the name of the field must be preceded by the word m8 , the register number in brackets and the symbol . (full stop) . For example, if two mode 8 windows are initiated, the number 0 and the number 1, you can access to the camera variable of both windows with the terminology m8[0].camera and m8[1].camera , respectively. When you access mode 8 window number 0 you can also omit the brackets around the window number, this means, that the variable m8.camera and the variable m8[0].camera are, to all purposes, the same. In continuation a detailed description of each field is shown z - priority of impression of the mode 8 window, where the plane of depth (layer)that this window must be painted in is indicated, with respect to the rest of the processes. By default, this variable has the value 256 which means that, as processes by default have their local z variable set to layer 0 , the mode 8 window will be painted to a plane of further depth, or more to the background, with the processes' graphics being displayed in front of the window. To change this situation you can modify the variable z of the window (for example change it to ** -1 ) or the variable z of processes (for example place it at 257**), then the process graphics will be hidden behind the window. camera - Identifier code of the process where the camera is situated. To move the camera which controls the visible region of the mode 8, all you need to do is create a mode 8 process, in other words one which has its local variable ctype = c_m8 , and put its identifier code in the camera variable of this structure. Then, in order to move the camera's position you only need to modify the local variables x , y , z and angle of this process and, for instance, use the function advance() to move the camera forward. height - camera height with respect to the process, by default this field is initialised as 32 . The mode 8 process will be positioned on screen in its vertical coordinate z , its local variable height determines the height of the main process, and the field ( m8.height ) determines the height of the camera (the user's viewpoint of the process with respect to its base). angle - vertical angle of the camera, the value of this angle is between ** -128 and 128 . It defines whether the camera is pointing upwards or downwards. When m8.angle values 0**, which is the default value, the camera will be looking horizontally. The horizontal angle will be the local variable angle of the main process which is used as the window camera (which identifier is contained in m8.camera ). See also these other local variables with respect to mode 8 . LOCAL radius LOCAL m8_wall LOCAL m8_sector LOCAL m8_nextsector LOCAL m8_step ---See: global data - start_mode8() c_m8 constant: c_m8 This constant is used to assign to the predefined local variable ctype which serves to define the type and number of coordinates (dimensions) a process will have. Its value is set to 3 . This value (3) is the value the variable ctype understands as meaning the graphic coordinates are contained in a mode 8 window, a three-dimensional sector map which the graphics are shown. For more information about mode 8 windows , you can access the function start_mode8() , used to activate them. Other constants exist which are used for other coordinates systems, here is the complete list : c_screen - coordinates of screen c_scroll - coordinates of scroll c_m7 - coordinates of mode 7 c_m8 - coordinates of mode 8 ---See: constants - ctype - start_mode8() GLOBAL STRUCT dirinfo STRUCT dirinfo; files; // Number of files in list name[1024]; // File names END This global predefined structure is used as the return value of the function get_dirinfo() , to contain the list of files in a directory (or folder). It consists of one structure register, which groups one variable files and one table of pointers in the text strings ( name[] ). In continuation a detailed description of each field is shown name[] - The function get_dirinfo() only returns the total number of files listed; the names of these files are saved in the global structure, in the table name[] (the first name of file is saved in dirinfo.name[0] , the second in dirinfo.name[1] , etc.). files - The total number of files listed which this function returns are also saved in this field (in dirinfo.files ). The list of file names are always saved in alphabetical order, the function qsort() can be used to order the structure by other criterion. ---See: global data - get_dirinfo() GLOBAL STRUCT fileinfo STRUCT fileinfo; string fullpath[254]; // Full name drive; // Drive letter string dir[254]; // Directory string name[7]; // Name string ext[3]; // Extension size; // Size (in bytes) day; // Day month; // Month year; // Year hour; // Hour min; // Minute sec; // Second attrib; // Attributes END This global predefined structure is used as the return value of the function get_fileinfo() , to contain the attributes of a file (or subdirectory). It is a one register structure, which groups different strings of text (data of type STRING ) and numeric variables (data of type INT ). Below is a detailed description of each field is shown fullpath - Full name (including the path). The file path can be specified completely (beginning with the root directory of the drive, such as \"C:\\WINDOWS...\") or relative to the current directory (starting from where the game executes, such as \"MAP\\MIOS...\"). In all cases, fileinfo.fullpath always returns the full path from the root directory, including the drive letter. drive - Drive disk where the file is situated. The drive disk is returned not as its corresponding letter, but as a number, establishing the following correspondence: 1 for A: , 2 for B :, 3 for C: , etc. dir - The directory where the file is situated. This string not only returns the name of the folder or directory where the file is, but also the full path, beginning with the current directory and listing all the directories in the path (for example \"\\DIV\\MAP\\\") relative to the directory of the program executable. The return value always has an inverted bar () at the beginning and at the end. name - the filename, this field ( fileinfo.name ), returns the name of the file, without its suffix/extension, up to a maximum of 8 characters . ext - Extension of the file. The extension of the file is returned in this field, in a string which includes the point which separates the filename from its extension. size - file size, this value will be 0 if the information refers to a directory. The size returns as a number of simple data, this means, as a multiple of data like INT (number of bytes in multiples of four (4,8,12,16 etc...)). It is possible to change this relationship by modifying the global variable unit_size ). day - Day of the month of the last actualisation of the file. month - Month of the last actualisation of the file. year - Year of the last actualisation of the file. hour - Hour of the last actualisation (from 0 to 23 ). min - Minute of the hour. sec - Second of the minute. attrib - Attributes of the file, they indicate the characteristics of the file, if it is a system file, a read-only file, an archive file ,etc. This value is the sum of the following constants: 0 - Normal file. 1 - Read-only file. 2 - file archive. 4 - System file. 8 - Volume Label. 16 - Subdirectory. 32 - file speed. For example, for a system and archive file, the value of fileinfo.attrib would be 6 (2 archive + 4 system). ---See: global data - get_fileinfo() GLOBAL STRUCT video_modes STRUCT video_modes[31]; width; // Width of mode height; // Height of mode mode; // Number of mode END In the global predefined structure video_modes , at the beginning of all programs, the list of VESA modes supported by the PC's video adaptor are detailed (all of them of 256 colours ), up to a maximum of 32 (from [0] to [31]). The number of found VESA modes is saved in the global variable num_video_modes . This information is generated by the system automatically, so you don't need to call any function. For all found modes the following information is registered : width - Number of horizontal pixels of the video mode. height - Number of vertical pixels of the video mode. mode - Number of mode. This value can be used directly as a parameter for the function set_mode() . Once the width and height of the video mode which you want to activate has been selected, and therefore the number of registers its structure shall consist of has been defined, you must then activate it by calling the function with : set_mode(video_modes[ ].mode); Note: Besides the registered modes in this structure, there also exists a list of standard video modes, which numbers are contained in the constants m320x200 ... m1024x768 . ---See: global data - num_video_modes - set_mode() GLOBAL channel[] channel[31]; // Use of sound channels--- The global table channel maintains information about the use of the different (up to 32) sound channels of the audio system. Each time when you play a sound with the function sound() , it is sent to one of these channels. And if the playback of one musical module with the function song() is initiated, a determined number of channels (up to 24) are reserved for it. In this table, each position represents one of these sound channels, and the system sets the value of each position to 1 when its respective channel is used. The function change_channel() allows you to modify the parameters of each one of these channels. Note: The system will never automatically set the value of the positions of the table channel to 0 , this must be done with the program code, and similarly the program must determine when a channel is used once more. ---See: global data - change_channel() GLOBAL vsync vsync=0; // Wait the vertical retrace--- The global predefined variable vsync defines a logical value (0 or 1) which indicates if it is necessary to wait before doing a vertical retrace the following frame is converted to video (when all processes execute the statement FRAME ). By default this variable will be set to 0 , which means, the process does not delay the vertical retrace before converting each frame to video. To indicate to the system that it must delay the vertical retrace you must set this variable to 1 (with the statement vsync=1; ). Note: Delaying the vertical retrace can make movements more soft to the eye (this effect is visible most of all in the panoramic effects, see start_scroll() ), but delaying the retrace will also slow the programs down in the great majority of cases. ---See: global data GLOBAL draw_z draw_z=-255; // plane of depth of the primitive graphics --- The primitive graphics are such things as straight lines, rectangles, circles, etc., which are painted with the function draw() . In this global variable the plane of depth in which the primitive graphic must appear on screen is indicated, this means what must appear in front and what must appear behind on screen. The plane of depth can be any whole number inside the range ( min_int ... max_int ), the bigger the number the more to the background the frame will be situated . The process' graphics have their local z variable set to 0 by default, the texts text_z are set to ** -256 and the mouse pointer has its z - value mouse.z set to ** -512 by default. This means, that by default, if these values are not modified, the primitive graphic will appear in front of the processes, but behind the mouse pointer and the texts. Note 1: The variable draw_z is GLOBAL for all primitive graphics, in other words, they cannot be represented in different planes. ---See: global data - draw() GLOBAL num_video_modes num_video_modes; // Number of detected video modes--- The global variable num_video_modes contains the number of VESA video modes which were detected in the system's graphics adaptor. The parameters of each one of these modes are registered in the global structure video_modes , therefore the variable num_video_modes defines the total number of registers defined in this structure. Note: Besides the modes registered in this structure, there exists a list of 10 standard video modes , which numbers are contained in the constants m320x200 ... m1024x768 . ---See: global data - STRUCT video_modes - set_mode() GLOBAL unit_size unit_size=4; // Minimum unit of reading/writing--- The global predefined variable unit_size indicates the minimum unit of reading and writing for the functions of files situated in handles . By default it always has the value 4 , because 4 bytes is the unit size of the standard data INT (32 bit whole number), and each piece of data has 4 bytes assigned in memory (see the assignation of data in memory ). The functions which count up the number of these unit_size blocks a variable contains are the following: fread() fwrite() fseek() ftell() filelength() And also the field size of the global structure fileinfo . The minimum size of 4 implies that it is impossible to write to or to read from any files whose length is not a multiple of this number. This size can be changed; for example assigning 1 to unit_size (with the statement unit_size=1; ). By doing this, all lengths of the previous functions will be indicated in bytes (and not in units of data). However, after changing the unit size, you must remember the following: SIZEOF() will continue to return the data length (in units of 4 bytes). For example, to save a table on the drive it will be not enough to indicate sizeof( ) as its length, you will also need to multiply this value by 4 (if its unit_size is defined as 1 ). The functions of files save() and load() (which are not functions based on the file handles ) will continue to indicate file length in data. The functions of dynamic memory malloc() and free() also will continue to work with the length in data, therefore adjustments must be made to cater for working with both groups of functions. ---See: global data - Alignment of data in memory LOCAL radius radius; // Radius (width) of the mode 8 processes --- This predefined variable is LOCAL , that means that each process will have their own value in its variable radius . This local variable is used exclusively in mode 8 processes (which have assigned c_m8 to ctype ). radius indicates the radius, or horizontal size, of the process. The system requires this value to calculate any collisions with the limits outlining the borders of the sectors of the three-dimensional map. The smaller the value of radius is for a process, the nearer it can be to its walls and, therefore, the bigger the pixels (or texel) of its textures will be. Note: For more information about mode 8 windows, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8() LOCAL m8_wall m8_wall; // Wall number of the sector map --- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_wall . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). the system stores in the variable m8_wall , the number of the wall the process has just collided against. This information can be useful to detect distinct active zones inside a map of sectors (such as ports, interrupts, etc.). Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to set up regions of this type. ---See: local data - start_mode8() LOCAL m8_sector m8_sector; // Number of sector in where the process is--- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_sector . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_sector the system automatically saves the number of the sector over which the process is situated, inside the map. The information about the sector number can be useful to program events where a process enters the specific sector. Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8() LOCAL m8_nextsector m8_nextsector; // Sector the process is directed towards--- This predefined variable is LOCAL , that means that each process has its own value in its m8_nextsector variable. This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_nextsector the system automatically saves the sector a process is directed towards. This means that, when the process collides with one of the map walls (borders), the system checks to see if any other sectors exist beyond this boundary, and if so, will store its number in this variable. This information can be useful, for example, to obtain the heights at which this sector is situated (See get_sector_height() ) and, in this way, can check if the program must adjust its height, and by how much, to proceed to the named sector. Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8() LOCAL m8_step m8_step; // height to which can lift the process--- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_step . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_step the maximum height which the process can be raised to reach the sectors is given, as \"the height of step\" which this process can rise by. When a process comes across a more elevated sector, the system checks with help of this variable to see if the process can reach this elevated sector, if the answer is yes the new height of the process will be set automatically and, but in the contrary case, the process will stop (it will collide with the boundary that separates both sectors). Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8() GLOBAL fps fps; // Number of frames per second--- The global predefined variable fps (frames per second) maintains the number of frames per second which the program shows. This variable is set by the internal processes of DIV Games Studio automatically. It doesn't determine this value in an instant, but rather takes an average over the last few seconds. The function set_fps() allows you to set the number of frames per second of the program, but this establishes the ideal number of frames and not the actual (which is stored in fps ). This means, that this variable serves as a counter to determine how many frames per second, on average, are converted to video. Note: The variable fps contains data only for reading, and its value cannot be modified by the program. ---See: global data - set_fps() Welcome to DIV 2015! This help file outlines the basic concepts required in the usage of the DIV Games Studio development environment. Using this electronic help you can access a lot of information about this environment, but even so, the learning of the programming language and the menu options are described only in the User's manual . Note: If you are using the DIV programming environment for the first time, you should know that in order to exit from DIV (or any game created with DIV), you should use the key combination ALT + X . What's new in DIV2? New language commands and variables New environment aspects introductory chapters How to use the help system Frequently asked questions (FAQ) Resolution of configuration problems What is DIV Games Studio? Working with windows Types of windows Fixing a video mode The configuration window First contact with the language Debugging your program DIV Games Studio appeared on the market in December 1998 as the first development environment with a programming language designed exclusively for games programming. In the beginning, our wish as developers was not the creation of a professional environment, but more to create a simple and interesting environment which could serve as an introduction to the fascinating world of games development; something like a \"game to make games\" in which any person could learn how to program. The very good response to DIV1 leads us to make this second version of the environment, in which the same philosophy is maintained. A great number of received opinions, criticism and wishes permitted us to create the new DIV Games Studio with improvements in all areas. We intended to improve, although only a little, all areas of the environment. In this sense there are major differences with the previous version, (and they are very practical and logical ones). We would like to thank everyone who has supported our ideas and this product. At the time of releasing this second version we don't know if an alternative to the DIV environment exists, which although on the one hand seems regretful, it does give us pride in the knowledge that such an environment exists here. The DIV Games Studio team. New language commands etc.. in DIV version 2.0 More extensive programming language. The programming language has been enlarged, including many new characteristics and internal functions, the more prominent of which are detailed below. The compilation options are a new characteristic of this version, which allow you to adapt the process of compilation to the individual requirements of each project (see Compiler_options ). - In addition to the first version's data (which are now known as INT ), there now also exists data of the types STRING (strings of text), WORD (16 bit positive whole number values), BYTE (8 bit positive whole number values) and POINTER (pointers, to all these types). - Also 2 or 3 dimensional tables and structures (also of any of these types) can be defined (see the declaration of a table ), and the structures can be initiated globally (see declaration of a structure ). - The new FUNCTION blocks behave in a similar way to the functions of other programming languages, they execute sequentially (and not parallel as the processes do), not returning until they are finished. - Different aspects of the program debugger have been improved, with new functions and support for new types of data. Also new are the time profiles , which you can access from the debugger using the keyboard command F11 , here you can observe the time taken in the execution and painting of each process. - The error control system for the programs has been improved, creating a more stable and better executable, there also now exists the possibility to ignore certain execution errors to allow the program to continue running (see the function ignore_error() . - new functions of file management have been added, which give you much more flexibility and potential over the way a program handles files; see for example fopen() , fseek() , get_dirinfo() , chdir() , remove() ) or disk_free() . - Besides support for CD-Audio music and digital effects, there now exist different functions for the reproduction / playback of music modules MOD , S3M and XM (see load_song() , song() or set_song_pos() ). - Optimised code generator. The code generated for the programs is better and faster (at least 60%) than the previous version. Also the created programs EXE are much smaller. - Functions for playing games over the internet or other network. With DIV Games Studio 2, it is possible to create games to play by cable , modem and local net IPX . This functionality is very simply controlled by the functions net_join_game() and net_get_games() . - Also new is the integration into the language of the ability to manipulate strings of text, with data of type STRING , many new functions (such as for example strcat() , strchr() , upper() or strdel() ) have been added along with adapted syntax to work with string expressions directly in the language. - Dynamic memory support . It is possible to ask for and free up memory dynamically whilst a program is running, thanks to the functions malloc() and free() (complemented with the new data type POINTER ). Also the function memory_free() allows you to determine the free disposed memory in the system at a certain point in the program. - You can also now order and disorder data, with the simple function qsort() which permits you to order and disorder data structures, taking any field as its index. - Another new feature is the ability to search for a path . This is achieved with different functions (see path_find() ) which, for instance, allow you to find the shortest and best available routes between two points, avoiding any obstacles. - Compression of data. Everything is more compact; the executables and installed data (can be created as compact and protected installations ). Also functions of compression are included in the language (see compress_file() ). - New mode 8. A new mode with up to 10 screen regions, which allows you to visualise maps of three-dimensional sectors. These three-dimensional environments also include an integrated editor in the environment and many specific functions (see for example start_mode8() , set_sector_height() , or set_fog() ). - And much more. What's new in the language doesn't stop here, there are many other improvements and functions (besides the bugs in the original version which have been fixed). Outlined below we describe what else is new in the DIV programming language. - A new function, called force_pal() , allows all {graphics loaded in a program to adapt automatically to a palette} at the time of execution. Functions for data encryption also exist, such as encode() , encode_file() and decode_file() . The library declarations reside now in the headline of the program, just after the PROGRAM statement (see IMPORT ). It is now possible to create programs in much more video modes , because the available VESA modes can also be detected (See video_modes ). In this new version assignations inside a condition are prohibited, to simplify the programming for less advanced users. However this can be changed (see _extended_conditions and _simple_conditions ). Now it is possible to define the max number of processes which can be active in the program during execution (see _max_process ). It is now possible to define literals over many lines , to do this the text must only be divided into distinctive literals, and put successively (see the limitation symbols of literals ). The sound system is completely new, and it is now possible to play back WAV files of better quality in the programs (See load_wav() and new fields of the structure setup ). Also new sound functions such as change_channel() or is_playing_sound() have been added. Also it is now permitted to use directly frames of PCX format in the programs (See load_pcx() ), and to save these files (See save_map/pcx() ). Functions now exist to fix a colour of the palette , such as ( set_color() ) and also to localise colours ( find_color() ). Trigonometric mathematical functions as sin() , cos() , tan() , asin() , ... have been added. Also a primitives painting tool has been included to create distinct graphics on screen: such as lines, rectangles and boxes, circles, ... (See draw() ). other functions have been added which increase the existing possibilities in the creation of programs, such as screen_copy() , write_in_map() , calculate() , load_screen() , xadvance() , new_map() , ... Also you can count the frames per second (See fps ), obtain the parameters of the program (See argv[] ), delay the vertical retrace (See vsync ), control the mouse in the programs better (See mouse.cursor and mouse.speed ), etc. And of course, all functions, data and possibilities which were available in the first version of DIV Games Studio, still remain! :) --- See also: New graphical environment changes New additions to the environment in version 2.0 More flexibility and simplicity in use. The development environment of DIV Games Studio has evolved into several smaller modules, and together they form a more intuitive structure than in the previous version. A new help. The help section has been restructured, and of course covers everything that's new in the DIV language. The window includes a new navigation bar. - Multiple paintbrush sizes. In the graphical editor paintbrushes of various sizes and forms can now be selected, either in monochrome or in greyscale. By pressing the key T you access the new dialogue; new paintbrushes can also be added, adding them to the file BRUSH.FPG of the SYSTEM directory. - Cover a Picture with coat or textures. In the graphical editor using the key U you can access the new dialogue where you can select any of the maps from the desktop as a texture to paint onto the surface of an image (with the key X you can see and allocate this texture). The aerosol tool has been improved, as has the bar of shade checkpoints , and also new keyboard commands were added (such as K to copy a graphic in a window, or +/- to change the checkpoint). - Graphical visualisers. Almost all windows to open files can display a square window thumbnail which allow you to view the contents of these files before they are loaded. It is also possible {to load different files at once} highlighting them with the mouse while the control key is held down (the Shift key allows you to highlight isolated consecutive graphics). - Developed system of files. In this version the internal management of the FPG files has been improved; errors have been eliminated, thumbnails of the contained maps can be viewed, lists can be printed, a complete FPG file transferred to a map and vice versa. - Sound effects editor. The audio has been completely revised, permitting many more operations, formats and including a mixer and effects editor of the sound. You can access this editor from the sounds menu. - Evaluation of expressions. Now you can access the new calculator windows (from the system menu) to evaluate numerical expressions while programming, without having to exit from the DIV environment. - Sprite Generator. The character generator is also a new characteristic of this version. It was made to create a base on which the realistic pictures of humans and animations can be realised. These photo-images can then be modified in the graphical editor. - Three-dimensional maps editor. A menu for 3D maps, their editor and all functions related to them in the programming language, are also a new characteristic of this version of DIV Games Studio. - Time profiles. From the program debugger you can access, by pressing F11, the time profiles of the program. These statistics indicate the time consumption of a process during the executing of the program, and allow the manual optimisation of the speed of these programs. - New examples. Several sample games and programs developed by users of the previous version of DIV Games Studio are included in this version. Also, on the CD-ROM you can find multiple shareware utilities available for free use in this development environment. - Facility of impression. This version of DIV Games Studio allows you to print, in addition to a program list, lists of the graphics contained in the FPG file and the electronic help pages. - Volume Controls. Amongst the improvements included in the audio system, there now exists a better volume level control, in the environment and the program. In the CD player window there is a small button which gives you access to the mixer. - Library of graphics. The library of graphics included in the program has been enlarged and better structured. Also now maps can be imported of any colour depth in the formats BMP, PCX or JPG. - New installation system. The installation system of the program has been completely re-done, generating a more compact and protected installation, and using a more intuitive and graphical adaptable interface . - And much more. Many more small improvements in the environment exist, many of them imperceptible, but they make the environment more powerful and easy to use. Outlined below you can see in detail the more relevant of these. - The process of entering and exiting from the environment has been optimised , as has the execution of programs from it, also the environment loads faster and all delays between processes are shorter. The program editor is now in colour , highlighting the key-words of the language, also you can define more clearly, for example, the tabulation size. Now, after loading the environment, you have the option to {continue with the previous session} or start a new one . It is possible to select more visualisation modes for the environment, depending on the modes supported by the installed video-card and VESA adaptator. A colour palette editor simplifies the generation of explosions (which can now be aborted) and the preparation of the background (a preview is now shown). The speed of the mouse pointer can be configured using the small bar presented in the configuration window of the system menu. In the fonts windows a sample of letters appears , which indicate which collection of characters are selected. It is possible to generate fonts of letters with shadows or outlines , by simply creating them with an outline of 1 pixel of the background colour. --- See also: New features of the programming language Resolution of configuration problems General resolution of audio problems. If the audio system couldn't be initiated, it is most likely because of a sound card conflict. This problem is often produced by one of these causes : The card is being used at the same time by another program . It cannot initiate the sound if any other program is reading or writing data via the card (such as an MP3 player or sound capture device). A problem can occur with the auto-detection of the soundcard's parameters. You must execute the sound configuration program or define these values in the variable BLASTER or ULTRASND of the system environment (you can find more information in the user's manual for DIV Games Studio 2). Because the soundcard is incompatible with DIV. If the card is not a GRAVIS (tm) or SOUND BLASTER (tm), it may be incompatible with DIV Games Studio. The majority of commercial cards are compatible with SOUND BLASTER, but may not be 100% compatible and may present some problems. If your particular problem doesn't fit into any of these three cases, you must first execute the sound configuration program. This can be called from DIV by pressing F4 , or loading the program SETUP.PRG from the SETUP directory , and executing it with the key command F10 . In this program you must input the parameters of your sound card. To obtain these parameters in MS Windows it is probably best to consult the soundcard's handbook, but normally you can also access them the following way: pressing with the right mouse button in \"My Computer\", activating the Properties menu \\ Device Manager \\ Sound, video and games Controllers, selecting your audio card (normally one compatible with \"Sound Blaster\" or \"SB\") and pressing the Properties button. Then a dialogue will appear with the characteristics of your sound card where, in the Resources pane you'll find: 1. The IRQ number of your card as an \"interrupt request value\". 2. The DMA and of DMA2 (also denominated as HDMA or DMA16) numbers which are the two \"direct memory access\" values. 3. The port number as the initial value of the first \"enter/exit value\". Also you can try to configure the sound system indicating in the configuration program a simpler card (previous to yours). For example, if you have a soundcard compatible with a Sound Blaster AWE 64 or 128 and cannot get the sound system to initiate; try to configure the system as if it were a Sound Blaster 16 , or Sound Blaster Pro card. As the last recourse, if it is not possible to configure the sound in your system, you must deactivate it. For this you must execute the configuration program and select the value in the field which defines the type of card. Then press the button to establish this configuration and deactivate the sound in DIV Games Studio 2. If you are unable to hear the sound effects in your program on your PC, you probably have a sound card which is not 100% compatible with the Sound Blaster or Gravis Ultrasound family of cards. Consult your dealer. Note: The reproduction of CD-Audio is independent of the digital sound system whose configuration is described here; therefore CD music will be reproduced although the sound system may not have been correctly initialised. Video or Graphics card Problems. If at any time DIV enters a resolution which cannot be displayed properly, the first thing which must be done is to exit from the environment by pressing the key combination ESC+control (or ALT+X and Enter in succession) and, then, re-enter the program in safety mode. To enable this mode you must, from the MS-DOS command prompt and in the directory (FOLDER) in which the program was installed , execute the following command: ** D /SAFE** This way you will load up the environment in a low resolution (in 320x200, the most compatible mode), from this mode you can attempt to put in other resolutions which will be compatible with your graphics card and with your monitor. On those PCs where the graphics card is not compatible with the standard VESA system you must install VESA driver for the card. For this, you must contact your card supplier or technical support of your hardware for the driver. ( A driver is a small program which must be installed on the PC to give support for some hardware or utilities such as, in this case, your video or graphics card). Problems with the mouse. If the mouse is jumping on the screen, instead of moving smoothly from point to point, it is because you're using an incorrect or out of date mouse handler (the mouse driver is not functioning properly). You can resolve this problem in one of these ways: 1. Contact with the supplier of your PC to obtain the latest driver for your mouse. 2. Change the resolution of the program (with the option system\\video mode ) to another which does not produce this problem. 3. (MS-DOS, only for advanced users). Comment out the line in your autoexec.bat file in which the mouse driver is loaded. This can be done from the DIV environment, by loading this file (situating on the root directory of your hard disk) with the key command F4 and adding the word REM at the beginning the line which loads the mouse driver (a line which normally finishes with the text ... mouse.com). Then press F2 to save the file, close it (pressing on the upper left corner of the text window), exit from DIV (ALT+X) and re-start your PC. If you then have problems with another program which requires this driver, return to edit the same autoexec.bat file and remove the word REM which was added. Solution of possible installation problems. If you find any problem, check the minimum requirements indicated in the program. If you have doubts about one of the elements consult the technical support of your PC or your PC supplier. The most likely problem is reading from the CD-ROM drive; for this, clean the surface of the DIV Games Studio CD carefully with a clean and dry duster, and attempt the installation of the program once more. Manual installation If you couldn't install the program correctly and have a lot of free space on the hard disk of your PC (sufficient to allow a maximum installation) you can attempt a manual installation of the program, by following these steps: MS-DOS users - Supposing that your CD-ROM disk drive is the letter D:, select the CD-ROM drive with the following command: ** D:** And press Enter. Then introduce the following commands (supposing that your hard disk is the C: drive): ** XCOPY DATA*. C:\\DIV*. /S** ** C:** ** CD \\DIV** ** DEL INSTALL . ** Pressing Enter after each one of these commands. If you have sufficient space the program will be installed without any problem, introduce this command to execute it afterwards: ** D /SAFE** For the next steps in executing the program, follow the conventional instructions. Users of Windows 95/98 - Open the MS-DOS prompt (double clicking on its icon, or via start menu \\ programs \\ ms-dos) and follow the instructions for MS-DOS users. For the remaining executions of the program you can use the instructions that come with the operating system, remembering that the program will be installed in the DIV folder of your hard disk. If you cannot get the program to function correctly with these suggestions, then contact your FastTrak Technical Support, its tel. is (44) 1923 495497 (01923 495497 for UK users) during normal office hours Monday to Friday from 09:00 to 17:30 or go to http://www.div-arena.com and try the message forums or the live chatroom. Remember though, that as DIV Games Studio is a big selling product with limited technical support facilities, it is best to first try and follow carefully all instructions and check the website before making a call to this service. Important: This technical support service does not provide any consultation regarding the programming language, because we could not give any more advice than is contained in the help file and the user's manual of the program. With these you can find a solution for any doubts regarding the programming language you have. What is DIV Games Studio? It is a graphical environment which integrates a new programming language for videogames together with other utilities such as a painting tool, tools to create fonts, palettes, etc. The programming language was made exclusively for the creation of games and, as you can see, allows you to obtain very good results with very short and simple programs. It is not necessary to know how to program to use it, DIV was designed so that the user could learn to program with it. It has a user-friendly environment to make you lose the fear of the word \"programming\" ... ---See: Working with windows - Introduction to 2 Working with windows The windows, can be moved to any position on screen if you press on the title bar with the mouse and drag it to the new position. Title bar. - Is the top zone of the window, where the name of the window is shown in white against a blue background. When the name of the window appears in grey scale, it is because the window is not selected (as another window is currently selected ), to select it press on it. Drag. - This term is applied inside the graphical environment to mean the action of holding the mouse button down over an object, moving it to the new position, and finally releasing the mouse button. To ask the system to place the window automatically, you must double click with the mouse on the title bar of the window. If the system finds a better position for the window, it will move it there. The windows can be in different modes , and therefore their functions and operations will be distinct from each other. These modes are described below : 1. Active windows: Are those which, normally, have an illuminated title bar, in white letters against a blue background and are situated foremost on the desktop. 2. Inactive windows: These type of windows have a dark title bar, in black letters against a dark grey background. To activate one of these windows simply click on them with the mouse. 3. Windows in the second plane: These are windows which are obscured; this is because they are at least partially, covered by other windows. With these windows you can't interact with them until they come into the foremost plane by clicking on them with the mouse. 4. Icons: The icons are the minimised windows, this means, the windows which were reduced temporarily. The icons don't have a picture, just a button with the sign \"+\" followed by the title of the window. Note: To drag the graphics (to a file, to the desktop, etc.) don't press on the title bar of the window, but on the contents of the window. This means, you must press the mouse button in the middle of the window and, without releasing the mouse button, move it to the new position. ---See: Types of windows - Introduction a DIV 2 Types of windows The windows can be classified by their function, into the following groups: 1. Interactive dialogues: These are windows which are used to impart information to the user; there exists a huge variety of them, which you'll see in the respective options. 2. Error message Windows : Are the dialogues in which the title bar appears in white against a red background and inform the user about the problem which has arisen. 3. Options Menus : These menus contain the list of options which call other menus, windows or dialogues after they have been clicked on. All these menus stem from the main menu. Some menus may have certain options disabled (a pointer is shown with the prohibited symbol if you place the mouse over it); this is because these options interact only with the specific types of windows, and there is no window of this type currently active (it must be created or loaded beforehand). 4. Programs: In these windows the programs are created and are effectively text windows. To edit a program its window must be activated (only one program window can be activated at any one time). The text is similar to that of other text editors (supports the standard DOS command EDIT). To ask for help in a program about a specific word of the programming language you must place the blinking cursor (not the mouse pointer) on it and, then, press the key F1 . These windows can be changed in size by pressing on the their lower right button and dragging with the mouse or by pressing the keys control + Z . 5. Maps or graphics: These windows are those which contain a map (bitmap) or graphic and are controlled with help of the menu of maps. They can be loaded from a MAP file (proper format), or imported from a PCX, BMP or JPG file. To edit the graphics you must double click with the mouse button in the centre of these windows thus opening, in this way, the graphics editor (described in the user's manual ). These graphics can be dragged to the background (to make a copy), to another graphic (to insert in them), to a file of graphics (to include them) or to the trash (to delete them), to drag them you must drag from the centre of the windows, and not from the title bar. 6. 3D Maps: These are vector maps created in the 3D maps editor, how a collection of closed polygons is shown in their window representing the vertical section of a plan. Its creation is not a trivial matter, and is explained in the user's manual . These maps are saved on disk in files with the extension WLD. 7. FPG or graphics library files : These windows show the contents of one file on the drive. These files are libraries or collections of graphics used in the game. Their purpose is to load a large quantity of maps into a game. They have two basic modes of function, activated with the help of buttons named \"Info\" and \"Images\" along the bottom of the window. When the \"info\" button is not activated (by default), graphics can be created and moved, or dragged (to the background, to other files, maps or the trashcan). When the \"info\" button is activated, the graphics codes and their descriptions are displayed with a thumbnail image. These FPG files are always controlled from the FPG file menu. The FPG file windows are always just a reflection of the \"graphics file\" contained on the hard disk of the PC, and therefore can be closed at any time, without need to save them before. Their contents will never be lost. The option Files \\ Save allows you to make a copy of the FPG saving it under another name (as temporary or security copy). 8. Fonts of letters: The fonts or letter types are small windows which display the current typography. You must click on them with the mouse to see an example of the font in real size. They correspond to FNT files (official font format) and are controlled by the fonts menu, from which you can access the fonts generator, which is the tool used to create new fonts of letters. The fonts of letters are used inside the painting program and in the programs to write texts. 9. Sound effects: These windows represent on screen a PCM file (press code modulation) or WAV file with a sound effect. They are controlled with the sounds menu, so you can create new effects (with the sound recorder) or edit them. You can find a library of sound effects already prepared for use in the games. To hear these sound effects you must have a sound card compatible with the Gravis Ultrasound or Sound Blaster family, correctly configured and then click over one of these windows. 10. Musical modes: Songs in the formats MOD, S3M and XM can be loaded . They are represented in a small window which allows you to activate or stop its playback. You cannot compose new modules from the environment though. 11. Help window : It is controlled mainly with the mouse, but you can also use the cursors, and the PageUp, PageDown and BackSpace keys to return to the previous page. In the help windows the texts are shown in white which make reference to other help pages. You must click on these references to access to these pages. In the help windows are also shown example programs which can be selected by clicking on their title, executed with the key F10 and closed by clicking ALT+X. 12. Calculators: The calculators windows function as evaluators of mathematical expressions, in the style of expressions presented in the programs. Their functioning is very simple, because you need only introduce an expression and press Enter to see the result. You can use parentheses to indicate subexpressions. Note: The trash window must be activated first from the system menu, with the corresponding option ( System \\ Trash ). ---See: Fixing the video mode - Introduction to DIV 2 Demo Session This is a version of DIV Games Studio 2 designed for evaluation purposes only, and is limited to 31 executions of the program. This demo version is completely functional, and was created with the aim that you could evaluate the possibilities of the program and its compatibility with your system, before obtaining the full registered copy. There are only two restricted functions in this version: The program size which can be compiled is limited by the maximum number of objects allowed in this version. All finished programs (after creating an EXE independent from DIV with the option Programs \\ Create installation ) will be marked with a message stating this is a demo version only. These restrictions don't exist in the commercial version of the program, but in addition remember that the full version also contains a User's manual which is essential to access all the functions of the program and to effectively learn the programming language of DIV 2. Note: The information contained in the User's manual of DIV Games Studio 2 (about what's new in the environment, the program options, a tutorial for the new language, ...) cannot be found in this electronic help. conflict with the sound system The audio system of DIV Games Studio was not initiated because of a conflict with your sound card. This problem is often produced for these reasons: The card is being used at the same time by another program . It cannot reproduce the sound if any other program exists which reading or writing data to the card (such as an MP3 player or sound capture device). A problem with the auto-detection of the card's parameters can occur. You must execute the sound configuration program or define these values in the variable BLASTER or ULTRASND of the system environment (you can find more information on this in the user's manual of DIV Games Studio 2). Because of the incompatibility of the card. If the card is not a mark GRAVIS (tm) or SOUND BLASTER (tm), it may be incompatible with DIV Games Studio. The majority of commercially available cards are compatible with SOUND BLASTER cards, but they still may not be 100% compatible and may present some problems. General solution of the audio problems. If your particular problem doesn't fit into any of these three cases, you must first execute the sound configuration program. This can be accessed from DIV by pressing F4 , loading the program SETUP.PRG from the SETUP directory, and executing it with the key command F10 . In the first chapter of the user's manual you can find the information about how to obtain the parameters of your sound card. Also you can try the configure the sound system indicating in the configuration program as if your card was a simpler one (previous to yours). For example, if you have a card compatible with a Sound Blaster AWE 64 or 128 and cannot initiate the sound system; try to configure the system as a Sound Blaster 16 , or Sound Blaster Pro card. As the last recourse, if it still wasn't possible to configure the sound in your system, you must deactivate it. To do this execute the configuration program and select in the field which defines the type of card. Then press the button to establish this configuration and deactivate the sound in DIV Games Studio 2. Note: The playback of CD-Audio is independent of the digital sound system which configuration is described here; therefore CD music will continue to be played although the sound system has not been initiated properly. The sound system is not working Digital sounds cannot be played back inside DIV Games Studio 2 if the sound system is deactivated. Probably, in the configuration program the option was selected, instead of indicating the type of card you have installed on your PC (or one compatible with it). ---See: conflicts with the sound dispositive Fixing a video mode The option System \\ Video mode gives access to the dialogue window which permits you to modify the resolution used by the graphical environment of DIV Games Studio 2. The video resolutions are indicated as the number of horizontal and vertical pixels the video will be displayed in on screen in this mode and will be a value between 320x200 (low resolution) and the max resolution which your video card permits. To select a new resolution you must click on the list which appears in the window over the resolution desired and then select the button Accept . Note: Some of these video modes can be visualised incorrectly (for example, a resolution which is permitted by your video card but not by your monitor); in this case you must wait 15 seconds for the environment to restore the previous resolution. Don't press any key, don't do anything, just be patient and wait. Selection of the system font. There are two settings allowed to select the font used by the system, which not only have differences in the size of the letters but, also in the size of the windows of the environment. They are : 1. Small font (and small windows). In this mode all windows, menus and pictures are seen in a small size, being ideal for low modes of resolution or a PC with a big monitor (17\" or more). 2. Big font (and big windows). This mode can be activated only in resolutions from 640x480 up and is ideal for small monitors (15\" or less). Note: The font of letters used in the programs and in the help window is independent from that selected for the system, and is defined in the configuration window, also accessible from this system menu. ---See: The window of configuration - Introduction to DIV 2 The configuration window With help of the option System\\Configuration you can access the following dialogue window divided into sections, which are outlined below. Colours windows This first section establishes the colours used by the environment; the colours for background of the windows, the colour of letters / fonts and the colour of the title bar can be selected. To change these colours click on the boxes. The system not only uses these three colour windows but, starting from them, generates a gamma array of colours used for texts, cursors, buttons, etc. Programs Editor This establishes the appearance of the program windows. Different colours for different objects (words or symbols) presented in the program can be selected. 1. Background of the edition window. 2. General colour of letters. 3. Cursor. 4. Commentaries of the programs. 5. Symbols and operators of expressions. 6. Reserved words of the language. 7. Numbers inside the program. 8. Literals, or texts in inverted commas. The text blocks marked inside the editor are seen with the interchanged colours of paint and background. A text box allows you to define the size (n number of spaces) of the tabulator in the programs editor, as a number between 1 and 16. By default the program tabulates every 4 columns. It is also possible to select here the size of the letters of the programs and the help, from 6x8 up to 9x16 points. All fonts of letters are fixed for a particular setup. **Painting Program ** Defines the quantity of memory reserved to carry out operations in the graphics editor, the speed of the mouse pointer and its representation. The quantity of \"memory\" is specified in Kbytes, and by default is set at 1088Kb (more than one megabyte), but it is not necessary to modify this value even if an operation can't be realised in the graphical editor because of not enough memory available (in this case the program will divert more memory to it). Please note though, that the more memory reserved for graphics, the less memory will be disposed in the system for the rest of the actions. The speed of the mouse pointer is defined with the small horizontal bar (faster to the left and slower to the right), and affects the mouse in all window environments, not only the painting program. Global options of the environment 1. Emergent windows. Indicate all windows effects to be visualised, when they are opening, closing, minimising, etc. If this option is deactivated, the environment will lose these effects but will gain a faster response speed. 2. Move complete windows. With this option enabled, windows will show their complete content whilst being dragged, otherwise only the outline will be shown. It can be useful to deactivate this option on slower PCs. 3. Always save session. Means that when exiting from DIV Games Studio, the contents of the desktop and all its objects (programs, maps, sounds,etc.) must be saved. If this option is deactivated then entering and exiting from the environment will be faster, but there is a risk of losing the work which was not saved prior to exiting from DIV. 4. Colour of the lists. Indicates that, when a file with the extension PRG is being edited, all colours previously selected for the editor must be applied. Alternatively only the colours of the background and cursor will be applied. The same applies when you are editing a file which is not a PRG div source program file. Note: If you close the configuration window or press the key ESC all changes you have just made will be lost, and the values of the previous configuration will be restored. ---See: First contact with the language - Introduction to DIV 2 First contact with the language In this section it is explained how to execute the Sample games of DIV Games Studio and quick instructions how to start learning about DIV, receiving the first notions about this programming language. General instructions All included games are simple examples, they don't pretend to compete with the commercial games which can be created with this tool. Although we're talking about complete games, the majority of them are very simple or very short. The aim was to demonstrate the techniques which are used and how the programs are made, by use of examples, instead of huge lists of instructions in which the user gets easily confused. Note: These games can never show the true capabilities of this environment, because practically no single game uses all of them. The majority of the new and potential capabilities of this version of DIV Games Studio weren't used in these example, giving you the opportunity to be the first persons who attempt, or maybe manage, to explore these possibilities to the full. To execute any of these examples you must, first, load the program with the option Programs\\Open program , and then a window will appear with a list of the loaded programs. The help system One of the best ways of learning the DIV environment; after placing the cursor on a reserved word, constant, variable, function, etc., of the language you can press the key F1 to see a help page about this subject. If, after pressing F1, help about the subject doesn't appear (but instead the general index appears) it is because this is not a specific word of the DIV language, and the data or process is not directly from the game language (processes are functions which control the behaviour of the graphics, or 'sprites', in the games). Note: We recommend you begin by learning with simple games, as tutorials or, better still, with the examples included in the electronic help; to access them you must press the Functions button in the help window and, from this page, access the different explanations of the functions of the programming language, from where small examples can be viewed by pressing on their headline or title. Texts which begin with the symbol // (double bar) are explanation comments, they don't form part of the program, but only consist of \"explanatory notes\" about the internal functioning of the program. These comments are often a big help in understanding the functioning of the programs. The comments can also appear between the symbols / and / (covering many lines of the program). To go to one of the program processes (one of the program blocks used to control a graphic or sprite of the game), you must press the F5 key and select the name of the process with the help of the mouse. Execution of the examples To execute one of the loaded programs, press with the mouse on its window and then with the key F10 (this action can also be instigated with the option programs \\ execute). The contents of the games are different, but the majority of them allow you to exit by pressing the ESC key and are managed with the cursor and control keys (See the general commands in the games ). The Pause key can be used in all games to immediately stop the execution of the program. All programs can be aborted at any point, independent of their programming, if the combination of keys ALT+X is pressed. ---See: Debugging your program - Introduction to DIV 2 Monitoring or debugging the programs The more active people can find out more detail about the progress of the games during runtime by pressing the key F12 (from the game itself, during its execution), that allows you to access the program debugger, which permits you to execute the games step by step. Here you can observe all processes and modify their data (if you have convenient data, all dynamic parameters of the game can be changed, the phase number, the lives left, ammunition left ...). In the upper part of this window there appears a list with the processes currently active at any moment (such as toys or graphics which are being used by program). They can be selected with the mouse and, by pressing the button see data , all variables, counters, etc. which the process is using will be seen. In the lower part of the screen appears the lists of the program, which basically are the order in which the PC must action things whilst the game is running. It is normally divided into small blocks which begin with the word PROCESS (one of the reserved words of the programming language). In each one of these blocks the orders for a main element of the game are specified (for example, for a shot being fired, an enemy or an explosion). General functioning of the programs In short, the games always consist of a sequence of frames. Each frame is composed of different elements (or processes)of the game. All these elements must, in each frame, complete a series of operations or calculations (normally very simple) to determine what their appearance must be in the following frame (which picture or graphics the frame must show, in which position, of which size, which orientation etc.) The PC is realising the orders specified for each process until it comes to the orders for the FRAME (frame or fotogram) itself. This order indicates that a process is already prepared to be shown in the following frame, which means, all the parameters which will define its appearance in the following frame have already been allocated. Note: The orders specified in a program are denoted as statements. Each one of these statements indicates an operation or calculations which the PC must realise. In this way, the PC continues realising all these operations and calculations which the orders of each process have specified, until all active processes have reached the order statement FRAME . At this moment, the PC stops executing orders and will focus instead on composing the following frame which must be displayed on screen. In the games these two tasks are consistently alternating, first the orders are executed, and then the frames are composed and displayed. Basic controls of the debugger This can be viewed from the program debugger, with the help of different buttons which allow the actions of the program or game to be realised step by step, visibly on screen. These main buttons are the following: 1. Step. Indicates to the PC to execute the following order of the next process. The next process appears in white in the most prominent list of the debugger, and the following order to be realised (by this process) appears in the program list in the same colour. 2. Exec.process. This button instructs the PC to execute all instructions of the following process until it reaches the order FRAME, this means, it must realise all necessary operations required before the next process can be displayed in the next frame. 3. Foll.Frame. This button is used to advance the game frame by frame. Each time it is pressed, all necessary orders of all active processes will be executed, the new frame will be composed, and finally the frame will be converted to video (the term \"convert to video\" means that the action of one frame of the is composed in the video / graphics card, and thus will be displayed on the monitor of the PC). When a program is realised, all its aspects can be controlled: the order in which the different processes are executed, the order in which the graphics are displayed on screen, the interactions of the processes on screen (when they \"are touching\" one another, for instance), when sound effects must be played, the reactions of each process on the keyboard, mouse, etc ... ---See: Introduction to DIV 2 The last possible term inside this hypertext","title":"Help"},{"location":"help/#invalid-hypertext-link","text":"Error: There is no help page associated to this link.","title":"Invalid hypertext link"},{"location":"help/#how-to-use-the-help-system","text":"The help system works in a similar way to an internet browser window, each page is linked using a hyperlink system. Use the mouse to navigate the help pages, or use the following keys. Cursors - Move the text a single line at a time. Page Up/Page Down - Go up or down one page. ESC - Exit the help window. Backspace - To return to the previous page. These controls can be used only when the help window is selected (to select a window you just have to click the mouse over it). In the lower right part of the screen there is button that you can use to {change the size of the help window}. Simply click on the button, and whilst holding, drag with the mouse to change its size. The words that appear in white colour are {hyperlinks to other help pages} (the mouse cursor will look like a small hand when you are over the words). Click on these words to jump to the relevant page. The examples are small programs or parts of programs that appear in the Help to show the user how to use the functions and operations in the DIV language. All of them begin with a white colour line, as you can see right here: Example program: PROGRAM example; BEGIN // ... END - To try the example program, just click on the white line. These programs can be run with the F10 key and ended by pressing the ALT + X keys, the same as any other program. In the upper part of the help window you can see a group of buttons to navigate the pages. ( << Backwards and >> Forwards), ( Index , Glossary and Functions ), send the current page to the printer ( Print ), and information on how to use the help system ( ? ).","title":"How to use the help system"},{"location":"help/#general-index","text":"Introduction to DIV Games Studio 2015 Help about the program language Glossary of Terms Syntax of a program Declaration of statements List of functions Predefined constants Predefined global data Predefined local data Arithmetic Expressions Logical conditions Key table Codes Language News Help about key table commands Graphical environment Commands Normal Commands in the games Commands in the program debugger Commands in the program editor Commands in the graphical editor","title":"General index"},{"location":"help/#glossary-of-terms","text":"!= ! \" %= % && &= & ' [(](#() ) ) */ *= * ++ += + , -- -= -> - .. . /* // /= / : ; <<= << <= <> < =< == => = >= >>= >> > [ []](#]) ^= ^^ ^ |= || | _a, _b, _c, ... _case_sensitive _extended_conditions _free_sintax _hidden _ignore_errors _max_process _no_check _no_id_check _no_null_check _no_optimization _no_range_check _no_strfix _normal _simple_conditions _subdir _system _volid abs() acos() advance() all_drawing all_sound all_text and angle argc argv[] ascii asin() atan() atan2() begin bigbro break byte c_0 ... c_9 c_m7 c_m8 c_screen c_scroll calculate() case change_channel() change_sound() channel[] char() chdir() clear_screen() clone cnumber collision() compiler_options complete_dump complete_restore compress_file() const continue convert_palette() cos() ctype debug decode_file() default define_region() delete_draw() delete_text() dirinfo (struct) disk_free() draw() draw_z dump_type dup else encode() encode_file() end_fli() end exit() fade() fade_off() fade_on() fading false fast_mixer father fclose() fget_angle() fget_dist() fileinfo (struct) filelength() file find_color() flags flush() fopen() force_pal() for fps frame_fli() frame fread() free() from fseek() ftell() function fwrite() g_height g_width g_x_center g_y_center get_angle() get_dirinfo() get_dist() get_distx() get_disty() get_fileinfo() get_id() get_joy_button() get_joy_position() get_pixel() get_point() get_point_m8() get_real_point() get_sector_height() get_sector_texture() get_song_line() get_song_pos() get_wall_texture() getdrive() global go_to_flag() graphic_info() graph height id if ignore_error() import int is_playing_cd() is_playing_song() is_playing_sound() itoa() joy (struct) joy_filter joy_state key() let_me_alone() load() load_fnt() load_fpg() load_map() load_pal() load_pcm() load_pcx() load_screen() load_song() load_wav() load_wld() local loop lower() m320x200 ... m1024x768 m7 (struct) m8 (struct) m8_nextsector m8_sector m8_step m8_wall malloc() map_block_copy() map_get_pixel() map_put() map_put_pixel() map_xput() max_int max_process_time memory_free() min_int mkdir() mod mouse (struct) move_draw() move_scroll() move_text() near_angle() net (struct) net_get_games() net_join_game() new_map() no_restore not num_video_modes offset or out_region() partial_dump partial_restore path_find() path_free() path_line() pi play_cd() pointer pow() priority private process program put() put_pixel() put_screen() qsort() quality_mixer radius rand() rand_seed() refresh_scroll() region remove() repeat reserved reset_fli() reset_sound() resolution restore_type return roll_palette() s_freeze_tree s_freeze s_kill_tree s_kill s_sleep_tree s_sleep s_wakeup_tree s_wakeup save() save_map() save_pcx() scan_code screen_copy() scroll (struct) seek_cur seek_end seek_set set_color() set_env_color() set_fog() set_fps() set_mode() set_point_m8() set_sector_height() set_sector_texture() set_song_pos() set_volume() set_wall_texture() setdrive() setup (struct) setup_program shift_state signal() sin() sizeof() size smallbro song() son sound() sound_bits_16 sound_bits_8 sqrt() start_fli() start_mode7() start_mode8() start_scroll() step stop_cd() stop_mode7() stop_mode8() stop_scroll() stop_song() stop_sound() strcat() strchr() strcmp() strcpy() strdel() string strlen() strset() strstr() struct switch system() tan() text_z timer[] to true type uncompress_file() drive_size unload_fnt() unload_fpg() unload_map() unload_pcm() unload_pcx() unload_song() unload_wav() until upper() video_modes (struct) vsync while word write() write_in_map() write_int() xadvance() xgraph xor xput() x y z","title":"Glossary of Terms"},{"location":"help/#abs","text":"abs( ) Returns: The absolute value of the expression. Description: Calculates the absolute value of the expression given as parameter. If the result of the expression is negative it will change the sign, if it is positive, it won't do anything. Example program: PROGRAM example_abs; GLOBAL INT values[15]; INT n; BEGIN FROM n=0 TO 15; values[n]=rand(-1000, 1000); write_int(0, 0, n*10,0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to run the function abs()\"); LOOP IF (key(_space)) FROM n=0 TO 15; values[n] = abs(values[n]); // We find the absolute value END END FRAME; END END - This program will print a list of values on the screen that can be positive or negative, when the space bar is pressed it will apply the function abs() to all these values, making all values positive. ---See: Expression","title":"abs()"},{"location":"help/#advance","text":"advance( ) Description: Advances the process in its angle (specified by the local angle variable) as many points as specified in the expression (distance) parameter. To advance in a different angle to the one specified in this variable, use the xadvance() function instead. The value can be also a negative number, in this case, the processes' graphic will advance in the opposite direction to the angle specified. Example program: PROGRAM example_advance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=101; x=160; y=100; write(0, 0, 0, 0, \"Use the cursors (left + right) to change direction.\"); LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END advance(2); // We advance 2 points FRAME; END END - This example will draw a triangle on screen that will advance in the specified direction (2) in the specified local variable angle using this function. Remember that the angle is specified in thousandths of a degree. The local angle variable will be changed using the cursor keys (adding or subtracting 10000, which is equivalent to 10 degrees). This function is the same as executing the following two statements: x+=get_distx(angle, ); y+=get_disty(angle, ); This function just modifies the coordinates of the process. It is possible to use the two previous statements when you would like the process to advance in a different angle to the one which in the local angle variable. This could be useful if you want to advance without rotation. Alternatively you can use the xadvance() function. For example, to make a process advance 8 points in a direction ( stored in a private variable called angle2 ) but rotated in another direction, (the angle variable), you would use: x+=get_distx(angle2, 8); y+=get_disty(angle2, 8); ---See: xadvance() - Use of angles in the language - get_distx() - get_disty()","title":"advance()"},{"location":"help/#change_sound","text":"change_sound( , , ) Description: To use this function it is essential to have a sound card installed which is 100% compatible with Sound Blaster (tm) or Gravis Ultrasound (tm) and have the correct drivers installed. This function only works if it is used after the sound() function is called, which is used to play sounds. Change_sound() modifies one sound that is playing on one of the channels , setting the volume and frequency . The channel is the channel code that is returned by the sound() function. You can play up to 16 channels at the same time, with the same sound or with different sounds. Each time you play a sound it is quite possible that it will be played through a different channel. Each channel has its own levels of volume and frequency. The volume is a value between 0 (minimum volume) and 512 (maximum volume) which determines the noise level that the sound will be heard through this channel. The frequency is a value that affects the speed of the sound through the channel, it controls how deep or sharp the sound is emitted. Valid values are between 0 (deep) and 512 (sharp). Example program: PROGRAM example_change_sound; PRIVATE freq=256; // Medium Value (0..512) vol=256; // Medium Value (0..512) sound_id; chan; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); sound_id = load_pcm(\"help/help.pcm\", 1); chan = sound(sound_id, vol, freq); write(0, 0, 0, 0, \"Press right or left to change the frequency.\"); write_int(0, 0, 10, 0, offset freq); write(0, 0, 20, 0, \"Press up or down to change the volume.\"); write_int(0, 0, 30, 0, offset vol); LOOP // Change the sound change_sound(chan, vol, freq); IF (key(_right)) freq++; END IF (key(_left)) freq--; END IF (key(_up)) vol++; END IF (key(_down)) vol--; END FRAME; END END - In the example a sound help.pcm is loaded and played. Inside the main loop of the program you can change the frequency and the volume of this sound using the change_sound() function to modify these values using the cursor keys. ---See: load_pcm/wav() - sound() - unload_pcm/wav() - STRUCT setup","title":"change_sound()"},{"location":"help/#clear_screen","text":"clear_screen() Description: Delete from the screen all graphics placed on it with the put() , xput() , put_pixel() & put_screen() functions. Example program: PROGRAM example_clear_screen; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"Press [SPACE] to clear the screen.\"); write(0, 0, 10, 0, \"Press [ENTER] to view it again.\"); graph=100; x=160; y=100; LOOP IF (key (_space)) clear_screen(); // Deletes the graphic of the screen END IF (key (_enter)) put_screen(0, 1); END FRAME; END END - In the example a graphic is drawn using the put_screen() function. When the space bar is pressed, the screen is deleted. Pressing the key Enter , you can see the screen again. You can see how the graphic of the process (a ball that appears in the centre) doesn't disappear when you use the function clear_screen() , because the function will just delete the screen. ---See: put() - xput() - put_pixel() - put_screen()","title":"clear_screen()"},{"location":"help/#collision","text":"collision( ) Returns: The identifier code of one process or 0 . Description: This is the function to detect collisions between graphics. Checks if the current process (the one that executed this function) collides with one of the indicated parameter types. It checks to see if the graphics of both processes are overlapped. If a collision is detected, it returns the identifier code of the process which is colliding with the current process. If not, the function will return 0 . If the current process collides with more process of the specified type, the function collision() will return the rest of the identifiers in the successive calls to the collision() function. To get every identifier code of the process that is in collision with the current one, you must not use a FRAME statement between successive calls to the collision() function. As soon as a FRAME statement is reached, the function will start returning collision ID's starting with the first. Something similar happens if you run a call to the function specifying a different type of process; if, after this, collisions are still detected with the previous type, this function will return every code from the first. If you want to obtain every identifier code of the processes of one particular type without collision, you must call the function get_id() . If you want to check how near two processes are so that their graphics do not collide, then you must use the get_dist() function. Example program: PROGRAM example_collision; PRIVATE id2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; mobile_process(80, 50, 101); LOOP delete_text(all_text); write(0, 160, 0, 1, \"Use the cursors to move the triangle\"); id2 = collision(TYPE mobile_process); // Collision detected IF (id2<>0) write(0, 160, 200, 7, \"\u00a1 COLLISION DETECTED!\"); END FRAME; END END PROCESS mobile_process(x, y, graph); BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example you can see a ball in the centre of the screen as the graphic of the main program. After that a process named mobile_process is created with the picture of a controllable triangle with the cursor keys. The main program will call the function collision() to check if its graphic (the circle) collides with the graphic of the mobile_process type (the triangle). The result of the function is saved in the private variable id2 of the main program. This value will be 0 until a collision is detected, and will return the identifier code of mobile_process when it does. The identifier codes of the processes are always odd numbers, which in the DIV language are true conditions (the even numbers are associated with the false conditions), thus, in the example program we could have changed the statement to: IF (id2<>0) ... END For the next one: IF (id2) ... END For further information about this, see: Definition of a condition. When you can see the mouse pointer in a DIV program (by assigning the code of the corresponding graphic in the mouse structure ), it is possible to see if it has collided with the current process using this function in the following way: IF (collision(TYPE mouse)) // The process collides with the mouse pointer END When a collision with the mouse pointer is detected, it won't be done with the entire graphic used as a pointer like a normal graph, but only with the main checkpoint (the number 0) of the same item, known commonly as the \"hotspot\" ( hotspot ) of the mouse. This function is used to detect collisions between graphics on the screen or in a window with a scrollbar. It's not possible to use this function to detect collisions with processes that don't have a graphic (a valid code allocated to its variable graph ) or between graphics of a window of mode 7 or mode 8 (with its variable ctype allocated to the value c_m7 o c_m8 ). It is essential that the particular item of the current process that is the specified graphic has a defined graphic associated with it. To detect collisions between graphics of a window of mode 7 or mode 8 you must use the get_dist() function to detect when the distance between the two processes is smaller than the distance stipulated as a collision distance . ---See: get_id() - get_dist() - Types of processes - {#1038,Ways to obtain the identifier code}","title":"collision()"},{"location":"help/#convert_palette","text":"convert_palette( , , ) Description: Manipulates a map of colour to that of the indicated . The < offset new_palette> is the path/address inside the memory of the computer of a 256-colour table where the new order of colours are located. Note: The table must be (of the INT type, signed 32bit). If the table is like this: new_palette[255]=0, 1, 2, 3, 4, ... , 254, 255; The graphic will not be changed. However, if in the 3rd position of the previous table (new_palette[3]) there is a 16 (not a 3), when the function is called with the offset of the table, the colour 3 will be changed for the colour 16 in the graphic. The graphics loaded with the functions load_map() or load_pcx() (or made with new_map() ) will be used as if they refer to the first file (the file with the code 0). If a process wants to change the colours of its graphic, it must build a palette with the new order of colours and, after that, call the function with the parameters: convert_palette(file, graph, ) Here is a program that changes the colours of its graphic in this way using the predefined local variables file and graph . Example program: PROGRAM example_convert_palette; PRIVATE new_palette[255]; counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); FROM counter=1 TO 255; new_palette[counter]=(counter+16) MOD 256; END graph=100; x=160; y=100; write (0, 160, 0, 1, \"Press [SPACE] to change the colours of the ball\"); LOOP IF (scan_code==_space) // We convert the palette of the graphic number 100 (ball) convert_palette(file, graph, offset new_palette); END FRAME; END END - First, a table is created with the new order of the palette. The colour number 0 (transparent) never changes (new_palette[0] will always be 0) and the rest of the colours (from 1 to 255) will be changed for the colour that is 16 positions further along in the palette (the 1 for 17, the 2 for 18, etc.). The last 16 colours will be changed for the first 16 (when the operation MOD 256 is done the values are truncated, 256 will be 0, 257 will be 1, etc.). After that, inside the main loop of the program the function will run convert_palette() and it will change the colours of the ball each time that the space bar is pressed. ---See: load_pal() - roll_palette()","title":"convert_palette()"},{"location":"help/#define_region","text":"define_region( , , , , ) Description: Defines a new region within the screen (like a borderless window). Regions are rectangular areas inside the screen, in which you will see some kind of process, scroll windows or mode 7 windows. The region number must be between 1 and 31. Up to 31 different regions in the screen can be defined that are assignable, after that, to different processes (fixing its local variable region to the new number) as its view window or use it like a border for a scroll window or a mode 7 window, indicating it in the parameter of the functions start_scroll() or start_mode7() . The region number 0 can't be redefined, because it will be always be the entire screen, a window at the coordinates (0, 0) and as wide and as high as the screen. This is the region in which every process will be displayed, because its local variable region always has a value 0. Example program: PROGRAM example_define_region; PRIVATE counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); define_region(1, 0, 0, 160, 200); // We define the region 1 define_region(2, 160, 0, 160, 200); // We define the region 2 write(0, 0, 0, 0, \"Region 1\"); write(0, 320, 0, 2, \"Region 2\"); FROM counter=1 TO 20; mobile_process(rand(0, 319), rand(0, 159), rand(-8, 8), rand(-8, 8), rand(1, 2)); END END PROCESS mobile_process(x, y, increment_x, increment_y, region); BEGIN graph=100; LOOP IF (x<0 OR x>320) increment_x=-increment_x; END IF (y<0 OR y>200) increment_y=-increment_y; END x+=increment_x; y+=increment_y; FRAME; END END - First you define two regions as lateral divisions of the screen. After that, 20 processes of the type mobile_process are created using a loop at random coordinates and movement, in one of the two regions. You can see in the execution how each process can be seen in only one of the two halves of the screen (just in its region). ---See: out_region() - start_scroll() - start_mode7() - Variable region","title":"define_region()"},{"location":"help/#delete_text","text":"delete_text( ) Description: Delete text on the screen that is specified with the text identifier parameter, which is a numeric code returned by the functions write() and write_int() . If all_text is specified as the text identifier parameter, then all text on screen will be deleted. Example program: PROGRAM example_delete_text; PRIVATE text_id; BEGIN write(0, 160, 10, 1, \"Press [ENTER] to make the above text reappear.\"); LOOP text_id=write(0, 160, 0, 1, \"Press [SPACE] to delete this text.\"); WHILE (NOT key(_space)) FRAME; END delete_text(text_id); // Delete the text WHILE (NOT key(_enter)) FRAME; END END END - In this example, two texts appear on screen. When you press the space bar, one of these texts will be deleted using the delete_text() function, and when you press the Enter key, the text appears again using the write() function - which returns the new text identifier text_id . ---See: write() - write_int() - move_text()","title":"delete_text()"},{"location":"help/#end_fli","text":"end_fli() Description: Finishes an animation FLI/FLC shown on screen and frees the memory that was being used. The animations FLI/FLC are initiated with the start_fli() function. Only one animation can be loaded at a time. Example program: PROGRAM example_end_fli; BEGIN LOOP start_fli(\"help/help.fli\", 0, 0); // load and play the animation WHILE (frame_fli()<>0) FRAME; END end_fli(); // Unload the animation END END - In this example, the animation is loaded with the start_fli() function and then is displayed via frame_fli() until it finishes (when frame_fli() returns 0). At that moment it is unloaded from memory using end_fli() . The program does this sequence of commands (load, play, update and unload) of the animation FLI/FLC ) indefinitely. It is not necessary for the animation to have finished before it is unloaded from the memory. ---See: start_fli() - frame_fli() - reset_fli()","title":"end_fli()"},{"location":"help/#exit","text":"exit( , ) Description: Ends the game, killing all processes and returning to the operating system (or to the DIV IDE) with a message and a numeric code . The message is text message displayed between quotation marks which will be shown when the game finishes as an indication to the user that they have left DIV2. The return code is valid for the use of external programs to DIV Games Studio (like *.BAT files ), to determine the action that must be done after finishing the game. When the function exit() is used, you do not need to close any resources as this will be done for you (such as maps, fli, sounds and songs) as the system frees all resources automatically . Example program: PROGRAM example_exit; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to finish the program.\"); LOOP IF (key (_space)) fade_off(); exit(\"Thanks for using me!\", 0); // We exit the program END FRAME; END END - In the example you can see a message whilst the program waits for the space bar to be pressed, then exits with the exit() function. Every DIV program will finish its execution at any moment if the key combination [ALT]+[X] is pressed. This is similar to calling the exit() function, but without any messages and with the return code 0. ---See: let_me_alone() - fade_off()","title":"exit()"},{"location":"help/#fade","text":"fade( <% red> , <% green> , <% blue> , ) Description: Fades the palette until the percentages of colour is reached - (from 0% to 200% of the red (red), green (green) and blue (blue) components, specified as parameters). The last parameter indicates the speed at which the fading will occur, normally defined as a number from 1 (very slowly) to 10 (Very fast). If the speed indicates a number bigger or equal to 64, the fade will be done instantaneously. The fade will be done gradually in the successive frames of the game. If all three colour components are 0 you will see a fade to black, if the three components are set to 200, the fade will be to white, if the components are 100 you will retrieve the original colours of the game palette. A value less than 100 in a component will tone down its colour, meanwhile that a value greater than 100, will saturate the colour. Remember that the fade doesn't happen when the function fade() is called, but over the next FRAME statements . Whilst the program is executing a fade command, the predefined global variable fading will have a value of true (1) and when the fade is finished (the required values have been reached), this variable will be set to false (0). Example program: PROGRAM example_fade; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to see the fade() effects.\"); LOOP IF (NOT fading AND key(_space)) fade(rand(0, 200), rand(0, 200), rand(0, 200), 5); END FRAME; END END - In the example a screen is loaded and a message appears. Each time that the space bar is pressed and a fade is not already in progress ( IF (NOT fading ...) ), a new fade will start with the three random values chosen between 0% and 200% (with the rand() function) at a speed value of 5. ---See: fading - fade_off() - fade_on() - load_pal()","title":"fade()"},{"location":"help/#fade_off","text":"fade_off() Description: Creates a fade to black from the colours on screen. The game stays as it is until the screen is completely black. To turn on the screen again (undo the fade to black), use the fade_on() function. Example program: PROGRAM example_fade_off; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to fade off and fade on the screen.\"); LOOP WHILE (NOT key(_space)) FRAME; END fade_off(); // We turn off the screen fade_on(); END END - In this example, a screen appears, and after that, the program waits for the space bar to be pressed to turn off and turn on the screen. The fade() function can do this without stopping the program or at different speeds, as well as creating more advanced palette effects. ---See: fade() - fade_on()","title":"fade_off()"},{"location":"help/#fade_on","text":"fade_on() Description: Creates a fade up of the colours on the screen to their natural saturation (100%). In the successive FRAME statements of the game, the colours will recover their visibility until they can be seen perfectly. To turn off the screen (to do a fade to black) use the fade_off() function. Example program: PROGRAM example_fade_off; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write (0, 0, 0, 0, \"Press [SPACE] to fade off and fade on the screen.\"); LOOP WHILE (NOT key(_space)) FRAME; END fade_off(); fade_on(); // The screen is faded on END END - In this example, a screen appears, and after that, the program waits for the space bar to be pressed to turn off and turn on the screen. The fade() function can do this without stopping the program or at different speeds, as well as creating more advanced palette effects. Every game automatically executes a fade_on() at the beginning of execution. ---See: fade() - fade_off()","title":"fade_on()"},{"location":"help/#fget_angle","text":"fget_angle( , , , ) Returns: The angle between two points. Description: Returns the angle from the point 0 (x0, y0) to the point 1 (x1, y1). Remember that the angle is specified in thousandths of a degree. The function always returns a value between ** -180000 and 180000** (an angle between -180 and 180 degrees). Coordinates of both points (x0, y0, x1, y1) can be any valid numeric expression. Example program: PROGRAM example_fget_angle; PRIVATE coord_x0, coord_y0; coord_x1, coord_y1; result; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); write(0, 0, 0, 0, \"Coordinates point 1\"); write(0, 0, 10, 0, \"X:\"); write_int(0, 20, 10, 0, offset coord_x0); write(0, 0, 20, 0, \"Y:\"); write_int(0, 20, 20, 0, offset coord_y0); write(0, 0, 40, 0, \"Coordinates point 2\"); write(0, 0, 50, 0, \"X:\"); write_int(0, 20, 50, 0, offset coord_x1); write(0, 0, 60, 0, \"Y:\"); write_int(0, 20, 60, 0, offset coord_y1); write(0, 0, 80, 0, \"Angle from point 1 to point 2:\"); write_int(0, 0, 90, 0, offset result); write(0, 0, 200, 6, \"Press [SPACE] to get another two points.\"); LOOP clear_screen(); coord_x0=rand(0, 319); coord_y0=rand(0, 199); coord_x1=rand(0, 319); coord_y1=rand(0, 199); put(file1,200,coord_x0, coord_y0); put(file1,200,coord_x1, coord_y1); //We find the angle between two points result = fget_angle(coord_x0, coord_y0, coord_x1, coord_y1); scan_code=0; WHILE (scan_code<>_space) FRAME; END END END - In this example, some text messages are printed on the screen, along with some coordinates x and y of two points set from random values. The angle between the points is then calculated with the fget_angle() function. Each time that the space bar is pressed the process will repeat. The get_angle() function is used to obtain the angle between two processes , instead of between two points. The fget_dist() function is used to obtain the {distance between two points}, instead of the angle. ---See: Use of angles in the language - get_angle() - fget_dist()","title":"fget_angle()"},{"location":"help/#fget_dist","text":"fget_dist( , , , ) Returns: The distance between two points. Description: Returns the distance between point 0 (x0, y0) and point 1 (x1, y1). Coordinates of both points (x0, y0, x1, y1) can be specified by any valid numeric expression. Example program: PROGRAM example_fget_dist; PRIVATE coord_x0, coord_y0; coord_x1, coord_y1; result; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); write(0, 0, 0, 0, \"Point 1 Co-ordinates\"); write(0, 0, 10, 0, \"X:\"); write_int(0, 20, 10, 0, offset coord_x0); write(0, 0, 20, 0, \"Y:\"); write_int(0, 20, 20, 0, offset coord_y0); write(0, 0, 40, 0, \"Point 2 Co-ordinates\"); write(0, 0, 50, 0, \"X:\"); write_int(0, 20, 50, 0, offset coord_x1); write(0, 0, 60, 0, \"Y:\"); write_int(0, 20, 60, 0, offset coord_y1); write(0, 0, 80, 0, \"Distance between point 1 and point 2\"); write_int(0, 0, 90, 0, offset result); write(0, 0, 200, 6, \"Press [SPACE] to find another distance.\"); LOOP clear_screen(); coord_x0=rand(0, 319); coord_y0=rand(0, 199); coord_x1=rand(0, 319); coord_y1=rand(0, 199); put(file1,200,coord_x0, coord_y0); put(file1,200,coord_x1, coord_y1); //Find the distance between the two points result = fget_dist(coord_x0, coord_y0, coord_x1, coord_y1); scan_code=0; WHILE (scan_code<>_space) FRAME; END END END - In this example, the program sets the 2 sets of co-ordinates to random values, and then obtains the distance between them with the fget_dist() function. Each time that the space bar is pressed, the process is repeated. The get_dist() function is used to obtain the {distance from one process to another}, instead of from one point to another. The fget_angle() function is used to obtain the {angle between two points}, instead of the distance. This function could be used to detect collisions between processes, but of course, you would normally use the collision() function which detects when two processes have their graphics overlapping. An example of this is when a process exists within a Mode 7 window (See start_mode7() ) the collision() function can't be used, so the distance between the processes must be obtained (normally with get_dist() ) to check if they collide (if their distance is smaller than a specified one). ---See: get_dist - fget_angle - collision()","title":"fget_dist()"},{"location":"help/#frame_fli","text":"frame_fli() Returns: True if the animation continues and false if it has finished. Description: Shows the next image of an animation FLI/FLC that was started with the start_fli() function. This function returns 0 (false) if the animation has finished. It is only possible to run one FLI/FLC animation at a time. It is not possible to have two animations playing at the same time. The next frame of animation will be seen in the next FRAME of the game, but if a loop is created without a FRAME statement, the animation will not be seen. Example program: PROGRAM example_frame_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); LOOP frame_fli(); // Show the next frame of animation FRAME; END END - In the example, the animation FLI/FLC is loaded and then played repeatedly with the frame_fli() function. ---See: start_fli() - reset_fli() - end_fli()","title":"frame_fli()"},{"location":"help/#get_angle","text":"get_angle( ) Returns: The angle to other process Description: Returns the angle from the current process (the one which called this function) to the process which has the identifier code . See Ways to obtain the identifier code , for further information. Remember that angle is specified in thousandths of a degree. The function will always return a value between -180000 and 180000 (an angle between -180 and 180 degrees). Example program: PROGRAM example_get_angle; PRIVATE resulting_angle; process_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; process_id = mobile_object(80, 50, 101); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Angle from the ball to the triangle:\"); write_int(0, 0, 10, 0, offset resulting_angle); LOOP // We find the angle between the two processes resulting_angle = get_angle(process_id); FRAME; END END PROCESS mobile_object(x, y, graph); BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example, a ball is displayed in the centre of the screen. A mobile_object process is created, and its identifier code is stored in the process_id variable. This process can be controlled with the cursor keys. In the main loop of the program, the angle between the two processes is calculated and shown on screen continuously. The fget_angle() function is used to obtain the {angle between two points}, instead of between two processes. For Example, if the identifier code of the process refers to a variable id2 , then a function call of: get_angle(id2) Would be equivalent to: fget_angle(x, y, id2.x, id2.y) The get_dist() function is used to obtain the distance to the other process instead of the angle. ---See: Use of angles in the language - fget_angle() - get_dist()","title":"get_angle()"},{"location":"help/#get_dist","text":"get_dist( ) Returns: The distance to the other process. Description: Returns the distance from the current process (the one which called this function) to the process which has the identifier code . See ways to obtain the identifier code , for further information. If the process has defined its local variable resolution then it is important that the process for which the distance we wish to obtain has the resolution local variable set to the same value. If both processes have the coordinates in hundredths instead of whole amounts (with resolution =100), then the distance between both will be given in hundredths too, but if the value of this variable is different between processes, then the result of the get_dist() function will not make sense. Example program: PROGRAM example_get_dist; PRIVATE resulting_distance; process_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; x=160; y=100; process_id = mobile_object(80, 50, 101); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Distance from the ball to the triangle:\"); write_int(0, 0, 10, 0, offset resulting_distance); LOOP // We find the distance between the two processes resulting_distance = get_dist(process_id); FRAME; END END PROCESS mobile_object(x, y, graph) BEGIN LOOP IF (key(_right)) angle-=10000; END IF (key(_left)) angle+=10000; END IF (key(_up)) advance(4); END FRAME; END END - In this example, a ball is displayed in the centre of the screen. A mobile_object process is created, and its identifier code is stored in the process_id variable. This process can be controlled with the cursor keys. In the main loop of the program, the distance between the two processes is calculated and updated on screen continuously. The function fget_dist() is used to obtain the {distance between two points}, instead of between two processes. If the identifier code of the process is contained, for example, in a variable denominated id2 , then the call to the function: get_dist(id2) Will be equivalent to: fget_dist(x, y, id2.x, id2.y) To obtain the distance from the coordinates (x, y) of the current process up to the coordinates (x, y) of the process for which its identifier code is id2 . The function get_angle() is used to obtain the angle to the process instead of the distance. This function can be used to detect collisions between processes, though of course, the collision() function is normally used which detects when two processes graphics overlap. An example of this is when a process exists within a Mode 7 window (See start_mode7() ) the collision() function can't be used, so the distance between the processes must be obtained (normally with get_dist() ) to check if they collide (if their distance is smaller than a specified one). ---See: fget_dist() - get_angle() - get_distx() - get_disty()","title":"get_dist()"},{"location":"help/#get_distx","text":"get_distx( , ) Returns: The horizontal distance towards the vector (angle, distance). Description: Returns the horizontal distance (in the x axis) from the angle and distance (over this angle) passed as parameters. It returns the distance that the vector moves horizontally (along the x-axis), made by the angle and length (distance or module of the vector) indicated. Keep in mind that the angle is specified in thousandths of a degree and distance can be specified by any valid numeric expression. The function used to calculate the vertical distance, instead of the horizontal one is get_disty() . Example program: PROGRAM example_get_distx; GLOBAL distance; horizontal_distance; vertical_distance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 3); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Horizontal distance:\"); write_int(0, 0, 10, 0, offset horizontal_distance); graph=101; LOOP IF (key(_up)) distance+=2; END IF (key(_down)) distance-=2; END IF (key(_right)) angle-=2000; END IF (key(_left)) angle+=2000; END // We calculate the horizontal distance horizontal_distance= get_distx(angle, distance); vertical_distance = get_disty(angle, distance); x=160+horizontal_distance; y=100+vertical_distance; FRAME; END END - In the example, a circular graphic is placed on screen, then a triangle process is shown, whose angle and distance can be controlled using the cursor keys. The program calculates the horizontal and vertical distances to the triangle from the coordinates of the centre of the screen (160, 100), showing the horizontal distance in the upper left corner all the times. If the aim is to advance the coordinates of the process a distance in a specific angle, the following statements may be used: x+=get_distx( , ); y+=get_disty( , ); This would be equivalent to (using the xadvance() function). xadvance( , ); If the angle that you wish to move the process is the one declared in the local variable angle , then you would use the advance() function like this: advance( ); The get_distx() function is the same as calculating the cosine of the angle and multiplying it by the distance . ---See: Use of angles in the language - get_disty() - xadvance() - advance()","title":"get_distx()"},{"location":"help/#get_disty","text":"get_disty( , ) Returns: The vertical distance towards the vector (angle, distance). Description: Returns the vertical distance (in the x axis) from the angle and distance (over this angle) passed as parameters. It returns the distance that the vector moves vertically (along the y-axis), made by the angle and length (distance or module of the vector) indicated. Keep in mind that the angle is specified in thousandths of a degree and distance can be specified by any valid numeric expression. The function used to calculate the horizontal distance, instead of the vertical one is get_distx() . Example program: PROGRAM example_get_disty; GLOBAL distance; horizontal_distance; vertical_distance; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 3); write(0, 160, 200, 7, \"Use the cursors to move the triangle.\"); write(0, 0, 0, 0, \"Vertical distance:\"); write_int(0, 0, 10, 0, offset vertical_distance); graph=101; LOOP IF (key(_up)) distance+=2; END IF (key(_down)) distance-=2; END IF (key(_right)) angle-=2000; END IF (key(_left)) angle+=2000; END // We calculate the horizontal distance horizontal_distance= get_disty(angle, distance); vertical_distance = get_disty(angle, distance); x=160+horizontal_distance; y=100+vertical_distance; FRAME; END END - In the example, a circular graphic is placed on screen, then a triangle process is shown, whose angle and distance can be controlled using the cursor keys. The program calculates the horizontal and vertical distances to the triangle from the coordinates of the centre of the screen (160, 100), showing the vertical distance in the upper left corner all the times. If the aim is to advance the coordinates of the process a distance in a specific angle, the following statements may be used: x+=get_disty( , ); y+=get_disty( , ); This would be equivalent to (using the xadvance() function). xadvance( , ); If the angle that you wish to move the process is the one declared in the local variable angle , then you would use the advance() function like this: advance( ); The get_disty() function is the same as calculating the sine of the angle and multiplying it by the distance . ---See: Use of angles in the language - get_distx() - xadvance() - advance()","title":"get_disty()"},{"location":"help/#get_id","text":"get_id( ) Returns: The identifier code of a process or 0 . Description: This function checks to see if there are any processes of the specified type. If any are found, then the function will return the identifier code of the first occurrence, and if none are found will return a 0. If there are more processes of the specified type, the function get_id() will return the next identifier code for each successive call. Once every identifier code has been returned, the function will return 0, until the next FRAME statement is executed, at which point the function will be reset, and once again will begin to return every identifier code of the specified type of process. If you wish to get all of the identifier codes of the processes of that type, you should not use the FRAME statement between two successive calls to get_id() . If you execute a FRAME statement between calls to get_id() then the function will again reset and start returning values from the first occurrence of that type of process. A similar thing happens if you call get_id() with a different process type. Each time a new process type is called, the identifiers reset and start with the first process of that type. Example program: PROGRAM example_get_id; PRIVATE process_id; counter; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); FROM counter=1 TO 20; my_process(rand(0, 319), rand(0, 199), 101); END LOOP FROM counter=1 TO 20; // Get the Processes ID process_id = get_id(TYPE my_process); // Change the processes LOCAL angle variable using the ID process_id.angle+=rand(-5000, 5000); END FRAME; END END PROCESS my_process(x, y, graph); BEGIN LOOP FRAME; END END - In the example, after having loaded the file with graphics and set the background screen, 20 movable_process type processes are created with their positions randomly chosen and with a triangle-shaped graphic. These processes will only execute FRAME statements inside a loop, in order to be displayed. From the main program, the identifiers of the movable_process type processes are taken with the get_id() function (storing them in the process_identifier variable) and using them to modify their angle (their angle local variable). On having the identifying code of a process, it is possible to consult or modify its local variables (like angle in this example) or else, to send signals to the process with the signal() function. The collision() function is used to obtain the identifier codes of processes of a determined type that collide with the current process. ---See: Ways to obtain the identifier code - Types of processes - Identifier codes","title":"get_id()"},{"location":"help/#get_joy_button","text":"get_joy_button( [button number] ) Returns: True (1) if the button is pressed or False (0) if it isn't Description: This function requires the joystick number button (from 0 to 3) as a parameter, and returns true (an odd numerical value) if it is pressed at that moment. If the button is not pressed, the function returns false (an even numeric value). Some joysticks only have two buttons, and this case they will be mapped to button numbers 0 and 1. On computers that have two joysticks connected, the second joystick will have the buttons numbered 2 and 3. Example program: PROGRAM example_get_joy_button; PRIVATE counter; buttons[3]; BEGIN write(0, 160, 200, 7,\" Press the buttons of the joystick.\"); write(0, 0, 0, 0, \"Buttons (0..3):\"); write_int(0, 100, 0, 0, offset buttons[0]); write_int(0, 120, 0, 0, offset buttons[1]); write_int(0, 140, 0, 0, offset buttons[2]); write_int(0, 160, 0, 0, offset buttons[3]); LOOP FROM counter=0 TO 3; // We take the value of the joystick button buttons[counter] = get_joy_button(counter); END FRAME; END END - An explanatory message is displayed in the lower part of the screen and the condition of the four possible buttons is displayed in the upper part of the screen; after that, the program stays inside of a loop updating the state of the four buttons continuously using the get_joy_button() function. There are other ways to read the joystick. The easiest is to use the joy structure, because in there are four variables that are continuously updated with the status of the joystick buttons. ---See: get_joy_position() - Joy Structure","title":"get_joy_button()"},{"location":"help/#get_joy_position","text":"get_joy_position( ) Returns: The position of the joystick axis Description: This function returns the coordinate in which is found the indicated axis (with a number from 0 to 3 ) of the analogic joystick. Axis 0 - Axis X main. Axis 1 - Axis Y main. Axis 2 - Axis X secondary. Axis 3 - Axis Y secondary. The coordinate of the joystick can change due to the type of joystick and computer in which it is played, in all cases it is a number which changes between 4 and 200 , more or less. The axes main and secondary can be integrated in just one joystick in some cases (flight joysticks with a hat , pedals , etc.). In computers with two joysticks connected, the main axis will be the joystick 1 and the secondary axis will be the joystick 2. Example program: PROGRAM example_get_joy_position; PRIVATE joystick_axis[3]; counter; BEGIN write (0, 160, 200, 7, \"Move the joystick\"); write (0, 0, 0, 0, \"Coordinate X main.\"); write_int(0, 0, 10, 0, offset joystick_axis[0]); write (0, 0, 40, 0, \"Coordinate & main.\"); write_int(0, 0, 50, 0, offset joystick_axis[1]); write (0, 0, 80, 0, \"Coordinate X secondary.\"); write_int(0, 0, 90, 0, offset joystick_axis[2]); write (0, 0, 120, 0, \"Coordinate & secondary.\"); write_int(0, 0, 130, 0, offset joystick_axis[3]); LOOP FROM counter=0 TO 3; // We take the value of the joystick axis joystick_axis[counter] = get_joy_position(counter); END FRAME; END END - Information is printed on the screen, then the program is put into a continuous loop. The screen updates with the state of each joystick position, stored in the joystick_axis[] array, and updated using the get_joy_position() function. There are other ways to read the joystick. The easiest is to use the joy structure when analogue reading of the joystick (its coordinates) is not required. This tells you the simple directions of the joystick, like the centre, to the right, down, etc. ---See: get_joy_button() - joy structure","title":"get_joy_position()"},{"location":"help/#get_pixel","text":"get_pixel( , ) Returns: The colour value of the pixel (0..255). Description: Returns the colour of the background at the screen coordinates that are specified in the parameters. The number returned is a palette index from the active palette between 0 and 255, because the palettes have 256 colours. The point refers to only the background from the picture, without taking notice of the graphics of the processes, texts, scroll regions, etc. Only the images placed on screen by the functions put() , xput() , put_pixel() & put_screen() will be read. Example program: PROGRAM example_get_pixel; PRIVATE pixel_colour; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); mouse.graph=200; write (0, 0, 190, 0, \"Colour of the background pixel:\"); write_int(0, 256, 190, 0, offset pixel_colour); LOOP // We take the colour of the point of the background pixel_colour = get_pixel(mouse.x, mouse.y); FRAME; END END - In this example, the put_screen function is used to display an image on screen, representing a group of squares in different colours, and a mouse pointer displayed as a cross. In the lower part of the screen a message is displayed, along with a variable that is updated from the get_pixel() command. By using the mouse, you can obtain the colour of any pixel on the screen. ---See: put_pixel() - map_get_pixel() - map_put_pixel() - get_point()","title":"get_pixel()"},{"location":"help/#get_point","text":"get_point( , , , , ) Returns: The position of the checkpoint (placed into the variables which offset is declared in the last two parameters). Description: This function will place the coordinate values of a map point into the variable you specify from an indicated graphic. A checkpoint is a point that can be defined in the graphic editor (draw tool), in the checkpoints function. The function needs the address (which is obtained with the offset operator) in memory of two variables in which the x and y values of the checkpoint will be stored. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be used as if they were from the first file (the one with the code 0). Example Program: PROGRAM example_get_point; GLOBAL file1; point=1; x_point; y_point; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(0, 4); graph=101; LOOP IF (fget_dist(x, y, x_point, y_point)<6) IF (point++==50) point=1; END END // Store the checkpoint coordinate values in x_point and y_point get_point(file1, 4,point, offset x_point, offset y_point); angle=fget_angle(x, y, x_point, y_point); advance(6); FRAME; END END - In this example, an image of a circuit is displayed on the screen. On this map there are 50 checkpoints defined {from 1 to 50) in the circuit. The main process appears as a triangle that travels throughout the circuit. The number of the checkpoint is stored in the local variable point which at the beginning is set to 1. The coordinates of each checkpoint, obtained with the get_point() function, are saved in the x_point and y_point variables and are used to make the process move to that position with the fget_angle() functions (to obtain the local angle variable) and advance() (to advance 6 points in that direction). The distance to the next checkpoint is checked using the fget_dist() function, if that point number is detected as being less than 6 pixels away, then the triangle is directed onto the next point. When point number 50 is reached it will reset back to point 1. This function returns the exact coordinates that the checkpoints were placed inside the graphic, without regard to how the graphic is displayed (zoomed,rotated,etc). To obtain the position of a checkpoint in an graphic that is zoomed or rotated, and relative to the coordinates of screen (and not of the original graphic) you must use the get_real_point() function. ---See: Checkpoints - get_real_point() - get_pixel()","title":"get_point()"},{"location":"help/#get_real_point","text":"get_real_point( , , ) Returns: Sets the coordinates of the checkpoint to the variables which offset indicated as the two last parameters. Description: This function returns where a checkpoint of the main processes graphic is at a particular moment in the coordinates system used by the process (See local variable ctype ), evaluating the original location of the point, the current coordinates of the process, its size, angle, etc. A checkpoint is a point that can be defined in the graphics editor (drawing tool), in the options given to the function. The function needs the address (which is obtained with the offset operator) in memory of two variables in which the x and y values of the checkpoint will be stored. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be used as if they were from the first file (the one with the code 0). Example program: PROGRAM example_get_real_point; PRIVATE point; x_point; y_point; BEGIN load_fpg(\"help/help.fpg\"); graph=4; x=160; y=100; LOOP FROM point=1 TO 50; // We take the coordinates where there at this moment the checkpoint is get_real_point(point, offset x_point, offset y_point); cross(x_point, y_point, 200); END angle+=1000; FRAME; END END PROCESS cross(x, y, graph); BEGIN FRAME; END - In the example a circuit that rotates on the screen is defined as the graphic of the main process . This graphic has 50 defined checkpoints numbered from 1 to 50. The program stays inside of a loop, rotates this graphic with the angle command,and creating 50 processes of a cross type, one for each of the 50 checkpoints of the graphic. You can check how the relative position of two points doesn't change though the graphic of the circuit rotates. This function is usually used to locate some important key points of a graphic. For example, in a process in which the graphic is a man with a gun that can be escalated, rotated or that has some animations, a checkpoint could be defined in the cannon of the gun to know at each moment where the bullets must go the case of gun being fired. If the original graphic was inside of a scroll region (See start_scroll() ) the given coordinates will be relative to to the scroll region. The get_point() function returns the position where a checkpoint of the graphic was placed initially, instead of its current position like get_real_point() . ---See: Checkpoints - get_point() - get_pixel()","title":"get_real_point()"},{"location":"help/#graphic_info","text":"graphic_info( , , ) Returns: The information that was requested about the graphic. Description: It returns the information of a graphic for in a file that was requested. Information: The returned value will depend on the third parameter information that is passed to the function as follows: g_wide - The original width of the graphic g_height - The original height of the graphic. g_x_center - The (x coordinate} of the centre of the graphic. g_y_center - The y coordinate of the centre of the graphic. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() ) will be treated as if they were loaded from the first file (code 0). Example program: PROGRAM example_graphic_info; PRIVATE file1; myheight; mywidth; x_centre; y_centre; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); graph=100; x=160; y=100; // We take the information about the height of the graphic myheight = graphic_info(file1, 100, g_height); // We take the information about the width of the graphic mywidth = graphic_info(file1, 100, g_wide); // We take the information about the coordinate x of the centre of the graphic x_centre = graphic_info(file1, 100, g_x_center); // We take the information about the coordinate & of the centre of the graphic y_centre = graphic_info(file1, 100, g_y_center); write(0, 0, 0, 0, \"Height of the graphic:\"); write_int(0, 0, 10, 0, offset myheight); write(0, 0, 20, 0, \"Width of the graphic:\"); write_int(0, 0, 30, 0, offset mywidth); write(0, 0, 40, 0, \"Horizontal centre of the graphic:\"); write_int(0, 0, 50, 0, offset x_centre); write(0, 0, 60, 0, \"Vertical centre of the graphic:\"); write_int(0, 0, 70, 0, offset y_centre); LOOP FRAME; END END - In this example, the program fetches the information about graphic number 100 in the help.fpg file, which is a ball of 32 pixels square and has a centre of (16, 16). To obtain this information, it makes 4 calls to the graphic_info() function, each time passing a different ( ) argument (g_wide, g_height, etc) to get the required values. ---See: g_width - g_height - g_x_center - g_y_center","title":"graphic_info()"},{"location":"help/#is_playing_cd","text":"is_playing_cd() Returns: True (1) if the CD is playing, or false (0) if it isn't. Description: This function is used to determine if the CD is playing a track. Returns True (an odd number) if the CD is playing, or False (an even number) if no track is playing. Normally this is used to play a song in a continuous loop as shown in this example. Example program: PROGRAM example_is_playing_cd; BEGIN play_cd(1, 0); LOOP IF (NOT is_playing_cd) // Checks if the song has finished play_cd(1, 0); END FRAME; END END - In this example (which you need to have an audio Compact disk inserted in your CD-ROM drive), The play_cd() function is used to play the first song of the CD. In a loop, a check is made to see if the song has finished so it can restart it. The volume of the cd-audio can be controlled with the setup structure and the set_volume() function. ---See: play_cd() - stop_cd() - set_volume() - Setup structure","title":"is_playing_cd()"},{"location":"help/#key","text":"key( ) Returns: True (1) if the key is pressed and false (0) if it is not. Description: Returns true (an odd number) if the key (indicated as the parameter) is pressed, and returns false if not. The parameter is usually specified by the key name proceeded by the _ symbol. For example, to read the [ A ] key, the command used would be key(_a) . View the key codes to see the complete list of keytable codes that can be used as the parameter of the key() function. Example program: PROGRAM example_key; BEGIN LOOP delete_text(all_text); IF (key(_space)) // Check if the space bar is being pressed write(0, 0, 0, 0, \"You are pressing the [SPACE] key.\"); ELSE write(0, 0, 0, 0, \"You are not pressing the [SPACE] key.\"); END FRAME; END END - In this example, a message is displayed, dependant on whether the SPACE key is being pressed or not. There are three predefined global variables that can be used to control the keytable. These are: scan_code - Gets the Code of the last key that has been pressed. This is a numeric value that corresponds directly with the constants of key codes used as parameters of the key() function. ascii - the ASCII code of the last key pressed. shift_state - Variable that indicates a number in the function for the special keys (shift, alt, control, ...) which are pressed at that moment. ---See: key codes - scan_code - ascii - shift_state","title":"key()"},{"location":"help/#let_me_alone","text":"let_me_alone() Description: Sends a s_kill signal to every process (except the one that called this function) to stop processing. This function is normally called from the main process when a game has finished, to eliminate every process (shots,enemies, etc.) that still remain active and recover the control of the program. A call to let_me_alone() could always be swapped for a group of calls to the signal() function with the s_kill signal, but to do this you need to know the types of the processes that you wish to eliminate or their identifier codes . Example program: PROGRAM example_let_me_alone; BEGIN load_fpg(\"help/help.fpg\"); ball (160, 100, 100); write (0, 160, 0, 1, \"Press [SPACE] to eliminate the process\"); WHILE (NOT key (_space)) FRAME; END let_me_alone(); // The other processes are eliminated LOOP FRAME; END END PROCESS ball(x, y, graph) BEGIN LOOP FRAME; END END - In this example a ball process is created, and the program waits for the space bar to be pressed. At this point, the let_me_alone() function is called, which eliminates every process except the main one, which kills the ball process. If you wish to check the processes that are active in a program at any given moment, the debugger may be accessed by pressing the [ F12 ] key. The exit() function is used to finish a program instantly, returning to the operating system. ---See: exit() - signal()","title":"let_me_alone()"},{"location":"help/#load","text":"load( , ) Description: Loads the raw data from a file into the computer memory. To do this, the function requires the name of the file and the address of the data within the program, this can be a variable, array or structure and can be obtained by using the OFFSET ) operator. The address of the data must be the same as was used to save the data using the save() function. The name of the file can be any legal MS-DOS 8:3 filename (the same limitations as fpg and PRG filenames). It is important that the file you wish to read data from exists, as an error will occur if you try to load a nonexistent file (even if this can be ignored, continuing the program's execution). Example program: PROGRAM example_load; PRIVATE table[9]; counter; BEGIN write (0, 0, 0, 0, \"Press [ENTER] to delete the data from memory.\"); write (0, 0, 10, 0, \"Press [SPACE] to load the data from disk.\"); write (0, 0, 30, 0, \"Current values of the data:\"); FROM counter=0 TO 9; table[counter]=rand(0, 100); write_int(0, 0, 40+(counter*10), 0, offset table[counter]); END save(\"help.dat\", offset table, sizeof(table)); LOOP IF (key(_enter)) FROM counter=0 TO 9; table[counter]=0; END END IF (key(_space)) load(\"help.dat\", offset table); // The disk data are loaded END FRAME; END END - In this example, an array of 10 values are created, and filled with random values. This array is then saved to disk using the save() function. When the ENTER key is pressed, the values in the array are reset to 0. When the SPACE key is pressed, the values are recovered into the array using the load() function. ---See: save() - sizeof()","title":"load()"},{"location":"help/#load_fnt","text":"load_fnt( ) Returns: The code of the loaded font. Description: Loads a font file (*.FNT) from the disk. The function returns the font code that can be used by the write() and write_int() functions to write to the screen. The path can be specified with the font. However, it is not necessary to do so if the file resides in the same directory as the executable or the default font directory ( \\FNT ). The new font must have the same palette as the game is currently using for it to be displayed correctly. Otherwise, the colours may appear incorrectly. Example program: PROGRAM example_load_fnt; PRIVATE font1; BEGIN font1=load_fnt(\"help/help.fnt\"); // The font for the text is loaded write(0, 160, 0, 1, \"Text written with the system font.\"); write(font1, 160, 10, 1, \"FONT LOADED FROM DISK\"); LOOP FRAME; END END - In this example, a font is loaded with the load_fnt() function and then two messages are written with different fonts. The first one with the system font, and the second one loaded from the help.fnt file. To unload the font from memory (freeing up the space that the font occupies), the unload_fnt() function must be called, using the font code as the parameter. It is not necessary to unload the font unless you need the space to load other graphics or fonts, since the system will automatically free up the font when the program has terminated. ---See: unload_fnt() - write() - write_int() - load_pal()","title":"load_fnt()"},{"location":"help/#load_fpg","text":"load_fpg( ) Returns: The code of the fpg file that was loaded. Description: Loads an *.FPG file from disk. An FPG file may contain anywhere from 0 to 999 graphic images. Every image in in the file will have a numeric code, this is the graphic code (a number that ranges from 1 to 999 ) that is used to identify the graphic inside the file. It is possible to load as many graphics FPG files as necessary, as long as there is available memory (this function has to be called several times to load several files). The function returns the file code that can be used by many functions that require a graphic. For that, it is necessary to indicate the file code in which the graphic is and the graphics code inside the file. The path can be specified with the graphics file. However, it is not necessary to do so if the file resides in the same directory as the executable or the default FPG directory ( \\FPG ). When different files have been loaded, take into account that if they have different palettes, every palette has to be activated previously with the load_pal() function, indicating the (FPG) file name as a parameter before using its graphics. Example program: PROGRAM example_load_fpg; PRIVATE file1; BEGIN file1 = load_fpg(\"help/help.fpg\"); // The graphics' file is loaded put_screen(file1, 1); // We use graphic 1 of the file write(0, 160, 0, 1, \"Graphics' file successfully loaded\"); LOOP FRAME; END END - In this example, the FPG file that is going to be used in the program is loaded using the load_fpg() function. Then, graphic number 1 is put as a screen background (with the put_screen() function). To unload the graphics file ( FPG ) from memory (freeing up the space that the graphics file occupies), the unload_fpg() function must be called, using the file code as the parameter. It is not necessary to unload file unless you need the space to load other graphics or fonts, since the system will automatically unload the file when the program has terminated. ---See: unload_fpg() - load_map/pcx() - load_pal() - file","title":"load_fpg()"},{"location":"help/#load_pal","text":"load_pal( ) Description: Loads a colour palette from disk (from a PAL, FPG, MAP or FNT file) defining the 256 colours displayed on the screen. From that moment, the game will be seen with the colours set indicated by that palette. If when the palette was loaded, the program had already another one assigned, a fading of the screen colours to black will be carried out. Then, the new colour palette will gradually appear in the following frames of the game. The file path may be specified with the palette, although this is not necessary if the file is in the same directory as the executable, or in the default directory (depending on file type) ( \\PAL, \\FPG, \\MAP or \\FNT ). The program will automatically read the palette of the first of these types of files loaded in the program, even if the load_pal() function is not used. Then, this function will be used when the program uses several different palettes to change from one to another. Example program: PROGRAM example_load_pal; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 160, 0, 1, \"Press [SPACE] to load a different palette.\"); write(0, 160, 10, 1, \"Press [ENTER] to load the original palette.\"); LOOP IF (key(_space)) load_pal(\"help/help.pal\"); // The palette of a .pal file is loaded END IF (key(_enter)) load_pal(\"help/help.fpg\"); // The palette of a .fpg file is loaded END FRAME; END END - In this example, a graphics file is loaded ( FPG ) and an image is placed on the background, along with the necessary text messages. The main program is a small loop, testing for the space and enter keys. When a key is pressed, a palette is loaded. The help2.pal file is loaded when the spacebar is pressed, and the original palette is loaded (from the help.fpg file) when the ENTER key is pressed. A palette can not be unloaded from the computer's memory, since only one palette can be loaded at any time. ---See: load_map/pcx() - load_fpg() - load_fnt()","title":"load_pal()"},{"location":"help/#load_pcm-load_wav","text":"load_pcm( , ) load_wav( , ) Returns: The sound code loaded. Description: Loads a PCM or WAV sound effect from disk. The filename must be specified as the first parameter, and the second parameter replaced by either a 1 if the sound must indefinitely be repeated (looped), or 0 if it should played only once (this refers to the sound when played using the sound() function). The function returns the sound code that is required by the sound() function to play the sound through a channel. The path can be specified with the sound file. However, it is not necessary to do so if the file resides in the same directory as the executable or the default sounds directory ( \\PCM or \\WAV ). Example program: PROGRAM example_load_pcm; PRIVATE id_sound; BEGIN id_sound = load_pcm(\"help/help.pcm\", 0); // Loads a sound of the hard disk write(0, 160, 0, 1, \"Press [SPACE] to play the sound.\"); LOOP IF (scan_code==_space) sound(id_sound, 100, 256); END FRAME; END END - In this example, a sound is loaded with the load_pcm() function. Then, every time the spacebar is pressed, that sound is played using the sound() function. The unload_pcm() and unload_wav() functions allow us to free up the computer's memory occupied by the sound when it is not going to be used any longer. For that, you require the sound code in order to know which sound we want to unload from the memory. It is not necessary to unload the sound from memory before finishing the program, since the system will do it automatically. ---See: unload_pcm/wav() - sound() - change_sound() - Setup structure","title":"load_pcm() / load_wav()"},{"location":"help/#map_block_copy","text":"map_block_copy( , , , , , , , , ) Description: The map_block_copy() function allows us to transfer a rectangular block from a graphic to another one. The graphic from which the rectangular region is taken is called the and the graphic in which the block will be copied to is called the . The parameters are the following ones, in order: - Both graphics must come from the same graphics file FPG . The file code must be specified as first parameter (see load_fpg() ). The graphics loaded with the load_map() or load_pcx() functions (or created with new_map() function) will be used as if they were from the first file (file code 0). - graphic code in which the block is going to be put. , - x and y coordinates at which the copied block is to be placed inside the destination graphic. - graphic code from which the copied block is going to be taken. , - starting coordinates of the block inside the origin graphic. , - dimensions of the block that is going to be copied. This function will modify the indicated graphic, but only the copy that has been loaded into memory. The original graphic that is stored in the FPG , MAP or (PCX) files on disk will remain unchanged . If you wish to recover the original graphics, then you must unload the graphic (with unload_fpg() , unload_map() or unload_pcx() ) and then, load it in again to obtain the unchanged version. Example program: PROGRAM example_map_block_copy; PRIVATE x_destination, y_destination; x_origin, y_origin; map_width, map_height; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 320); y_destination=rand(0, 200); map_width=rand(1, 32); map_height=rand(1, 32); x_origin=rand(0, 32-map_width); y_origin=rand(0, 32-map_height); map_block_copy(file1, 1, x_destination, y_destination, 100, x_origin, y_origin, map_width, map_height); FRAME; angle+=1000; END END - In this example, an FPG graphics file is loaded, and a graph (graphic number 1) is placed in the centre of the screen and continuously rotated. Within the main loop, a ball graphic (graphic number 100) is copied inside the destination graphic (number 1) at some randomly chosen coordinates. When a graphic is put inside another one that is being used as a scroll region's background, it will not automatically appear on screen unless the refresh_scroll() function is used. ---See: map_xput() - map_put() - map_put_pixel()","title":"map_block_copy()"},{"location":"help/#map_get_pixel","text":"map_get_pixel( , , , ) Returns: The colour of the point (0..255). Description: This function allows us to obtain the colour of a graphic's specific pixel. For this, the in which the graphic is stored, the inside the file and the x and y coordinates of the graphic where you wish to obtain the colour are needed to be passed as parameters. Graphics loaded with the load_map() or load_pcx() functions (or created with new_map() function) are treated as if they were loaded from the first FPG file (code 0). Example program: PROGRAM example_map_get_pixel; PRIVATE file1; figure; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(0, 7); mouse.graph=200; write(0, 0, 0, 0, \"FIGURE:\"); write_int(0, 42, 0, 0, offset figure); LOOP // We take the colour of the bitmap's pixel figure = map_get_pixel(file1, 8, mouse.x, mouse.y); FRAME; END END - In this example, 6 different geometrical figures are drawn on the screen in the same colour. The mouse graphic is defined as a little cross. The image displayed on screen directly corresponds to another graphic (graphic number 8 in the FPG file), which has the same figures but every one is in a different colour (the first one of colour 1, the second one of colour 2, etc.). In the main loop, the map_get_pixel() function is used to get a colour from graph 8, at the mouse's x and y coordinates. This value will be shown in the upper left corner of the screen and when the mouse is over one of the shapes, will show a value from 1 to 6. This function is normally used to detect zones inside a graphic. This technique is called using hardness maps and allows us to use two different graphics, one with the picture and the second with the zones to detect, painted using colours. ---See: get_pixel() - map_put_pixel()","title":"map_get_pixel()"},{"location":"help/#map_put","text":"map_put( , , , , ) Description: Puts a graphic inside another one. The graphic that is going to be copied is called and the graphic in which the is to be copied is called the . The function allows us to copy a graphic (origin) inside another one (destination). Both graphics must be in the same FPG file. The parameters are as follows, in order: - The file code of the FPG file that contains both graphics. Graphics loaded with the load_map() or load_pcx() function (or created with new_map() function) will be used as if they were loaded from the first file (code 0). - code of the graphic inside which the other one is going to be copied. - code of the graphic that is going to be copied into the destination. , - coordinates inside the destination graphic where the origin graphic is going to be copied. The centre (or control point number 0) of the origin graphic will be located at these coordinates. This function will modify the , but only the copy of it in memory. The original graphic that is stored in the FPG or MAP files on the disk will remain unchanged . If you wish to recover the original unchanged graphic you should unload the file from memory (using unload_fpg() unload_map() or unload_pcx() functions) and then load it back again. Example program: PROGRAM example_map_put; PRIVATE x_destination; y_destination; file1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 320); y_destination=rand(0, 200); map_put(file1, 1, 100, x_destination, y_destination); angle+=1000; FRAME; END END - In the example, graphic number 1 is put at the centre of the screen. In every step of the main loop, this graphic rotates and a graphic number 100 (a ball) is put inside the graphic 1 (the central graphic) with the map_put() function. The map_xput() function is a version a little more complex than the map_put() function, but with much more utilities. Thus, the latter allows us, moreover, to put rotated, scaled, mirror and transparent graphics. The map_block_copy() function must be used to put a part of a graphic (instead of the full graphic) inside another one. Note: When the map_put() function (or any other similar) is used to modify a graphic that is being used as background of a scroll window, it is possible that the graphic you have put does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_xput() - map_put_pixel() - refresh_scroll() - map_block_copy()","title":"map_put()"},{"location":"help/#map_put_pixel","text":"map_put_pixel( , , , , ) Description: Allows us to modify the colour of a specific pixel of a graphic. For that, the where the graphic is stored, the inside the file and the ( x , y ) coordinates of the pixel whose is intended to set are required. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). This function will modify the indicated graphic, but only its copy that has been loaded in the computer's memory. The original graphic, that is stored in the FPG or MAP files of the disk, will remain unchangeable . For that, if at a specific moment of the game the aim is to recover the original state of the graphic, it will be necessary to unload it from the memory (with unload_fpg() , unload_map() or unload_pcx() functions) and then, load it again. Example program: PROGRAM example_map_put_pixel; PRIVATE file1; coord_x; coord_y; colour; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=5; x=160; y=100; size=180; LOOP coord_x=rand(0, 199); coord_y=rand(0, 199); colour=rand(0, 15); // Points are placed in the graphic number 5 of the file1 map_put_pixel(file1, 5, coord_x, coord_y, colour); angle+=2000; FRAME; END END - In the example, graphic number 5 is put at the centre of the screen, continuously rotating. This graphic is a completely black background. For that reason, nothing will initially be seen on screen. But then, in every step of the loop, pixels of a colour randomly chosen between 0 and 15 (greys) are put in this graphic, at a pair of coordinates randomly chosen too. These pixels are put using the map_put_pixel() function. Notice how it seems that there are more and more pixels rotating on screen, when the only thing that really rotates is graphic number 5. The map_put() or map_xput() functions may be used to put a full graphic inside another one (and not only at one pixel). The map_block_copy() function may be used to put just a part of a graphic inside another one. Note: When the map_put_pixel() function is used to put a pixel in a graphic that is being used as background of a scroll window, it is possible that this pixel does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_put() - map_xput() - refresh_scroll() - map_block_copy()","title":"map_put_pixel()"},{"location":"help/#map_xput","text":"map_xput( , , , , , , , ) Description: Extended version of the function map_put() . Puts a graphic inside another one. The graphic that is going to be copied is called and the destination graphic is that inside which the origin will be copied. This function allows us to copy a graphic (origin) inside another one (destination). Both graphics must be in the same file. The parameters are the following ones, in order: - file code with the graphics library that contains both graphics. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). - code of the graphic inside which the other one is going to be put. - code of the graphic that is going to be copied in the destination. , - coordinates inside the destination graphic where the aim is to put the origin graphic. The origin graphic is going to be copied at these coordinates, from its upper left corner. - angle (in degree thousandths) in which the origin graphic is going to be copied; the normal angle is 0 . - size (in percentages) in which the original graphic is going to be copied (the normal size is 100 ). - Indicates the mirrors and transparencies with which the original graphic will be copied in the destination; the values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Horizontal transparencies and mirror. 6 -vertical transparencies and mirror. 7 -Transparencies, horizontal and vertical mirror. This function will modify the indicated graphic, but only its copy that has been loaded in the computer's memory. The original graphic, that is stored in the FPG or MAP or (PCX) files of the disk, will remain unchangeable . For that, if at a specific moment of the game the aim is to recover the original state of the graphic, it will be necessary to unload it from the memory (with unload_fpg() , unload_map() or unload_pcx() ) and then, load it again. Example program: PROGRAM example_map_xput; PRIVATE x_destination; y_destination; file1; angle1; size1; flags1; BEGIN file1=load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; LOOP x_destination=rand(0, 319); y_destination=rand(0, 199); angle1=rand(-pi, pi); size1=rand(10, 200); flags1=rand(0, 7); map_xput(file1, 1, 101, x_destination, y_destination, angle1, size1, flags1); angle+=2000; FRAME; END END - In the example, graphic 1 is put at the centre of the screen, continuously rotating (this graphic is a decorative background in grey tonalities). In every step of the loop, a triangle-shaped graphic (with number 100) will be put inside graphic 1. This new graphic will be put with coordinates, angle, size and flags (see flags variable) randomly chosen. Notice how brown triangles with different applied effects are continuously appearing in the background graphic. The map_xput() function is a version a little more complex than the map_put() function, which is easier to use when it is not required to put rotated, scaled, mirror and transparent graphics. The map_block_copy() function must be used to put a part of a graphic (instead of the full graphic) inside another one. Note: When the map_put() function (or any other similar) is used to modify a graphic that is being used as background of a scroll window, it is possible that the graphic you have put does not immediately appear on screen. To solve this problem, you must use the refresh_scroll() function. ---See: map_put() - map_put_pixel() - refresh_scroll() - map_block_copy()","title":"map_xput()"},{"location":"help/#move_scroll","text":"move_scroll( ) Description: Forces to scroll automatically and immediately. This function is rather advanced and, for that reason, it could be difficult to understand its purpose. As a parameter, the function requires the from 0 to 9 that was indicated in the start_scroll() function as first parameter when the scroll started. This function is used when a scroll region is automatically controlled, as the camera field of the scroll structure corresponding to the identifier of a process has been defined. The purpose is to force the ( x0 , y0 , x1 and y1 ) values of that structure to be updated. If this function is not used, these values won't be updated until the following game's frame. This means that when a scroll is automatically controlled and another process needs to know the value of the coordinates of that scroll before the next frame (normally to be located in a position in keeping with the background movement), do as follows: 1 - The scroll starts with start_scroll() . 2 - The process that will be used as camera is created and its identifying code is put in the camera field of the scroll structure . 3 - A very high priority must be set for this process, for it to run before the rest of the processes (putting in its priority local variable a positive whole value like, for instance, 100). 4 - The move_scroll() function will be called just before the FRAME statement of the process' loop used as camera. Thus, you will guarantee the previous execution of this process and, just at the end, the updating of the values ( x0 , y0 , x1 and y1 ) of the scroll structure , so the rest of the processes may use these variables already updated. The most widespread use of this function is when you want to have more than two backgrounds in a scroll window. For that, a series of processes simulating a third or fourth plane are created. The position of their coordinates will depend on the exact position of the scroll in every frame. A program doing so is shown below. Example program: PROGRAM example_move_scroll; PRIVATE file1; counter; BEGIN set_fps(100, 0); file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); scroll.camera=id; priority=100; write(0, 160, 0, 1, \"Use the right and left cursors to move\"); graph=101; ctype=c_scroll; LOOP if (key(_right)) x+=2; flags=0; END if (key(_left)) x-=2; flags=1; END move_scroll(0); // Updates the scroll structure[] FRAME; END END - This example starts a scroll at full screen with two planes. Then, it moves a triangle to the right and left with the cursors. This process will function as a scroll camera, automatically focusing the vision on it (by putting scroll.camera= id ; ). But, at the same time, it creates a total of 40 processes (from -2000 to 2000, every 100 pixels) with the picture of a vertical band with moving colours as if they were a third scroll plane (processes of the type movable_process ). For that, it is important that their z coordinate is greater than the rest of the processes ( z=100; ) and that the priority of the process that controls the camera is higher than ( priority=100; ) and that the latter uses the move_scroll() function before every frame ( FRAME; ). The processes simulated by the third plane ( movable_process ), place their x coordinate at a point depending on the scroll's x and its original position. The difference lies in the fact that, if move_scroll() had not been used, the processes, by using the scroll.x0 variable without being updated, would move with a certain slowness that detracted from the credibility of the game. ---See: start_scroll() - Scroll structure - Priority - Z","title":"move_scroll()"},{"location":"help/#move_text","text":"move_text( , , ) Description: Moves a text towards other screen coordinates. The ** text identifier and the ( x , y**) screen coordinates towards which the text must be moved are specified as parameters. The identifier of the text is a numeric code returned by the write() and write_int() functions when they are required to write a text. The centreing code specified in the write() or write_int() functions will remain when this function is used. The specified coordinates always dealt with the screen and may be inside it or out from it. It is necessary to use the text_z global variable to modify the {z coordinate of the texts} (the depth plane in which they appear). Example program: PROGRAM example_move_text; PRIVATE id_text1; id_text2; coord_x; coord_y; angle1; BEGIN id_text1=write(0, 160, 100, 4, \"MOVING TEXT\"); id_text2=write(0, 160, 100, 4, \"MOVE THE MOUSE\"); LOOP coord_x=160+get_distx(angle1, 100); coord_y=100+get_disty(angle1, 90); // We move the texts move_text(id_text1, coord_x, coord_y); move_text(id_text2, mouse.x, mouse.y); angle1+=1000; FRAME; END END - In the example, two texts are displayed at the centre of the screen with the write() function. This function returns the identifiers of those texts, that are stored in the id_text1 and id_text2 variables. In every step of the loop, the first text moves along a circular path obtained by increasing an angle ( angle1 ) and using the get_distx() and get_disty() functions. The second text will be placed at the coordinates of the mouse pointer. Both texts move in every frame with the move_text() function. To delete a text definitively, the text identifier is also required, and the delete_text() function must be used for that. ---See: write() - write_int() - delete_text()","title":"move_text()"},{"location":"help/#near_angle","text":"near_angle( , , ) Returns: A new angle nearer to the final angle. Description: Brings an angle nearer another one at the given increment. The function returns the new angle. It is used when the aim is that an angle ( ) gradually varies until it becomes another angle ( ). For that, the function needs the original angle, the final angle and the angular increment that is going to be added to or subtracted from the original angle. Keep in mind that all the angles are specified in degree thousandths. The angular increment is but a small angle (such as one degree ( 1000 ) or five ( 5000 ). Example program: PROGRAM example_near_angle; PRIVATE angle2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); mouse.graph=200; graph=101; write(0, 160, 200, 7, \"Move the mouse cursor\"); LOOP angle2=fget_angle(x, y, mouse.x, mouse.y); // Brings the current angle closer to the final one in 10 degrees at the most angle = near_angle(angle, angle2, 10000); advance(6); FRAME; END END - In the example, the mouse cursor is defined as a little cross that can be moved by the user. The main program defines its graphic as a triangle ( graph=101; ) that, in every loop's iteration, obtains the angle towards the mouse cursor with the fget_angle() function. Then, it modifies its angle to move 10 degrees (10000) at the most towards the cursor angle, using the near_angle() function. Finally, it advances 6 points in that direction by using the advance() function. Notice how the triangle continuously pursues the mouse cursor without making any abrupt turn (bigger than 10 degrees). ---See: Use of the angles in the language - angle - get_angle() - fget_angle()","title":"near_angle()"},{"location":"help/#out_region","text":"out_region( , ) Returns: True if the process is outside of the region or False in the opposite case. Description: This function determines whether a process is out of a screen region. For that, the function requires the identifying code of the process and a region number. The screen regions can be defined with the define_region() function and they are simply rectangular zones of screen. Region number 0 can not be defined, as it will always be equivalent to the entire screen. Therefore, if 0 is specified as a second parameter, this function determines whether a process is out of the screen (if it is not seen). In case that the process' graphic is out of the specified region, the function returns True (an odd number). Otherwise, if the graphic is seen in that region, even partially, the function returns False (any even number). The process whose identifying code is indicated must have its graphic correctly defined (normally in its graph variable). Otherwise, the system will produce an error, since it is not possible to calculate the dimensions of a graphic if the process lacks it. Example program: PROGRAM example_out_region; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); y=100; x=160; graph=101; LOOP advance(8); IF (out_region(id, 0)) // Check for off screen x=160; y=100; angle=rand(-pi, pi); END FRAME; END END - In the example, a background graphic is put and the main program creates a triangle-shaped graphic at the centre of the screen with an angle randomly chosen. In every step of the loop, the triangle advances and it is checked whether it is still present on the screen (region 0) with the out_region() function. If so, it is put once again at the centre of the screen with another angle, also randomly chosen. ---See: define_region() - region - codes identifiers","title":"out_region()"},{"location":"help/#play_cd","text":"play_cd( , ) Description: Starts playing a cd-audio track. The track number (from 1 to the number of songs contained on the cd) must be indicated. The way to do it is as follows: Mode. 0 - Play the song and then stop. 1 - Play this song and then the following ones. Example program: PROGRAM example_play_cd; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to turn the CD on.\"); LOOP IF (scan_code==_space) play_cd(1, 1); // It plays the 1st. song followed by all remaining tracks. END FRAME; END END - In the previous example (for which it is necessary to have a music Compact disc inside the CD-ROM device) an information message is displayed and in every iteration of the loop it is checked whether the spacebar was pressed to play the first song with the play_cd() function. To have a song indefinitely playing, a loop must be implemented, using the is_playing_cd() function to determine when the song is over. The cd-audio reproduction volume can be controlled with the setup structure and the set_volume() function. ---See: is_playing_cd() - stop_cd() - set_volume() - Setup structure","title":"play_cd()"},{"location":"help/#pow","text":"pow( , ) Returns: The first expression raised to the second. Description: Calculates the result when the first expression is raised to the second one. For instance, pow(3, 2) will return 9 , which is 3 squared, 3\u00b2 , or 3*3 . Example program: PROGRAM example_pow; GLOBAL values[15]; n; BEGIN FROM n=0 TO 15; values[n]=rand(-100, 100); write_int(0, 0, n*10, 0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to square these numbers\"); LOOP IF (scan_code==_space) FROM n=0 TO 15; values[n] = pow(values[n], 2); // Square the values (value\u00b2 or value ^ 2) END END FRAME; END END - This program will display a list of numbers randomly chosen between -100 and 100 on the screen. When the spacebar is pressed, these numbers will square. Take into account that in the language it is only possible to use integers within the ( min_int ... max_int ) range . Therefore, when the result of the function exceeds this range, incorrect results will be shown . In this case, the system won't produce an error, so care must be taken. ---See: Expression","title":"pow()"},{"location":"help/#put","text":"put( , , , ) Description: Puts a graphic in the screen background. The function requires the file code in which the graphic is stored, the graphic code inside the same file and the ( x , y ) coordinates at which the graphic is intended to be put. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). If the centre graphic was not specified (setting its control point number 0 from the painting tool), the coordinates will be referred to the position on the screen in which the graphic centre will be located. The graphics displayed on the screen background like this will be within the game's display under all the processes, scroll regions, texts, etc. If the aim is to have a graphic over some others, it must be created as a new process and its z variable must be established, indicating the priority of its display. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put; PRIVATE file1; coord_x; coord_y; BEGIN file1=load_fpg(\"help/help.fpg\"); LOOP coord_x=rand(0, 319); coord_y=rand(0, 199); put(file1, 100, coord_x, coord_y); // The graphic 100 is \"put\". FRAME; END END - In the example, the file with the graphics is loaded and in every iteration of the loop graphic number 100 (a ball) is put, with the put() function, at random coordinates (randomly chosen with the rand() function). If the graphic that is intended to be put is merely a background screen, it is easier to use the put_screen() function, since it does not require the screen coordinates, because it will automatically centre the graphic on the screen. The xput() function is a version a little more complex than the put() function, but with much more utilities since, at the same time, it allows us to put rotated, scaled, mirror and transparent graphics. To put a graphic inside another one (instead of in the screen background), the map_put() or map_xput() functions must be used. ---See: put_screen() - xput() - map_put() - map_xput() - put_pixel()","title":"put()"},{"location":"help/#put_pixel","text":"put_pixel( , , ) Description: Plots a pixel of the specified colour at the indicated coordinates ( x , y ) on the background screen. The pixels put with this function in the background screen will be displayed in the game {below all the processes, scroll regions, texts, etc.} If the aim is to see a pixel over other graphics, you must create a new process, assigning the picture of a point (in its graph variable) as a graphic and fixing its z variable with the priority of its printing. To clear the background screen, the clear_screen() function must be used. Example program: PROGRAM example_put_pixel; PRIVATE x_pixel; y_pixel; colour; BEGIN LOOP x_pixel=rand(0, 319); y_pixel=rand(0, 199); colour=rand(0, 15); // The pixels are put in the background screen at random put_pixel(x_pixel, y_pixel, colour); FRAME; END END - In the example, in every step of the loop the pixels are put with the put_pixel() function, with coordinates and colour chosen at random with the rand() function. To read the colour of a specific background screen colour, the get_pixel() function must be used, returning a number between 0 and 255 corresponding to the order of the colour inside the palette. The put() function must be used to set a graphic on the screen, instead of a simple pixel. It is also possible to set the colour of a pixel in a specific graphic, instead of in the background screen, by using the map_put_pixel() function. ---See: get_pixel() - put() - map_put_pixel() - map_get_pixel()","title":"put_pixel()"},{"location":"help/#put_screen","text":"put_screen( , ) Description: Establishes the background screen. The function requires the file code in which the graphic is, and the own code of the graphic intended to be displayed in the background screen inside the file. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). The function does not require any coordinate as a parameter since, if the graphic size (in pixels) is different from that of the screen, the former will simply be displayed centred in the latter. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put_screen; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); // Graphic 1 is established as background. LOOP FRAME; END END - In the example, the graphics' file is loaded and a background graphic (contained in the file with the graphic code number 1) is set with the put_screen() function. If the aim is to display a graphic on a specific part of the screen or a graphic that is not centred , the put() may be used. Moreover, the xput() function allows us to display rotated, scaled, mirror and/or transparent graphics in any screen region. ---See: put() - xput() - put_pixel() - clear_screen()","title":"put_screen()"},{"location":"help/#rand","text":"rand( , ) Returns: A random numeric value. Description: Returns a random number (chosen at random) between the minimum value and the maximum value , both included. This function is normally used to set all the parameters intended to be varied in a game when it is restarted. For instance, the coordinates of an enemy may be initialised with random numbers, so it may appear in a different position in every game. This function has another utility. Thus, if we want that an action does not always occur, but that it has a certain probability to occur, we normally use a statement of the following type: IF (rand(0, 100)<25) ** // Action ...** END In this case, the action will take place, on average, 25 per cent of the times the IF statement would be executed. The reason for that is that, on obtaining a random number between 0 and 100, this number would be less than 25 in a fourth of times, approximately. Example program: PROGRAM example_rand; PRIVATE table[15]; counter; BEGIN write (0, 0, 192, 0, \"Press [SPACE] to calculate random values.\"); FROM counter=0 TO 15; write_int(0, 0, counter*10, 0, offset table[counter]); END LOOP IF (scan_code==_space) FROM counter=0 TO 15; // Random values between -100 and 100 are chosen table[counter] = rand(-100, 100); END END FRAME; END END - In the example, a table with 16 data (from 0 to 15) is created. In every iteration of the main loop it is checked whether the spacebar has been pressed. If so, the 16 data of the table will be filled with random values between -100 and 100, chosen with the rand() function. By default, the values returned by the rand() function will completely be different in every execution of the program. If we want to have always the same series of numbers, we may use the rand_seed() function, specifying a number behind which the series of numbers returned by the rand() function will always be predetermined. ---See: rand_seed()","title":"rand()"},{"location":"help/#rand_seed","text":"rand_seed( ) Description: This function sets a seed for the generator of random numbers (the numbers generated by the rand() function). The seed can be any integer within the range ( min_int ... max_int ). If the seed is set, all the numbers generated by the rand() function will be the same in every execution of the program. After having been established an origin seed, the rand() function will return a series of numbers predetermined for this seed. Example program: PROGRAM example_rand_seed; PRIVATE table[15]; counter; BEGIN write (0, 0, 184, 0, \"Press [ENTER] to set 1234 as a seed.\"); write (0, 0, 192, 0, \"Press [SPACE] to calculate random values.\"); FROM counter=0 TO 15; write_int(0, 0, counter*10, 0, offset table[counter]); END LOOP IF (scan_code==_space) FROM counter=0 TO 15; table[counter] = rand(-100, 100); END END IF (scan_code==_enter) rand_seed(1234); // A seed is set to generate the random numbers. END FRAME; END END - In the example, a table with 16 bits of data (from 0 to 15) is created. In every iteration of the main loop, the data will be filled with random values from -100 and 100 (chosen with the rand() function) every time the spacebar is pressed. And when the ENTER key is pressed, then the seed of the random numbers will be defined as 1234 with the rand_seed() function. Notice how, every time the ENTER key is pressed and then, by pressing the space bar, the same series of random numbers (17, 94, -38, ...) is obtained. This series will be different for every possible seed. ---See: rand()","title":"rand_seed()"},{"location":"help/#refresh_scroll","text":"refresh_scroll( ) Description: This function is used when a graphic that is being used as a background of a scroll region has been modified with the map_put() , map_xput() , map_block_copy() or map_put_pixel() functions, in order to update it. The parameter required by the function is the that was specified when the scroll started with the start_scroll() function. When a graphic that is being used as background of a scroll is modified, it is not automatically updated on the screen. On the contrary, it is necessary to call this function for that purpose. Once the graphic has been modified, it will remain like this during the rest of the program execution, unless the graphic is unloaded from the memory (with unload_fpg() , unload_map() or unload_pcx() functions) and loaded again. In this case, the original state of the graphic will be restored. Example program: PROGRAM example_refresh_scroll; BEGIN load_fpg(\"help/help.fpg\"); start_scroll(0, 0, 103, 102, 0, 15); scroll.camera=id; write(0, 160, 192, 7, \"Press [ENTER] to put a graphic in the scroll.\"); write(0, 160, 200, 7, \"Press [SPACE] to update scroll.\"); LOOP IF (scan_code==_enter) map_put(0, 103, 100, rand(16, 48), rand(16, 48)); END IF (scan_code==_space) refresh_scroll(0); // We refresh the scroll 0. END x+=2; y+=1; FRAME; END END - In the example, a scroll (number 0) is created as a scroll of two planes: the foreground with graphic number 103 and the background with graphic number 102. Inside the main loop, a ball will be displayed over graphic 103 (foreground of the scroll) when the ENTER key is pressed. But it won't appear on-screen, unless we await until the scroll gradually appears on-screen (with graphic 103 already modified), or until the spacebar is pressed. In this case, the call to the refresh_scroll() function will update the scroll window with the graphic already modified. If, in the previous example, the refresh_scroll() function had been called just after the map_put() one, the graphics displayed on the foreground would instantaneously appear by pressing the spacebar. In the example, every time that a ball is displayed, many of them appear. The reason for this is that graphic 103 used as a foreground in the scroll is a small graphic and it is shown on many occasions tile, to fill all the scroll zone. Note: It can be noticed that, if the displaying graphic is at some coordinates out of the screen, it won't be necessary to call this function, because the parts of the scroll that are gradually appearing on-screen are automatically refreshed. ---See: start_scroll() - move_scroll() - Structure scroll","title":"refresh_scroll()"},{"location":"help/#reset_fli","text":"reset_fli() Description: This function rewinds an FLI/FLC animation to the beginning. This animation started with the start_fli() function. After having called this function, the animation will entirely be displayed again from the beginning (to display every frame of the animation, you must call the frame_fli() function). The utility of this function deals with the possibility of stopping an animation and repeating it again from the beginning, without unloading it ( end_fli() ) and loading it again. If the aim is to perform an animation indefinitely, restarting when it is over, then it is not necessary to use this function , since it will automatically be done with frame_fli() , if you keep on calling once the animation is over. Only one animation can exist at the same time. Thus, it is not necessary to specify any parameter for this function. Example program: PROGRAM example_reset_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); write(0, 160, 0, 1, \"Press [SPACE] to restart the animation.\"); LOOP frame_fli(); IF (scan_code==_space) reset_fli(); // The animation is initialised END FRAME; END END - In the example, an animation is loaded with the start_fli() function and then, it is indefinitely performed with the frame_fli() function. In the loop, it is checked whether the spacebar has been pressed. If so, the animation is reinitialised with the reset_fli() function. ---See: start_fli() - frame_fli() - end_fli()","title":"reset_fli()"},{"location":"help/#roll_palette","text":"roll_palette( , , ) Description: Rotates a range of palette colours. This function is used to create movement effects in static graphics, like the effect of flowing water. To use this function, it is first necessary to create graphics that use a range of consecutive colours of the original palette, in a perpetual cycle (for instance, colours ranging from 0 to 15 , painting something with the colours 0, 1, 2, 3, ... , 14, 15, 0, 1, 2, ...). Then, it is necessary to take care that those colours are not used by other graphics that are going to appear on the screen at the same time, if you do not want to implement the effects on them. The increment (third parameter) is normally 1 to perform the rotation in a direction and -1 to perform it in the opposite direction, but other values may be used to perform the colours cycle at higher speed. To perform a cycle of colours from 0 to 15 , it would be necessary to specify 0 as and 16 as . Example program: PROGRAM example_roll_palette; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); write(0, 160, 0, 1, \"Press [SPACE] to rotate the entire palette.\"); LOOP IF (scan_code==_space) roll_palette(0, 256, 1); // The 256 colours rotate. END FRAME; END END - In the example, a multicolour screen is put as background and, inside the program's main loop, the 256 colours of the palette will rotate every time that the spacebar is pressed. To determine the palette which is going to realise the circle of colour, this must be loaded from an file with the function load_pal() . To perform other palette effects without replacing some colours by other ones in cycles, the fade() function must be used. This function allows us to perform many colours fading and saturations at different speeds. There are two simplified versions of this last function that allow us to carry out a fading to black ( fade_off() ) and undo it ( fade_on() ). ---See: set_color() - load_pal() - fade() - fade_off() - fade_on()","title":"roll_palette()"},{"location":"help/#save","text":"save( , , ) Description: Saves a data block from the program memory to a file in the disk, to recover it later, when it is required, with the load() function. For that, the function requires the file name , the offset (inside the computer memory) of the variable, table or structure stored in the disk (the variable offset is obtained with OFFSET ) and the number of memory positions that this variable occupies (which may be obtained with sizeof ( ) ). It is possible to save several data (variables, tables or structures) if they have consecutively been defined inside the same section ( GLOBAL , LOCAL or PRIVATE ). In this case, the OFFSET of the first variable must be indicated as a second parameter , and the addition of the sizeof() of all the data must be indicated as a third parameter . It is not necessary to specify a path together with the file name. Example program: PROGRAM example_load; PRIVATE table[9]; counter; BEGIN write (0, 0, 0, 0, \"Press [ENTER] to reset the data.\"); write (0, 0, 10, 0, \"Press [SPACE] to load the disk data\"); write (0, 0, 30, 0, \"Current values of the data:\"); FROM counter=0 TO 9; table[counter]=rand(0, 100); write_int(0, 0, 40+(counter*10), 0, offset table[counter]); END save(\"help/help.dat\", offset table, sizeof(table)); // The file is saved. LOOP IF (key(_enter)) FROM counter=0 TO 9; table[counter]=0; END END IF (key(_space)) load(\"help/help.dat\", offset table); END FRAME; END END - At the beginning of the example, a table of 10 positions (from 0 to 9) is created with random values. This table is saved in the disk with the save() function. When the ENTER key is pressed, the table values are reset (the 10 positions are put at 0). When the spacebar is pressed, the table's values stored in the disk are loaded with the load() function. To save the table[9] and the counter variable in the same file, the save() function should have been called in the following way: save(\"help/help.dat\", offset table, sizeof(table)+sizeof(counter)); Do not vary the load statement ( load(\"help.dat\", offset table); ), as it does not require the number of data. The value returned by sizeof() for any variable (like counter ) will always be 1. For a table, this function returns the number of positions that it has. Then, considering that 11 data (10 of the table and 1 of the variable) are going to be saved, the statement to save them could be as follows: {save(\"help/help.dat\", offset table, 11); ---See: load() - OFFSET - sizeof()","title":"save()"},{"location":"help/#set_fps","text":"set_fps( , ) Description: This function regulates the speed of the game; it defines how many frames per second will be displayed during the game. By default, the display will be regulated at 18 frames per second, which means that if a process moves a pixel per every ( FRAME ), it will move on-screen at a speed of 18 pixels per second. This function may establish the number of Frames Per Second ( FPS ) from a minimum of 4 to a maximum of 200 ; in general, no more than 24 frames per second are necessary to obtain a fluid and slight movement. The second parameter, maximum number of allowed omissions , is referred to how the program must preferably work when it is executed on a computer fast enough to calculate the required number of frames per second. It works as follows. Number of allowed omissions. 0 - The game will go at a slower speed when it is executed on a computer that is too slow to keep the required frame rate - It will only display the frames per second that the computer has had time to calculate. 1 - If the computer cannot calculate all the frames, it is allowed to occasionally skip a frame to try to keep the game's relative speed. The game movements will become a little more abrupt, but faster. 2 or more - The game is allowed to skip as many consecutive frames as is indicated in this parameter to maintain the original relative speed of the game. For instance, if the number of omissions is set at 4 and in the game a process moved one pixel at a time, in a very slow computer it could move four pixels at a time. Example program: PROGRAM example_set_fps; PRIVATE frames=24; omissions=4; BEGIN load_fpg(\"help/help.fpg\"); graph=1; x=160; y=100; write(0, 0, 0, 0, \"Frames per second: Up(+) / Down(-)\"); write_int(0, 0, 10, 0, offset frames); write(0, 0, 20, 0, \"Allowed omissions: Right(+) / Left(-)\"); write_int(0, 0, 30, 0, offset omissions); write(0, 160, 200, 7, \"Use the CURSORS to change the values.\"); LOOP // The number of frames per second is chosen set_fps(frames, omissions); IF (key(_up) AND frames<200) frames++; END IF (key(_down) AND frames>4) frames--; END IF (key(_right) AND omissions<20) omissions++; END IF (key(_left) AND omissions>0) omissions--; END angle+=4000; FRAME; END END - In the example, the necessary messages are displayed and the main process creates a graphic, which is indefinitely rotating at the centre of the screen. In every step of the loop the cursor keys are detected, the number of frames per second ( frames ) is changed with up/down and the maximum number of allowed omissions is changed with right/left . At the beginning of every iteration of the loop, the speed is set with the set_fps() function, according to the values of both variables. Note: The global variable fps monitors the number of frames per second which is being reached in the program. ---See: FRAME - max_process_time - set_mode() - fps","title":"set_fps()"},{"location":"help/#set_mode","text":"set_mode( ) Description: Establishes a new video mode for the game execution. The allowed videomodes that may be specified as a parameter are the following ones: m320x200 - VGA standard m320x240 - X Mode m320x400 - X Mode m360x240 - X Mode m360x360 - X Mode m376x282 - X Mode m640x400 - SVGA VESA m640x480 - SVGA VESA m800x600 - SVGA VESA m1024x768 - SVGA VESA When a change of the videomode in the program is made, a fading to black (of the program's colours palette) will automatically be performed and in the following displays, the colours palette will gradually be restored. That is to say, set_mode() always performs a fade_off() just before changing the videomode and a fade_on() just after having changed it. By default, all the programs start with the 320 by 200 pixel activated mode ( set_mode(m320x200) ). Example program: PROGRAM example_set_mode; PRIVATE modes[]= m320x240, m640x480, m800x600, m1024x768; videomode=0; BEGIN load_fpg(\"help/help.fpg\"); write (0, 0, 0, 0, \"Press [SPACE] to change the videomode\"); LOOP IF (scan_code==_space) videomode=videomode+1; IF (videomode==4) videomode=0; END set_mode(modes[videomode]); END FRAME; END END - In the example, a screen background and an explanatory text are displayed. In the iteration of the main loop, if the space bar is pressed, a new videomode will be activated with the set_mode() function. Important: By using the set_mode() function, all the scroll and mode 7 windows that were activated in the game, as well as all the processes displayed inside them, will be deleted. ---See: set_fps() - max_process_time - m320x200 ... m1024x768 - STRUCT video_modes","title":"set_mode()"},{"location":"help/#signal","text":"signal( , ) Description: Sends a signal to a process (an object of the game). This function is used mainly to destroy (kill) a process from other, sending it a signal s_kill . If you don't know the meaning of process father, son, brother , of an orphaned process, etc., then see Hierarchy of processes . If you don't know the terms live, dead , slept , etc., referred to processes , then see Process state Example: PROGRAM my_game; PRIVATE id2; BEGIN id2=my_process(); // ... signal(id2, s_kill); END PROCESS my_process() BEGIN // ... LOOP FRAME; END END - This program would create a my_process type process and then it would delete it with the signal(id2,s_kill) statement (id2 is a variable of the main program that contains the identifying code of the process that is going to be deleted). Any process may send a signal to another one, provided that the former has the identifying code of the latter. See: Identifying codes of processes Ways to obtain the identifying code of a process Nevertheless, there are other signal types that may be sent to a process, and they are the following ones: s_kill - Order to kill the process. The process will not appear in the following frames of the game any longer. s_sleep - Order to make the process dormant . The process will remain paralyzed, without executing its code and without being displayed on screen (nor being detected by the rest of the processes), as if it had been killed. But the process will continue to exist in the computer's memory (see s_wakeup ). s_freeze - Order to freeze the process. The process will remain motionless without running its code. But it will continue being displayed on screen and it will be possible to detect it (in the collisions) by the rest of the processes. The process will continue to exist in the computer's memory, even if its code is not executed (see s_wakeup ). s_wakeup - Order to wake up the process. It returns a slept or frozen process to its normal state. The process will be executed and displayed again from the moment that it receives this signal normally. A process that has been deleted (killed) can not be returned to its normal state, since it does not exist in the computer's memory any longer. A process can also send these signals to itself, taking into account that the identifying code of a process is always ID (word reserved in the language to this purpose). The statement would be as follows: signal( id , ) Self-deleting a process in this way, sending a s_kill signal to itself, will not instantaneously destroy the process, but in the following ( FRAME ) display. The RETURN statement can be used to immediately delete a process. All the signals sent to processes will be implemented just before the next display of the game , in the next FRAME of the game (not instantaneously). Together with these four signals, there are other four signals that directly correspond to the previous ones. They are: s_kill_tree , s_sleep_tree , s_freeze_tree and s_wakeup_tree . These signals are sent not only to the indicated process, but also to all the processes that it has created . That is to say, if a s_kill_tree signal is sent to a process, the latter and all its descendants (sons, grandsons, ...) will be deleted as well as all the processes created by it and the processes created by the latter. An exception to these last four signals is when there is an orphan process , a process whose father (the process that called it) is already dead. The orphan processes will not receive the signal when it is sent to a process from which they are descended as, on having disappeared their father, it won't be able to send the signal to the processes it created. Example program: PROGRAM example_signal; PRIVATE id_text; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"1 - create the process\"); write(0, 0, 10, 0, \"2 - kill the process\"); write(0, 0, 20, 0, \"3 - sleep the process\"); write(0, 0, 30, 0, \"4 - freeze the process\"); write(0, 0, 40, 0, \"5 - wake up the process\"); id_text=write(0, 0, 190, 0, \"There is no process\"); LOOP IF (key(_1) AND NOT son) delete_text(id_text); my_process(); id_text=write(0, 0, 190, 0, \"Process alive\"); END IF (key(_2) AND son) delete_text(id_text); signal(son, s_kill); id_text=write(0, 0, 190, 0, \"There is no process\"); END IF (key(_3) AND son) delete_text(id_text); signal(son, s_sleep); id_text=write(0, 0, 190, 0, \"Process slept\"); END IF (key(_4) AND son) delete_text(id_text); signal(son, s_freeze); id_text=write(0, 0, 190, 0, \"Process frozen\"); END IF (key(_5) AND son) delete_text(id_text); signal(son, s_wakeup); id_text=write(0, 0, 190, 0, \"Process alive\"); END FRAME; END END PROCESS my_process() BEGIN graph=100; LOOP x=160+get_distx(angle, 140); y=100+get_disty(angle, 80); angle+=5000; FRAME; END END - With the 1 key, this program will create a process ( my_process ) that rolls around the screen; with the keys from 2 to 5 , different signals will be sent to this process, by using this function. The identifying code of my_process is located in the son local variable of the main program by default. When a process is created, the system defines the son variable of the father with the identifying code of the son, and the father variable of the son with the identifying code of the father. signal( TYPE , ) Description: This second meaning of the signal function is similar to the previous one, with the exception that, instead of sending a signal to a process from its identifying code , it allows us to send a signal {to all the processes of a specific type} or to them and their descendants, when the used signals are of the type s_kill_tree (see: Types of processes ). For instance, if several processes of the enemy type exist or may exist in a game, and the aim is to freeze these processes (without freezing their descendants), the following statement will be used: signal(TYPE enemy, s_freeze); As it can be noticed, it is necessary to have the identifying code of a specific process in order to send a signal to it. To delete a group of processes, it is necessary either that they are of the same kind, that this group is made up of a process and its descendants, or that all their identifiers are known ( in order to send them the signal one by one). It is possible to send a signal to a type of processes, even if no process of this type is being executed in the game. But if a signal is sent to a process that has already been killed, with its identifying code (first meaning of the signal statement), there is a risk that the identifying code is now used by another process, which is going to receive the signal. This happens, for instance, when the aim is to kill a process that has already been killed, as it is possible that another different one is being killed. Note: If the aim is to delete all the processes except the current one, the let_me_alone() function may be used. This function sends a s_kill signal to all the processes, except the one that executed this function. ---See: let_me_alone() - Identifier codes - Types of processes","title":"signal()"},{"location":"help/#sound","text":"sound( , , ) Returns: The channel number through which the sound is played. Description: Plays the effect whose sound code is specified as first parameter. At first, the sound must have been loaded from a PCM file with the load_pcm() or load_wav() functions. This function returns the sound code corresponding to this effect. As a second parameter, it is necessary to specify the volume at which the sound is intended to be reproduced, taking into account that 0 is the minimum volume, and 256 the maximum volume. As third parameter, you must specify the frequency (speed) at which the sound is intended to be reproduced, being 256 the standard frequency that will reproduce the original sound. With lesser values, the sound will be reproduced with more accentuated bass. On the contrary, with higher frequency values, it will be reproduced with more accentuated treble. The function returns the channel number that can be used by the stop_sound() function to stop the sound and by the change_sound() function to modify its volume or frequency. There are 16 sound channels. Thus, up to 16 sounds may simultaneously be played. Example program: PROGRAM example_sound; PRIVATE volume=128; // Average value (0..256) frequency=256; // Average value (0..512) id_sound, channels; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 0, 0, 0, \"Volume: Up(+) / Down(-)\"); write_int(0, 0, 10, 0, offset volume); write(0, 0, 20, 0, \"Frequency: Right(+) / Left(-)\"); write_int(0, 0, 30, 0, offset frequency); write(0, 160, 180, 1, \"Press [SPACE] to play the sound.\"); write(0, 160, 190, 1, \"Use the cursors to change the values.\"); id_sound = load_pcm(\"help/help.pcm\", 0); LOOP IF (scan_code==_space) // Plays it channels = sound(id_sound, volume, frequency); END IF (key(_up) AND volume<256) volume++; END IF (key(_down) AND volume>0) volume--; END IF (key(_right) AND frequency<512) frequency++; END IF (key(_left) AND frequency>0) frequency--; END FRAME; END END - In the example, a background screen and an explanatory text are displayed, and a sound is loaded with the load_pcm() function. This function returns the identifier of the sound , that is stored in the id_sound variable. In the main loop, at every keystroke of the spacebar, the sound is played with the sound() function with the parameters defined in the volume and frequency variables. These values can be manipulated with the cursors keys, in order to understand better how it works. The channel number returned by sound() , that is stored in the channel variable, could have been used to modify the sound with change_sound() or to stop it with stop_sound() . ---See: load_pcm/wav() - change_sound() - stop_sound()","title":"sound()"},{"location":"help/#sqrt","text":"sqrt( ) Returns: The entire square root of the expression. Description: Calculates the square root of the expression passed as a parameter, truncated to an integer . For instance, as a result, sqrt(10) will return 3 and not 3.1623 , which is the real value (approximately) of the square root of ten. Example program: PROGRAM example_sqrt; GLOBAL values[15]; n; BEGIN FROM n=0 to 15; values[n]=rand(0, 100000); write_int(0, 0, n*10, 0, offset values[n]); END write(0, 0, 192, 0, \"Press [SPACE] to calculate its square root\"); LOOP IF (scan_code==_space) FROM n=0 TO 15; values[n] = sqrt(values[n]); END END FRAME; END END - This program will display a list of randomly chosen values on-screen. When the spacebar is pressed, the program will apply the sqrt() function to all these values, calculating their square root. ---See: Expression","title":"sqrt()"},{"location":"help/#start_fli","text":"start_fli( , , ) Returns: The animation's number of frames. Description: Starts a FLI/FLC animation contained in the specified file , in the coordinates ( x , y ) (the upper left coordinate of the display window must be specified). The path can be specified in the . The path is not necessary if the file is in the DIV Games Studio directory or in a subdirectory whose name coincides with file extension (for instance, \"fli\\anima.fli\"). The screen must hold the whole animation. That is to say, if the animation occupies the whole screen, the videomode must be fixed at first with the set_mode() function, starting then the animation at the (0, 0) coordinate with the start_fli() function. For your information, the function returns the number of frames that the whole animation comprises. The system will automatically activate the colour palettes that the FLI/FLC animation could have. This can cause problems dealing with the representation of other graphics or fonts of the program, if they had been drawn with a different palette. If the aim is to combine other graphics with animation on-screen, the latter must have just one colour palette (which is normally called \" palette low FLI/FLC \") and the graphics must have been drawn with that same palette. Once the animation has started, its frames will gradually be shown with respective calls to frame_fli() . It is possible to have but one active animation at every time . Therefore, after having started an animation with start_fli() and having been displayed with frame_fli() , this animation must finish with the end_fli() function before starting another different animation. Example program: PROGRAM example_start_fli; BEGIN start_fli(\"help/help.fli\", 0, 0); // An animation begins. LOOP frame_fli(); FRAME; END END - In the example an animation which is inside of the file help/help.fli begins with the function start_fli() in the coordinates (0, 0) and the animation is played indefinitely. The frame_fli() function, used to show every frame, will return 0 when the animation is over. Therefore, to show the animation just one time you should have done as follows: Example program: PROGRAM example_start_fli; PRIVATE fli_frames; BEGIN start_fli(\"help/help.fli\", 0, 0); REPEAT fli_frames=frame_fli(); FRAME; UNTIL (fli_frames==0); end_fli(); END - The reset_fli() function allows us to rewind the animation, so that the frame_fli() function continues to execute it from the beginning. ---See: end_fli() - reset_fli() - frame_fli()","title":"start_fli()"},{"location":"help/#start_mode7","text":"start_mode7( , , , , , ) Description: This is an advanced function whose use requires special skill of its user. Creates a mode-7 display window. That is to say, it displays a three-dimensional graphic in a folded plane. In order to obtain this effect, this function will be called with the following parameters: - Up to 10 mode-7 windows can be created on-screen, numbered from 0 to 9 . If the aim is to create but one, the best thing to do is to define window number 0 . This number will be necessary later to modify the window parameters, as the system will need to know which one of the possible 10 mode-7 windows is intended to modify. - The graphics intended to be folded in the window must be in a file whose file code must be specified here, as a second parameter of the function. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) function will be used as if they belonged to the first file (the file with the code 0). - The third parameter must be the main code of the graphic which is going to be brought down in the window and must belong to the file previously indicated. - Here, it is possible to indicate either a 0 , if the aim is not to see any graphic beyond the graphic folded in the perspective, or a graphic code of the same file that will be shown in the perspective beyond the main graphic , until it gets the horizon. The height and width of this graphic must be powers of two, not higher than 8192 (these powers of two are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 & 8192). For instance, it can be a 64 pixel width by 32 pixel height graphic. This graphic will also be shown folded. - Here, the rectangular screen region in which the mode-7 is going to be shown, will be indicated. If 0 is indicated as a region number, this region will be shown on the whole screen. The rest of regions must previously be defined with the define_region() function (a region is but a rectangular zone of the screen). - The last parameter to indicate will be the distance, in pixels, from the upper part of the window, where the horizon line is intended to be put. If the camera is placed above the folded plane, then nothing will be displayed above the horizon line (this space is normally filled with another scroll or mode-7 window). Otherwise, if the camera is placed below the plane, then nothing will be shown below this horizon line. Besides the call to the function, some values of the global structure m7 must be initialised for the correct window's working . This is a structure of 10 records (one for every possible mode-7 window) and every record has the following fields: camera - Identifying code of the camera height - Height of the camera distance - Distance of the camera horizon - Height of the horizon focus - Focus of vision z - Depth plane colour - Exterior colour Important: In order to activate the mode 7 window it is indispensable to start the camera field as, without this field, the window can not determine from where the folded plane must be seen . The camera will be placed in the folded plane, at the indicated distance of the process whose identifying code has been set in camera , orientated at its angle itself (the one indicated by its angle local variable). The height at which the camera is located with respect to the bottom will be that indicated in the height field. See the help about the m7 structure for further information about these issues, or about how to access them. Example program: PROGRAM example_start_mode7; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_mode7(0, file1, 4, 0, 0, 64); m7.height = 64; m7.distance = 32; m7.color = 162; m7.camera = id; write(0, 160, 0, 1, \"Use the cursors to move\"); LOOP IF (key(_right)) angle-=8000; END IF (key(_left)) angle+=8000; END IF (key(_up)) advance(6); END FRAME; END END - In the example, the graphics file is loaded and then, a three-dimensional mode 7 is created with the start_mode7() function. This function is passed the following parameters: 0 - Number of mode 7 window (the first one, as just one window of this kind will be created). file1 - Code of the file from which the graphics must be taken. This is the code of the help.fpg file, that was loaded with the load_fpg() function. 4 - Code of the main graphic to fold inside the mode 7. To see this graphic, the file must be loaded with the Files menu . Thus, it is possible to observe which one is the graphic with code 4 0 - Code of the secondary graphic. A 0 indicates that no secondary (external) graphic will appear in the mode 7, so the external graphic will be displayed in the colour indicated by the m7[0].colour variable. In order to observe the effect of putting an external graphic , this parameter can be replaced, for instance, by 100 (that is the code of a 32 by 32 pixel brown ball stored in the help.fpg file). 0 - Region number of the screen on which the mode 7 must be placed . A 0 indicates that it must be placed on the entire screen. 64 - Height of the horizon. This last parameter indicates that the horizon line will be placed at 64 pixels from the upper part of the window. After having called the start_mode7() function, the program defines the following values of the global structure m7 : m7.height=64; - To show that the camera must be placed at 64 pixels from the bottom. m7.distance=32; - To show that the camera must be placed at 32 pixels behind the camera process. m7.colour=162; - To indicate that the external part must be displayed in colour number 162 of the palette. m7.camera= id ; - To indicate that the current process will be the camera process. The camera will be placed 32 pixels behind the main process, at 64 pixels height, orientated at the angle indicated by its angle variable. After these initialisations, the sample program will remain in a loop that simply controls the angle of the main process with the cursors. This angle will be that of the camera and, when the up cursor key is pressed, the advance() function will be called for the main process (and, consequently, the mode 7 camera) to advance 6 pixels. --- How to visualise processes graphics in mode 7. --- To create a process whose graphic is displayed in the mode 7, its ctype local variable must be defined as c_m7 ( type of coordinate as mode 7 coordinate ), which will be done with the following statement: ctype=c_m7; After this, the process will be displayed in the mode 7 with its graphic ( graph ) scaled depending on the distance at which it is. The process must only modify its x and y variables to move through the folded plane. When a process belongs to the mode-7 (the value c_m7 has been assigned to its local variable ctype ): Its x and y variables will be referred to the folded main graphic's point above which the process graphic will be placed. Its z variable will lose its effect, as the graphics will appear in strict order of depth. This variable will only be useful to indicate display priorities in graphics exactly placed in the same depth plane. The process will automatically be deleted when the mode 7 window, to which the process belongs, is deleted with the stop_mode7() function, or when the videomode is changed with the set_mode() function as, by doing so, the mode 7 windows will also be deleted. If there were several mode 7 windows, the process would be displayed in all of them by default. If the process had to be displayed just in one of them, its cnumber local variable should be then defined. For instance, if there were 6 mode 7 windows (from number 0 to number 5) and the aim was to display a process only in windows 0 and 2, the following statement should be included in it: cnumber=c_0+c_2; For a process to have several graphics (several views), depending on the angle from which it is observed, its graphic must be defined with the xgraph local variable (instead of the graph variable). To define this variable, it is necessary, at first, to create a table (of any name), first indicating the graphic's number of views and then the graphics codes for these views, starting with angle 0 and in an anticlockwise direction. For instance: GLOBAL views_car[]=4, 100, 101, 102, 103; The table views_car would define 4 views: graphic 100 for angles near 0 degrees, graphic 101 for angles near 90 degrees, graphic 102 for angles near 180 degrees, etc. And then, the xgraph variable must be initialised in the process code with the following statement: xgraph=OFFSET views_car; To get an example about what we have just seen, examine some of the DIV Games Studio's sample games that use this technique. Thus, read the comments about these programs (for instance, see Speed for dummies ). ---See: stop_mode7() - Structure m7","title":"start_mode7()"},{"location":"help/#start_scroll","text":"start_scroll( , , , , , ) Description: This function has a certain complexity, requiring a special skill of the user, who (should have previously programmed) to use it. Creates a scroll window, in which it will perform a view against a background graphic. That is to say, by using a graphic bigger than the display window as a game background, a part of this graphic can be showed and shifted in any direction. To obtain this effect, this function will be called with the following parameters: - Up to 10 scroll windows can be created on screen, numbered from 0 to 9 . If the aim is to create only one, the best thing is to define window number 0 . This name will later be necessary to modify the parameters of the window, as the system will need to know which one of the 10 possible scroll windows is intended to change. - The graphics that are intended to be shown as a background in that window must be in a file whose file code must be specified here, as a second parameter of the function. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) functions will be used as if they belonged to the first file (the file with the code 0). - The third parameter must be the code of the main graphic that is going to be displayed as a background in the window and that must belong to the file previously indicated. This graphic is normally the main window of the game on which the action will be developed. It is a graphic bigger than the display window, that will be shifted in one or several directions and on which the graphics of the game will be placed. The scroll window will be initially placed with the control point number 0 of this graphic in the upper left corner, when this point has been defined in the graphic editor . - Here, 0 will be indicated if the aim is to obtain a single scroll plane (a single background graphic), or another graphic code if it is intended that it appears as scroll background (deeper), behind the foreground. In order to see this background plane, it is indispensable that the main graphic (foreground) has parts painted in colour number 0 of the palette, as these transparent zones will allow us to see the background graphic through them. - The rectangular screen region in which the scroll is going to be shown will be here indicated. If 0 is indicated as a region number, it will be shown on full screen. The rest of regions must previously be defined with the define_region() function (a region is but a rectangular zone of the screen). - A value defining whether each of the two scroll planes is horizontally and vertically cyclical will be here indicated. For instance, a plane is horizontally cyclical when, on leaving the picture on the right, the picture appears on the left. To obtain this value, the following quantities must be added: ** + 1** - If the foreground is horizontally cyclical. ** + 2** - If the foreground is vertically cyclical. ** + 4** - If the background is horizontally cyclical. ** + 8** - If the background is vertically cyclical. This means that 0 if none of the two planes must be cyclical, 15 ( 1 + 2 + 4 + 8 ) if both planes must be cyclical in both axes, 12 ( 4 + 8 ) if only the background must be cyclical, etc. When a (foreground or background) graphic is smaller than the display window, the system will force it to have a cyclical scroll plane. Otherwise, the scroll window could not be completely filled, without cyclically repeating the graphic (tile). Besides the call to the function, some values of the scroll global structure must be initialised for the correct working of the window . This is a structure of 10 records (one for each possible scroll window) and every record has the following fields: x0, y0 - Foreground coordinates x1, y1 - Background coordinates z - Depth plane camera - identifying code of the camera ratio - Background's relative speed speed - Foreground's maximum speed region1 - First screen region region2 - Second screen region There are two ways to program the movement of the scroll windows: Manually, modifying in each frame of the game the fields x0 , y0 , x1 and y1 of this structure (the scroll planes' coordinates). Automatically, for what the identifying code of a process is needed in the field camera of this structure. From then, the system will be in charge of following the graphic of this process in the scroll window. See the help about the scroll structure either for further information about these fields, or to know how to access them. Example of AUTOMATIC scroll: PROGRAM example_start_scroll; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); scroll.camera=id; ctype=c_scroll; graph=100; write(0, 160, 0, 1, \"Use the cursors to move the ball\"); LOOP IF (key(_right)) x+=2; END IF (key(_left)) x-=2; END IF (key(_down)) y+=2; END IF (key(_up)) y-=2; END FRAME; END END - In the example, the graphics file is loaded and then, a scroll window is created with the start_scroll() function. The latter is passed the following parameters: 0 - Number of scroll window (the first one, as only a window of this kind will be created). file1 - Code of the file from which the graphics must be taken. This is the code of the file help.fpg loaded with the load_fpg() function. 103 - Code of the main graphic (foreground) of the scroll. In order to see this graphic, the file must be loaded with the Files menu , being then possible to observe which is the graphic with code 103 . 102 - Code of the secondary graphic (background). This graphic will be shown in the scroll window behind the main graphic. 0 - Number of the screen's region in which the scroll must be placed . 0 indicates that it must be put on the entire screen. 15 - Lock indicator; 15 (1+2+4+8) indicates that the foreground as well as the background will be cyclical in both axes (horizontal and vertical). After having called the start_scroll() function, the program defines the field camera of the scroll structure , assigning the identifying code of the main process to it (with the scroll.camera= id ; statement). Thus, the scroll becomes automatic , following the graphic of the main process from that moment. The program continues to define its type of coordinate as a scroll coordinate (with the ctype=c_scroll; statement), defining its graphic as number 100, that is a brown ball (with graph=100; ), and displaying a message. Then, it will stay in a loop in which the coordinates of this process (the x and y variables) may vary with the cursor keys. Example of scroll MANUAL: PROGRAM example_start_scroll; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); start_scroll(0, file1, 103, 102, 0, 15); write(0, 160, 0, 1, \"Use the cursors to move the scroll\"); LOOP IF (key(_right)) scroll.x0+=2; scroll.x1+=1; END IF (key(_left)) scroll.x0-=2; scroll.x1-=1; END IF (key(_down)) scroll.y0+=2; scroll.y1+=1; END IF (key(_up)) scroll.y0-=2; scroll.y1-=1; END FRAME; END END - In the example the file of graphics is loaded and then a scroll window is created with the function start_scroll() . The same parameters of the previous example are given to this last one. After this, the program will stay in a loop inside of which, when the cursor keys are detected, the fields x0 , y0 , x1 and y1 of the global scroll structure will change, and these define the coordinates of the two scroll planes ( x0 , y0 for the first plane and x1 , y1 for the second). It can be seen the difference between both methods; this last one, as it hasn't beginning the field camera of the structure, will be able to manipulate the coordinates of both planes. --- How to visualise the process graphics in the scroll --- To create a process which graphic is seen in the scroll window, its local variable ctype must be defined as c_scroll ( coordinate of type as coordinate of scroll ), what will be done with the following statement: ctype=c_scroll; Once this is done, the process will be seen in the scroll with its graphic (defined in the local variable graph ). The process just must modify its variables x and y to move over the scroll. In the example, the graphics file is loaded and then, a scroll window is created with the start_scroll() window. The latter is passed exactly the same parameters as in the previous example. After that, the program will stay inside a loop in which, on detecting the cursor keys, the fields x0 , y0 , x1 and y1 of the scroll global structure will vary. These fields define the coordinates of the two planes of the scroll ( x0 , y0 are the coordinates of the foreground and x1 , y1 those of the background). The difference between both methods can be noticed. The latter can directly manipulate the coordinates of both planes, as it has not initialised the field camera of the structure. --- How to display processes' graphics in the scroll. --- In order to create a process whose graphic is displayed in the scroll window, it is necessary to define its ctype local variable as c_scroll ( type of coordinate as scroll coordinate ), which will be done with the following statement: ctype=c_scroll; After that, the process will be displayed in the scroll with its graphic (defined in the graph local variable). The process must modified only its x and y variables to scroll. {When a process belongs to the scroll (assigning the value c_scroll to its local variable} ctype ): Its x and y variables will be referred to the point of the foreground's graphic on which the graphic of the process will be placed. Its z variable will be now referred to the variables z of the processes that also belong to the same scroll window. This means that each time that a scroll window is displayed, all the graphics that belong to it (ranged by their z ) will be displayed just after it. Then, the processes that don't belong to that scroll window will continue to be displayed. The process will be automatically eliminated when the scroll window to which the process belongs is eliminated with the stop_scroll() function. Or when the videomode is changed with the set_mode() function as, on doing so, the scroll windows will be also eliminated. If there were several scroll windows, the process would be displayed by default in all of them. If it had to be displayed only in some of them, its cnumber local variable should be defined. For instance, if there were 6 scroll windows (numbered from 0 to 5) and the aim was to display a process only in windows 0 and 2, the following statement should be included in it: cnumber=c_0+c_2; In order to observe an example of what it has been said, the best thing is to examine some of the sample games of DIV Games Studio that use this technique. Thus, the reader is directly referred to the comments of these programs (for instance, see the example Helioball ). ---See: stop_scroll() - refresh_scroll() - move_scroll() - Scroll structure","title":"start_scroll()"},{"location":"help/#stop_cd","text":"stop_cd() Description: Stops the CD-Audio reproduction, stopping the song which were playing. The songs are reproduced with the function play_cd() . Example program: PROGRAM example_stop_cd; BEGIN write(0, 160, 0, 1, \"Press [ENTER] to turn on the CD.\"); write(0, 160, 10, 1, \"Press [SPACE] to stop the CD.\"); LOOP IF (scan_code==_space) stop_cd(); // Para el CD END IF (scan_code==_enter) play_cd(2, 0); END FRAME; END END - In the example are placed the necessary messages. In each step of the loop, if the space bar is pressed, the CD will be stopped with the function stop_cd() . If the ENTER key is pressed, it will be turned on with the function play_cd() . The volume of reproduction of cd-audio can be controlled with the setup structure and the function set_volume() . ---See: play_cd() - is_play_cd() - set_volume() - setup structure","title":"stop_cd()"},{"location":"help/#stop_mode7","text":"stop_mode7( ) Description: Eliminates the mode 7 window which number (from 0 to 9) is given as parameter. This is the one indicated as first parameter in the function start_mode7() , is necessary due to that can be up to 10 different mode 7 windows, and the system needs to know which of them is ending. When a mode 7 window is eliminated, every process which belongs exclusively to this window will die automatically, so, every process which has its variable ctype with the value c_m7 and they are not being seen in any other mode 7 window. Important: When the video mode is changed with the function set_mode() every mode 7 window (and its processes) will be eliminated, without being in this case, necessary to use this function ( stop_mode7() ). Example program: PROGRAM example_stop_mode7; BEGIN load_fpg(\"help/help.fpg\"); write(0, 160, 0, 1, \"Press [ENTER] to start the mode 7 display.\"); write(0, 160, 10, 1, \"Press [SPACE] to stop the mode 7 display.\"); write(0, 160, 190, 1, \"Use the mouse to move the mode 7 display.\"); angle=90000; LOOP IF (scan_code==_space) stop_mode7(0); // The mode 7 is stopped END IF (scan_code==_enter) start_mode7(0, 0, 4, 0, 0, 64); m7.camera=id; END x=mouse.x; y=mouse.y; FRAME; END END - In the example a file of graphics is loaded, and the instructions of the program appear on screen, after this, the coordinates of the main process, which will be the camera of the mode 7, will be controlled with the mouse (through the statements x=mouse.x; and y=mouse.y ). When the ENTER key is pressed, a mode 7 window is created with a graphic of a circle, controlled by the main process. When the space bar is pressed, the function stop_mode7() will be called, eliminating this window of the mode 7 visualisation. To Create a mode 7 window is a bit complex procedure and requires to begin some parameters, as in this case the camera, some of them required by the function start_mode7() and other variables in the global structure m7 (as the variable m7.camera used in the example). ---See: start_mode7() - m7 structure","title":"stop_mode7()"},{"location":"help/#stop_scroll","text":"stop_scroll( ) Description: Eliminates the scroll window which number (from 0 to 9) is given as parameter. This is the one indicated as first parameter in the function start_scroll() and it is necessary due to can be up to 10 different scroll windows, and the system needs to know which one is ending. When a scroll window is eliminated, every process which belongs exclusively to this window will die automatically, so, every process which has its variable ctype with the value c_scroll and they are not being seen in any other scroll window. Important: When the video mode is changed with the function set_mode() every scroll window (and its processes) will be eliminated, without being in this case, necessary to use this function ( stop_scroll() ). Example program: PROGRAM example_stop_scroll; BEGIN load_fpg(\"help/help.fpg\"); write(0, 160, 0, 1, \"Press [ENTER] to activate the scroll window.\"); write(0, 160, 10, 1, \"Press [SPACE] to end the scroll.\"); LOOP IF (scan_code==_space) stop_scroll(0); // The scroll is quit. END IF (scan_code==_enter) start_scroll(0, 0, 103, 102, 0, 15); END scroll.x0+=1; scroll.y0+=1; scroll.x1-=1; FRAME; END END - In the example a file of graphics is loaded and the instructions of the program appear on screen. When the ENTER key is pressed, a scroll window will be created and when the space bar is pressed, the function stop_scroll() is called, eliminating this scroll window. Inside of the main loop, the coordinates of the scroll are accessed, being contained in the global scroll structure to move manually the scroll window ( scroll.x0+=1; ... ). To create a scroll window is a bit complex procedure and requires to start some parameters, some of them, required by the function start_scroll() and other contained in the global scroll structure (as the variable scroll.x0 used in the example). ---See: start_scroll() - scroll structure","title":"stop_scroll()"},{"location":"help/#stop_sound","text":"stop_sound( ) Description: Stops the sound that is being played through the channel, passed as a parameter. The required is the value returned by the sound() function when the reproduction of a sound effect starts. There are 16 sound channels. Thus, up to 16 sounds may simultaneously be played. Example program: PROGRAM example_stop_sound; PRIVATE id_sound; channels; playing=FALSE; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); write(0, 160, 0, 1, \"Press [SPACE] to start the reproduction.\"); write(0, 160, 10, 1, \"Press [ENTER] to stop the sound channel.\"); id_sound = load_pcm(\"help/help.pcm\", 1); LOOP IF (scan_code==_space AND NOT playing) channels = sound(id_sound, 128, 256); playing=TRUE; END IF (scan_code==_enter) stop_sound(channels); // The sounds stops playing playing=FALSE; END FRAME; END END - In the example, a background graphic is put and the necessary messages are displayed. At the same time, the sound effect stored in the help.pcm file is loaded with the load_pcm() function, that returns the sound identifier that is stored in the id_sound variable. Notice that, in this example, 1 is passed to this function as a second parameter. That is done to indicate that the loaded sound effect must indefinitely be repeated every time it is initialised (stressing thus the effect of the stop_sound() function). In every step of the loop, it is checked whether the spacebar is pressed. In this case, the reproduction of the sound effect will start with the sound() function, which will return the channel number that will be stored in the channel variable. If the ENTER key is pressed, the sound will be stopped with the stop_sound() function. To gradually stop a sound, turning its volume down little by little, several calls to the change_sound() function must be made to slightly reduce the channel volume until it reaches level 0. Then, the stop_sound() can be called to definitively stop the sound. ---See: sound() - change_sound() - load_pcm/wav() - unload_pcm/wav()","title":"stop_sound()"},{"location":"help/#system","text":"system( <\"external command\"> ) Description: Executes the operative system's command passed as a parameter. Example program: PROGRAM example_system; BEGIN write(0, 160, 0, 1, \"Press [SPACE] to execute a DIR.\"); LOOP IF (scan_code==_space) system(\"dir\"); // A command of MS-DOS is executed. END FRAME; END END - In the example, after the display of a text, you enter inside the main loop in which the DIR command of the MS-DOS operative system will be executed every time the spacebar is pressed. One of the utilities of this command is, for instance, to delete a temporary file that has been created in the program, calling the command of the system DEL < file name > . Note: The system can be blocked depending of the executed commands. In these cases you must reset the computer. There is no guarantee dealing with this function running, due to the multiple incompatibilities that can appear between the external commands and the manager of internal processes of DIV Games Studio. system(\"COMMAND.COM\") Description: Executes a session of the MS-DOS operative system from the program itself. On typing EXIT from it, you will return to the program at the point in which this statement was executed. ---See: exit()","title":"system()"},{"location":"help/#unload_fpg","text":"unload_fpg( ) Description: Unloads the graphics file whose code is passed as parameter from the memory. This is the value returned by the load_fpg() function when a new graphics file is loaded in the memory. After having unloaded a graphics' file, much care must be taken not to go on using in the program any graphic that was in that file. Otherwise, the program could become blocked. It is not necessary to unload the file from the memory before finishing the program, as the system will do it automatically. Therefore, a file must be unloaded from the memory only when it is not going to be used for a while and when the aim is to free up space occupied in the computer's memory in order to load other resources (other graphics files, sounds, fonts, etc.). Example program: PROGRAM example_unload_fpg; PRIVATE file1; BEGIN file1=load_fpg(\"help/help.fpg\"); put_screen(file1, 1); write(0, 160, 0, 1, \"Press [ENTER] to unload the file and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_fpg(file1); // The file is loaded. END - The example loads the graphics file contained in the help.fpg file with the load_fpg() function, storing the file code in the file1 private variable. The program will remain in a loop until the ENTER key is pressed. At that moment, the file will be unloaded from the memory with unload_fpg() and the program will finish. The graphics individually loaded with the load_map() or load_pcx() (or created with new_map() ) functions will not be unloaded when file number 0 (with code 0) is loaded , even if they were used as if they belonged to it. These graphics will have to be unloaded by using the unload_map() or unload_pcx() functions. ---See: load_fpg() - load_map/pcx() - unload_map/pcx ()","title":"unload_fpg()"},{"location":"help/#unload_pcm-unload_wav","text":"unload_pcm( ) unload_wav( ) Description: Unloads the sound whose code is passed as a parameter from the memory. This is the value returned by the load_pcm() or load_wav() function when a new sound effect is loaded in the memory. After having unloaded a sound effect, much care must be taken not to go on using in the program this effect (its code) for the sound() or unload_pcm() functions. Otherwise, the program could become blocked. It is not necessary to unload the sound from the memory before finishing the program, as the system will do it automatically. Therefore, a sound must be unloaded from the memory only when it is not going to be used for a while and when the aim is to free up space occupied in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.), which will be logical just with sound effects of a certain length, in other words big enough so as to be worth freeing up the space they occupy. Example program: PROGRAM example_unload_pcm; PRIVATE sound1; BEGIN sound1=load_pcm(\"help/help.pcm\",0); write(0, 160, 0, 1, \"Press [ENTER] to unload the sound and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_pcm(sound1); // The sound is unloaded. END - The example loads the sound effect stored in the help.pcm file with the load_pcm() function, storing the sound code in the sound1 private variable. The program will remain in a loop until the ENTER key is pressed. At that moment, the file will be unloaded from the memory with unload_pcm() and the program will finish. The stop_sound() function must be used to stop a sound effect, but keeping it in the memory in order to be played again when desired. ---See: load_pcm/wav() - sound() - change_sound() - stop_sound()","title":"unload_pcm() / unload_wav()"},{"location":"help/#write","text":"write( , , , , ) Returns: The identifying code of the text that has been written. Description: This function is used to show an alphanumeric text on-screen. For that, it requires the following parameters: - The font code or type of letter that is going to be used. Here, you must put either 0 when the aim is to use the system's font (white, small font, 6 by 8 pixels), or the font code returned by the load_fnt() function when a new font is loaded in the program. , - The coordinates referred to the screen in which the text is going to be displayed, first in the horizontal axis and then in the vertical one. - This code determines the position of the text specified by the previous coordinates. Its values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right For example, if a text is written at the 160, 0 coordinates and with the centreing code 1 (Up), then the text will c entre in the column 160 and it will be displayed from line 0 downwards. Or, if the aim is to have a text in the upper left corner, it must be displayed at the 0, 0 coordinates and with centreing code 0 (Up left). - The text to be written as a literal (a text in inverted commas) will be specified as last parameter (see the literals' specifying symbols ). The displayed text will remain on-screen until it is deleted with the delete_text() function, that requires as parameter the identifying code returned by write() . The write_int() function must be used to display the numeric value of a variable (such as the score of the player). The texts will remain unchangeable on screen even if graphics are displayed on it or processes' graphics pass before or behind them. Example program: PROGRAM example_write; PRIVATE font1; BEGIN font1 = load_fnt(\"help/help.fnt\"); write(0, 160, 100, 4, \"Sample text with the system font.\"); write(font1, 0, 0, 0, \"LEFT UP\"); write(font1, 320, 200, 8, \"RIGHT DOWN\"); LOOP FRAME; END END - In the previous example, the font contained in the help.fnt file is loaded with the load_fnt() function (whose font code is stored in the font1 variable), and then three texts are written: The first one with the system font (0), being placed at the 160, 100 coordinates (screen centre) the centre of the text (centreing code 4). The second one with the loaded font (whose font identifier is stored in the font1 variable), being placed at the 0, 0 coordinates the upper left corner of the text (centreing code 0). And finally, the third text, also with the loaded font, being placed at the 320, 200 coordinates the lower right corner of the text (centreing code 8). After that, the program will indefinitely remain expecting inside a loop. The depth plane in which the written texts appear is controlled through the text_z global variable, that is useful to regulate which graphics must be seen above the texts and which ones must be seen below them. Then, it will be possible to move the texts towards another position if necessary, by using the move_text() function, which also requires the identifying code returned by write() as parameter. When fonts loaded from files FNT are used, the colours palette used to generate these fonts must be activated (see load_pal() ). Otherwise, the colours may appear changed, and the text will be incorrectly displayed. ---See: write_int() - move_text() - delete_text() - load_fnt() - text_z","title":"write()"},{"location":"help/#write_int","text":"write_int( , , , , ) Returns: The identifying code of the text that has been written. Description: This function is used to show the numeric value of a variable. For that, it requires the following parameters: - The font code or type of letter that is going to be used. Here, it is necessary to put either 0 when the aim is to use the system's font (white, small font, 6 by 8 pixels), or the font code returned by the load_fnt() function when a new font is loaded in the program. , - The coordinates referred to the screen in which the numeric value is going to be displayed, first in the horizontal axis and then in the vertical one. - This code determines the position of the numeric value specified by the previous coordinates. Its values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right For example, if a numeric value is written at the 160, 0 coordinates and with the centreing code 1 (Up), then the numeric value will be centred in the column 160 and it will be displayed from line 0 downwards. Or, if the aim is to have a numeric value in the upper left corner, it must be displayed at the 0, 0 coordinates and with centreing code 0 (Up left). - The offset inside the computer's memory of the variable whose value is intended to be displayed, must be specified as last parameter (the offset of the data is obtained with the OFFSET operator). The displayed numeric value will remain on-screen until it is deleted with the delete_text() function, that requires as parameter the identifying code returned by write_int() . Important: During the time that the value of the variable appears on screen, this value will automatically be updated every time the variable is modified. For that, new calls to write_int() are not necessary. The write() function must be used to display any kind of alphanumeric text (a fixed text). The texts will remain unchangeable on screen even if graphics are displayed on it or processes graphics pass before or behind them. Example program: PROGRAM example_write_int; PRIVATE variable; BEGIN write(0, 160, 190, 1, \"Press [SPACE] to change the value of the variable.\"); write_int(0, 160, 100, 4, OFFSET variable); // A variable is displayed. LOOP IF (scan_code==_space) variable=rand(-100, 100); END FRAME; END END - In the example, a text is displayed by using write() and the value of a variable with the write_int() function. This last function is passed the following parameters: 0 - As font (0 is the system font). 0, 10 - As screen coordinates. 0 - As centreing code (Up/Left). OFFSET variable - As the offset of the variable in the memory. In every step of the loop, if the spacebar is pressed, the value of the variable is changed, assigning it one randomly chosen with the rand() function. The depth plane in which the written texts appear is controlled through the text_z global variable, that is useful to regulate which graphics must be seen above the texts and which ones must be seen below them. Then, it will be possible to move the texts towards another position if necessary, by using the move_text() function, which also requires the identifying code returned by write() as parameter. When fonts loaded from files FNT are used, the colour palette used to generate these fonts must be activated (see load_pal() ). Otherwise, the colours may appear changed, being the text incorrectly displayed. Warning: It is not possible to display an expression, as it is shown below: write_int(0, 0, 0, 0, offset variable + 1); To display the value of the variable plus 1. That is to say, if the aim was to display this value, it would be necessary either to add 1 to the variable or to create another variable, assigning it the value of the original variable plus 1, for instance: variable2 = variable + 1; write_int(0, 0, 0, 0, offset variable2); In this case, you should take into account that you had to update the value of the variable2 at least once per every FRAME of the game, as by changing variable the value of variable2 will not automatically be updated unless the variable2 = variable + 1; statement is again executed. ---See: write() - move_text() - delete_text() - load_fnt() - text_z","title":"write_int()"},{"location":"help/#xput","text":"xput( , , , , , , , ) Description: Advanced version of the put() function to put a graphic on the screen background. This function requires the following parameters, in order: - file code with the graphics library that contains both graphics. The graphics loaded with the load_map() or load_pcx() (or created with new_map() ) functions will be used as if they belonged to the first file (the file with the code 0). - code of the graphic inside the file that is going to be displayed on screen. , - coordinates dealing with the screen where the graphic is intended to be put. These coordinates reveal the position in which the graphic centre (or the control point number 0, if it is defined) will be placed. - angle (in degree thousandths) in which the graphic is going to be displayed; the normal angle is 0 . - size (in percentage) in which the graphic is going to be displayed; the normal size is 100 . - Indicates the mirrors and transparencies with which the graphic will be displayed; the possible values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical (180\u00b0) mirror. 4 -Transparent graphic. 5 -Horizontal transparent and mirror. 6 -Vertical transparent and mirror. 7 -Horizontal and vertical transparent, mirror. - Number of region (window inside the screen) in which the graphic must be displayed. This value will normally equal 0 to display the graphic at any position of the screen. The define_region() function must be used to define a region. The graphics displayed in this way on the background screen will be in the game display below all the processes, scroll regions, texts, etc. If the aim is that a graphic is above others, it is necessary to create it as a new process and fix its z variable with the priority of its display. The clear_screen() function must be used to clear the screen background. Example program: PROGRAM example_put; PRIVATE file1; coord_x; coord_y; angle1; size1; flags1; BEGIN file1=load_fpg(\"help/help.fpg\"); LOOP coord_x=rand(0, 319); coord_y=rand(0, 199); angle1=rand(-pi, pi); size1=rand(10, 200); flags1=rand(0, 7); // The graphic 101 is put xput(file1, 101, coord_x, coord_y, angle1, size1, flags1, 0); FRAME; END END - In the example, the file is loaded with the graphics and, in every iteration of the loop, graphic number 101 (a triangle) is put with the xput() function at coordinates randomly chosen with the rand() function, with random angle, size and value of flags , and in region number 0 (entire screen). The put() function is a simplified version of the xput() function, and it is useful when you do not want to rotate, scale, mirror or display the graphic with transparencies. The map_put() or map_xput() functions must be used to put a graphic inside another one (instead of the screen background). If the graphic intended to be put is just a screen background, it is easier to use the put_screen() function, as it does not require the screen coordinates because it will automatically centre the graphic on screen. ---See: put() - map_put() - map_xput() - put_screen()","title":"xput()"},{"location":"help/#load_map-load_pcx","text":"load_map( ) load_pcx( ) Returns: The loaded graphic code . Description: Loads a MAP or PCX file with a graphic in the computer's memory . The function requires the file name as a parameter, in inverted commas. The graphic code is returned as return value, which is a numeric value that must be specified to use the graphic, in the graph variable or, in general, in all the functions requiring a graphic code among their parameters. It is possible to load as many graphics as necessary. Every time one is loaded, the function will return the corresponding code (the first graphic loaded will have the code 1000 , the following one the code 1001 , etc.) It is possible to specify the path to the file with the graphics' file. Nevertheless, if the file is in the directory by default (\\MAP or \\PCX), it won't be necessary. Important: When the file code to which that graphic belongs is required inside a function, the code 0 (which is the code of the first file FPG that is loaded in the program) must be indicated. When different graphics have been loaded, keep in mind that if they have different palettes, every one of them must previously be activated with the load_pal() function, indicating the name of the file (MAP / PCX) as a parameter, before using the graphic. Graphics created with different palettes can not simultaneously be used. Example program: PROGRAM example_load_map; PRIVATE map1; BEGIN map1 = load_map(\"help/help.map\"); // A graphic map's file is loaded. put_screen(0, map1); LOOP FRAME; END END - In the example, a graphic map is loaded with the load_map() function, storing the graphic code that returns in the map1 private variable. This code is later used as a parameter of the put_screen() function to put the graphic on the background screen. The unload_map() and unload_pcx() functions allows us to free up the computer's memory used by the graphic when it is not going to be used for a specific time. For that purpose, it also requires the graphic code to know which is the graphic to be unloaded from the memory. It is not necessary to unload the graphic from the memory before finishing the program, as the system will do it automatically. To load several graphics all at once in a program, they must be included inside a graphics file (FPG) and loaded with the load_fpg() function. The function new_map() allows you to create a new graphic map of any size and colour, without loading it from an file. ---See: new_map() - unload_map/pcx() - load_fpg() - load_pal() - graph","title":"load_map() / load_pcx()"},{"location":"help/#reset_sound","text":"reset_sound( ) Description: Advanced function, only for very expert users. Resets the sound system. This function is used to activate new parameters of the sound hardware. The following values of the setup global structure must be established: setup.card setup.port setup.irq setup.dma setup.dma2 This function is normally used inside the sound setup programs (see setup_program ). To activate the rest of the values of the setup structure, those referred to the mixer volume, the set_volume() function must be called. The values to establish the volume are the following ones: setup.master setup.sound_fx setup.cd_audio ---See: set_volume() - Setup structure - setup_program","title":"reset_sound()"},{"location":"help/#unload_map-unload_pcx","text":"unload_map( ) unload_pcx( ) Description: Unloads the graphic whose code is passed as a parameter from the memory. This is the value returned by the load_map() load_pcx() or new_map() function by loading a new graphic stored in an file MAP or PCX in the computer's memory. After having unloaded a graphic, much care must be taken not to go on using this graphic in the program. Otherwise, the program would risk to become blocked. It is not necessary to unload the graphic before finishing the program, as the system will do it automatically. Then, a graphic must be unloaded from the memory only when it is not going to be used for a specific time and when the aim is to free up the occupied space in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.), which will make sense only with graphics of a certain size, big enough so as to be worth freeing up the space they occupy. Example program: PROGRAM example_unload_map; PRIVATE map1; BEGIN map1=load_map(\"help/help.map\"); put_screen(0, map1); write(0, 160, 0, 1, \"Press [ENTER] to unload the graphic and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_map(map1); // The graphic is unloaded. END - In the example, a graphic map is loaded with the load_map() function, storing the graphic code returned by it in the map1 private variable. This code is later used as a parameter of the put_screen() function to put the graphic on the background screen. Then, the program will display a message and wait in a loop for the ENTER key to be pressed. At that moment, the graphic will be unloaded by using the unload_map() function. The graphics individually loaded with the load_map() or load_pcx() (or created with the new_map() ) functions will not be unloaded when file number 0 (with code 0) is unloaded with the unload_fpg() function, even if these graphics are used as if they belonged to it. ---See: load_map/pcx() - unload_fpg()","title":"unload_map() / unload_pcx()"},{"location":"help/#unload_fnt","text":"unload_fnt( ) Description: Unloads from the memory the font (the kind of letter or the set of graphic characters ) whose code is passed as a parameter. This is the value returned by the load_fnt() function by loading a new letter font stored in a file FNT in the computer's memory. After having unloaded a font, much care must be taken not to go on using this font in the program. Otherwise, the program could crash. It is not necessary to unload the font before finishing the program, as the system will do it automatically. Then, a font must be unloaded from the memory only when it is not going to be used for a specific time and when the aim is to free up the occupied space in the computer's memory to load other resources (other graphics files, sounds, fonts, etc.). Example program: PROGRAM example_unload_fnt; PRIVATE font1; BEGIN font1=load_fnt(\"help/help.fnt\"); write(font1, 160, 0, 1, \"FONT LOADED FROM DISK\"); write(0, 160, 190, 1, \"Press [ENTER] to unload the font and finish\"); REPEAT FRAME; UNTIL (key(_enter)); unload_fnt(font1); // The font is unloaded END - In the example, the font stored in the help.fnt file is loaded with the load_fnt() function, storing the font code returned by it in the font1 private variable. This code is later used as a parameter of the write() function to put a text on screen with that font. Then, the program will wait in a loop for the ENTER key to be pressed. At that moment the font will be unloaded by using the unload_fnt() function and the program will finish. Font number 0, (the system font having 0 as font code), can not be unloaded . ---See: load_fnt() - write() - write_int()","title":"unload_fnt()"},{"location":"help/#set_volume","text":"set_volume( ) Description: Advanced function, only for very experienced users. Adjusts the different volume controls managed by the mixer of the system sound. To adjust the volume, the following values of the setup global structure must be set: setup.master - General volume setup.sound_fx - Sound effects volume setup.cd_audio - CC-audio music volume This function is normally used inside the sound setup programs (see setup_program ), or even in the rest of the programs, normally to adjust the CD_Audio music volume. To activate the rest of the values of the setup structure (those referring to the sound card's parameters) the reset_sound() function must be called with the following defined values of the structure: setup.card setup.port setup.irq setup.dma setup.dma2 ---See: reset_sound() - Setup structure - setup_program","title":"set_volume()"},{"location":"help/#set_color","text":"set_volume( , , , ) Description: Redefines a colour of the palette. This function is used to modify the components of a colour of the game palette. You must be very cautious with it, because all the graphics on the screen that use this colour will be affected, to modify the colours of just one graphic use the function convert_palette() . The must be a number between 0 and 255 . The components of the colour will be specified as a number between 0 (minimum) and 63 (maximum). - red Component of the colour. - green Component of the colour. - blue Component of the colour. Now a program is shown which modifies randomly the colours of the palette. Example program: PROGRAM example_set_colour; GLOBAL colour,r,g,b; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 2); LOOP colour=rand(1,255); r=rand(0,63); g=rand(0,63); b=rand(0,63); set_color(colour, r, g, b); // A colour of the palette is redefined. FRAME; END END - In the example a multicolour screen is placed as background and inside of the program main loop, the component colours of the palette are modified randomly when the space bar is pressed. To obtain random numbers use the function rand() . To modify the entire palette, it is better to load a wholly different file palette with the function load_pal() . To realise other palette effects, the function roll_palette() can be used, which allows you to make loops of changing colours, or the function fade() which allows you to realise multiple fades and saturations of colour at different speeds. ---See: roll_palette() - load_pal() - fade() - fade_off() - fade_on()","title":"set_color()"},{"location":"help/#net_join_game","text":"net_join_game( , , ) Returns: Number of players in the game (0, 1, 2, ...). If there is an error, a negative number is returned, which is the error code: ** -1** : Connection aborted by the user. ** -2** : Can't start the connection. ** -3** : The number of players doesn't fit. ** -4** : There were errors of synchronisation. Description: The net functions are of an extremely advanced level, so could be difficult to understand for users with not enough experience in programming. First the predefined global structure net must be initialised with the parameters that define the type of connection which is going to be established. Then, a call to the function net_join_game() will be enough to create a new game or to join a game (if it is already created). The name of the game (a literal, as \"MyGame\" ), is used to differentiate a game from other games running at the same time on one local net. From that moment, every computer connected to the game will send and receive data from the others automatically, through the net structure, indicated by the parameters. The structure of data. This must be a global structure of the program with as many registers as players that are connected at the same time. In the fields of the structure the sent data can be read and written to; each player must input their values in their own register. The number which corresponds to the total number of players is returned by this function. The system will automatically send their register values to the other players, and the registers of the others players to them. The predefined structure net In this structure are established the parameters which define the type of connection. The fields of this structure are : net.device - Type of Connection Port (1-IPX, 2-Serial link or 3-Modem). net.com - N\u2551 of COM Port, from 1 to 4 (just for serial and modem). net.speed - Connection Speed (in bauds), up to 115000 (just for serial and modem). net.number - Telephone number (just modem), for example net.number=\"913040622\"; . net.init - Initialising string of the modem, for example net.init=\"ATZ\"; . net.mode - 0 or 1 depending on whether the signals are pulses or tones (only for modem). net.server - Indicates if it is the server (just reading, can't be modified). net.max_players - Maximum number of players, from 2 to 16 (it must be the same as the number of registers to the global structure). net.num_players - Current number of players, from 1 to 16 (players can connect and disconnect at any moment). When the connection is made by a serial link or modem, you may only connect 2 players . It's important that the register number of the structure used for the data transfer has as many registers as that indicated in net.max_players . For example, if a game is created and the maximum number of players is 8, and the information which must be given to the players is just their coordinates (x,y), then it could be done as is shown in the following program (supposing a IPX connection for a local net). Example program: PROGRAM example_net_join_game; GLOBAL STRUCT player[7] // 8 players as maximum (from 0 to 7). x,y; END id_red; BEGIN net.device=1; net.max_players=8; // Here, the number of registers is indicated. // ... id_red=net_join_game(\"xxx\",OFFSET player, sizeof(player)); IF (id_red<0) // An error has been produced ... END // The register of this player is \"player[id_red]\" player[id_red].x=x; // I Define my fields player[id_red].y=y; FRAME; // Sending / Reception of data // Now there are connected \"net.num_players\", and their data has also been passed to // the other registers of the structure player[]. // ... END - Note: Further information can be found about how to structure a game over the internet in the user's manual of DIV Games Studio. ---See: net_get_games() - STRUCT net","title":"net_join_game()"},{"location":"help/#net_get_games","text":"net_get_games() Returns: Activated games of this game currently running. Description: returns the number of live games currently being played of a particular game (to connections over local net). This function is used to see if there is any live game at a determined moment. To establish a connection, the function net_join_game() is used, to create a game or to connect to them. Example program: PROGRAM example_net_get_games; GLOBAL n; // Active games. BEGIN net.device=1; // set device to local LAN // ... n=net_get_games(); IF (n>0) // ... END //... END - Just is useful to IPX connections, it has no meaning in serial link or modem connections (because in these cases there can be just one game). ---See: net_join_game() - ,STRUCT net","title":"net_get_games()"},{"location":"help/#stop_mode8","text":"stop_mode8( ) Description: Eliminates the mode 8 window which number (from 0 to 9) is given as the parameter. This is the one indicated as the first parameter in the function start_mode8() , it is necessary to define the mode 8 window number as there can be up to 10 different mode 8 windows, and the system needs to know which of them is being terminated. Note: To create a mode 8 window is an advanced procedure and requires some parameters to be set, as in this case the camera, some of them required by the function start_mode8() and others are contained in the global m8 structure (such as the variable m8.camera ). Example program: PROGRAM example_stop_mode8; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); write(0,0,0,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); stop_mode8(0); // Eliminates the region number 0 of mode 8 END - This program shows an initiation example of a mode 8 region, loading the map contained in the file wld_view.prg , and starting a region (the number 0 ) with start_mode8() function. This program waits in a loop until it detects the ESC key has been pressed, at which point it leaves the loop and then eliminates this region with the stop_mode8(0) function. ---See: start_mode8() - 1411,STRUCT m8 - load_wld()","title":"stop_mode8()"},{"location":"help/#xadvance","text":"xadvance( , ) Description: Advances the process the indicated angle as many points as the indicated distance shows as parameter. This function is equivalent to the function advance() , if the angle is used as its first parameter. The distance can be a negative number too, so the graphic of the process will advance (its coordinates x and y ) in the opposite direction to this angle. Example program: PROGRAM example_xadvance; PRIVATE angle2; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=101; x=160; y=100; write(0, 0, 0, 0, \"Use the cursors to change the direction.\"); LOOP angle+=5000; IF (key(_right)) angle2-=10000; END IF (key(_left)) angle2+=10000; END xadvance(angle2,4); // We advance the process to points FRAME; END END - This example will draw a triangle on screen which will rotate in the selected direction chosen with the cursors, independent of the orientation of the graphic on the screen (of visible angle). The program advances 5 degrees per frame in the direction selected by the cursors. Remember that the angle is specified in thousandths of a degree. ---See: Use of the angles in the language - advance() - get_distx() - get_disty()","title":"xadvance()"},{"location":"help/#char","text":"char( ) Returns: The ASCII value of the (first) character contained in the literal parameter. Description: This function char() is used to obtain the ordinal value of a character. Example program: PROGRAM example_char; PRIVATE value; BEGIN // .. value=\"A\"; // The address of the literal \"A\" is assigned in memory. // .. value=char(\"A\"); // The ASCII value of \"A\" is assigned (65 in decimal). // .. END - In a program, the literals (texts between quotation marks) are translated as the memory address which they have been allocated. To assign to one variable a character (its ordinal value), instead of the address of the string, use this function. See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel()","title":"char()"},{"location":"help/#path_find","text":"path_find( , , , , , , , ) Returns: Number of route points, or 0 if it doesn't find any. Description: Finds a route from the current coordinates of the process to a determined point, dodging the defined obstacles in a searching map (in the user's manual, can be found information about these maps). The mode. Defines the type of route searching mode, depending on the indicated as first parameter of the function. 0 - Searching less precise and faster. 1 - Searching more precise, but slower. The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. The route points. Now must be indicated the coordinates and where the process must go (the origin is taken as the initial coordinates of the process which executes the function path_find() ). This function returns a group of structure points, which are the points that form the route from the origin to the destination point. To do this, a structure must be declared which contains two fields (x,y), and as many registers as points that comprise the calculated route. The two last parameters of the function contain, the address ( OFFSET ) of this structure and its size ( SIZEOF() ), so the coordinates contained in this structure can be passed back to the function as the results. Example program: PROGRAM example_path_find; GLOBAL num_points; STRUCT points[100] x,y; END index; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); graph=200; mouse.graph=200; LOOP // Obtains the route to the mouse's coordinates num_points=path_find(0,0,201,2,mouse.x,mouse.y,OFFSET points,sizeof(points)); // If a route was obtained, it shows the route and advances to the destination IF (num_points>0) FOR (index=0;index 4) xadvance(fget_angle(x,y,points[0].x,points[0].y),4); ELSE x=points[0].x; y=points[0].y; END draw(1,24,15,0,x,y,points[0].x,points[0].y); END FRAME; delete_draw(all_drawing); END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file as its searching map . The square size of the searching map is 2 The main process is continuously finding a route to the mouse cursor with the function path_find() . The different segments of this route are shown with lines using the function draw() , and the coordinates are incremented with the function xadvance() . To obtain the distance and the angle to the next point of the route the functions fget_dist() and fget_angle() are used. To see if it's possible to go directly in a straight line between two points (without passing through any obstacle) the function path_line() can be used. The function path_free() determines if a particular point of the map is an obstacle or if it is a free point (accessible). ---See: path_line() - path_free()","title":"path_find()"},{"location":"help/#path_line","text":"path_line( , , , , ) Returns: True (1) , if it is possible to go from one point to another without going through any obstacle, or false (0) if not. Description: It determines if, inside of a searching map, you can go in a straight line up to a point (starting from the current coordinates of the process), without passing through any obstacle of the searching map (in the user's handbook you can find information about these maps). In case of wanting to obtain a path between two points that dodges all the obstacles , use the function path_find() , and to see if the destination point is inside of an obstacle, use the function path_free() . The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. The route points. Now must be indicated the coordinates and where the process must go (the origin is taken as the initial coordinates of the process which executes the function path_find() ). Example program: PROGRAM example_path_line; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); graph=200; mouse.graph=200; LOOP // It checks if you can go in a straight line to the mouse IF (path_line(0,201,2,mouse.x,mouse.y)) IF (fget_dist(x,y,mouse.x,mouse.y)>4) xadvance(fget_angle(x,y,mouse.x,mouse.y),4); draw(1,24,15,0,x,y,mouse.x,mouse.y); ELSE x=mouse.x; y=mouse.y; END END FRAME; delete_draw(all_drawing); END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file is used as its searching map . The square size in the searching map is 2 . The main process is continuously checking if you can go in a straight line to the mouse coordinates with the function path_line() . If this is possible, a line is traced with the function draw() , and the process coordinates advance in this direction with the function xadvance() . To obtain the distance and the angle to the mouse cursor the functions fget_dist() and fget_angle() are used. ---See: path_find() - path_free()","title":"path_line()"},{"location":"help/#path_free","text":"path_free( , , , , ) Returns: True (1) , if the point in a searching map is free (is not an obstacle), or false (0) if not. Description: Determines if, inside of a searching map, the coordinates are placed in an accessible zone, not overlapping with any obstacle (in the user's manual can be found information about these searching maps). In case of wanting to obtain a route to dodge the obstacles between two points the function path_find() must be used, and to see if it can go to a point in a straight line without passing through any obstacle use the function path_line() . The searching map. The and codes, are related to the searching map. This is a simplified version of the real scenario, where the free zones appear as a black colour (the number 0 of the palette) and the obstacles appear as a white colour shape. The indicates the reduction factor of the searching map, how much the width and height of the map must be multiplied to be shown at real size. For example, if a searching map of 160x100 is generated for a 320x200 screen, the square size will be 2. Now the coordinates and to be referenced must be indicated . Example program: PROGRAM example_path_free; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 7); mouse.graph=200; mouse.size=400; LOOP // Checks if the mouse is in an accessible zone IF (path_free(0,201,2,mouse.x,mouse.y)) mouse.angle+=5000; END FRAME; END END - In this example the graphic number 7 of the file help.fpg is used as the scenario, and the graphic number 201 of the same file as its searching map . the square size of the searching map is 2 The main process is continuously checking, with the function path_free() , if the mouse cursor is in a free zone, or over an obstacle. When the cursor is in a free zone, out of any obstacle, the cursor graphic will rotate. ---See: path_find() - path_find()","title":"path_free()"},{"location":"help/#new_map","text":"new_map( , , , , ) Returns: The code of the graphic created. Description: Creates a new map in memory (without loading it from an file of the disk). To do this, the function requires the and (in pixels) of the map that must be created, a central point (of the same) in and , and the colour with which the map will be initially filled (the number of the colour inside of the active palette, from 0 to 255). This function acts similarly to the function load_map() , except that an file graphic from the disk is not loaded, and the graphic created is a solid graphic of just one colour. The value returned is the code of the graphic , which is a numeric value which must be specified to use the graphic, in the variable graph or, in general, in every function which requires a code of graphic in its parameters. Important: When, inside of a function, the code of file which belongs to the graphic is required , you must be indicate the code 0 (which is the code of the first file FPG that is loaded in the program). Example program: PROGRAM example_new_map; BEGIN // Is created a map of 16x32 points // with its centre in the point (0,0) // and with the colour 15 of the palette mouse.graph = new_map(16,32,0,0,15); // Is assigned as mouse cursor REPEAT FRAME; UNTIL (key(_esc)); unload_map(mouse.graph); // And finally the graphic is deleted END - In the example a map is created with the function new_map() and is saved as the code of the graphic which is returned in the variable mouse.graph , as the mouse cursor. Pressing the ESC key takes you out of the loop of the program and the graphic will be deleted with the function unload_map() (exactly the same as if it were loaded from an file). The function unload_map() frees up the computer memory used by the graphic when it is used no more, and due to that the code of the graphic is also required to know which graphic is the one that is to be deleted from memory. It is not necessary to delete the graphic from memory before exiting the program, because the system will do that automatically. ---See: load_map/pcx() - unload_map/pcx() - graph","title":"new_map()"},{"location":"help/#load_wld","text":"load_wld( , ) Description: It loads a mode 8 map in a program. These maps are saved in the files with the extension WLD, and are created with the map's 3D menu (in the user's manual can be found further information on how to construct these maps). The parameters required are the which contains the map in WLD format, and the code of the which contains the file's textures. This file with the textures of the map needs to be previously loaded in the program with the function load_fpg() . Once the map is loaded, a region of mode 8 screen must be initiated with the function start_mode8() . The functioning is quite similar to the mode 7 which shows a graphic in a folded plane (see start_mode7() ). Example program: PROGRAM example_load_wld; GLOBAL fpgfile; BEGIN set_mode(m640x480); set_fps(70,0); fpgfile = load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",file); // Loads a file WLD start_mode8(id,0,0); ctype=c_m8; height=64; radius=64; m8.height=32; go_to_flag(0); LOOP IF (key(_right)) angle-=5000; END IF (key(_left)) angle+=5000; END IF (key(_up)) advance(24); END IF (key(_down)) advance(-9); END IF (key(_q)) z+=16; END IF (key(_a)) z-=16; END IF (key(_w)) m8.angle+=8; END IF (key(_s)) m8.angle-=8; END FRAME; END END - This program shows an initiation example of a mode 8 region, loading the map contained in the file wld_view.prg , and whose texture is found in the file wld_view.fpg . ---See: start_mode8() - go_to_flag() - load_fpg()","title":"load_wld()"},{"location":"help/#start_mode8","text":"start_mode8( , , ) Description: This is an advanced function that requires the user to have a certain amount of experience to use it. It creates a window with a mode 8, which generates a three-dimensional map. First the map must be loaded with the load_wld() function and then, the following parameters of this function need defining. - Identifier code of the process in which the mode 8 camera will be placed, the camera will be placed at the coordinates (x,y) , at height (z) and looking in the indicated direction defined by (angle) (these are local data predefined for the process). - Up to 10 mode 8 windows can be created on screen, numbered from 0 to 9 ; if just one is created, then define this as number 0 . This number will be needed to modify the parameters of the window, because the system needs to know which one of the 10 possible mode 8 windows you wish to modify. - Here will be indicated the rectangular region of the screen where the mode 8 is going to be shown. If the number of the region indicated is 0 , it will be shown full screen. Other regions must be defined previously with the function define_region() (a region is just a rectangular zone of the screen). Note: The functioning is very similar to the mode 7 which shows a folded plane (see start_mode7() ). Apart from the call to the function, some values of the global m8 structure must be initiated for the window to function correctly . This is a structure of 10 registers (one for each possible mode 8 window) and each register has the following fields: camera - Identifier code of the camera height - Height of the camera in relation to the process angle - Vertical angle of the camera (-128,128) z - Plane of depth (priority of impression of the region) The field camera is essential ,as that is asked as one of the calling parameters of the function start_mode8() because, without this field, the window can't determine the viewpoint from which the map will be initially viewed. Example program: PROGRAM example_start_mode8; GLOBAL fpgfile; BEGIN set_mode(m640x480); set_fps(70,0); fpgfile = load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",file); start_mode8(id,0,0); // Starts a mode 8 region ctype=c_m8; height=64; radius=64; m8.height=32; go_to_flag(0); LOOP IF (key(_right)) angle-=5000; END IF (key(_left)) angle+=5000; END IF (key(_up)) advance(24); END IF (key(_down)) advance(-9); END IF (key(_q)) z+=16; END IF (key(_a)) z-=16; END IF (key(_w)) m8.angle+=8; END IF (key(_s)) m8.angle-=8; END FRAME; END END - This program shows an initiation example of a mode 8 region, loading the file wld_view.prg , and whose textures are found in the file wld_view.fpg . To create a process where a graphic is displayed in the mode 8 region, its local variable ctype must be defined as well as c_m8 ( type of coordinate as the coordinate of mode 8 ). When a process is in a mode 8 region its variables x and y will be related to the point inside of the map sector (WLD), and the variable z will indicate the height. If there are several mode 8 windows, the process will by default be seen in all of them, if the process is wanted to be seen in just some of them, the local variable cnumber must be defined. For a process to have many graphics (many views), depending on the angle from which it is going to be viewed, you must define the local variable of the graphic xgraph (instead of the variable graph ). Note: To eliminate a mode 8 region you must be use the function stop_mode8() , indicating the number of m8 . ---See: STRUCT m8 - load_wld() - go_to_flag() - stop_mode8()","title":"start_mode8()"},{"location":"help/#go_to_flag","text":"go_to_flag( ) Description: Places a process in a mode 8 region in a position indicated by a flag, the process calling the function is the one placed in that position, the only parameter needed is the , as a mode 8 region can have more than one predefined flag position. After the function has been called, in the next FRAME the process will be placed at the flag coordinates. The height of the flag will always be understood to be the minimum height of the sector where it is going to be found. The flags are placed in the editor of the three-dimensional maps, control of which is explained in the user's manual. Note: This function is equivalent to giving the process the coordinates a flag ( x , y , z ). Example program: PROGRAM example_go_to_flag; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); // Places the process camera at flag 0 LOOP FRAME; END END - This example program initialises a mode 8 region, loading the map contained in the wld_view.prg file using the load_wld() function, and starts a region with start_mode8() . Then, it places the process (which acts as the camera of the window) in the position indicated by the flag number 0 of the map sector. ---See: start_mode8() - STRUCT m8 - load_wld()","title":"go_to_flag()"},{"location":"help/#set_sector_height","text":"set_sector_height( , , ) Description: Modifies the height of the ground or ceiling of a mode 8 sector. The following parameters are required: - Number of sector of the map for which the height is wished to be modified. This number can be obtained from three-dimensional maps editor, as explained in the user's manual. - The new sector height of the ground must be indicated (a value from 0 to 4096), if ** -1** is indicated as the parameter, the current sector height of the ground will remain (useful to ascertain the height of the ground). - The new sector height of the ceiling must be indicated (a value from 0 to 4096), if ** -1** is indicated as the parameter, the current sector height of the ceiling will remain (useful to ascertain the height of the ceiling). To start a mode 8 region, the function start_mode8() must be called. Note: If the height of the ceiling is the same as the ground's height this sector won't be accessible (if this one is inside of another, it will appear as a column). The height of the ceiling must be smaller than the height of the ground. Example program: PROGRAM example_set_sector_height; GLOBAL sector=255; altitude; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=64; LOOP altitude=1000+get_distx(angle1,64); angle1+=5000; set_sector_height(sector,altitude,-1); FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , and places it at the predetermined coordinates with the function go_to_flag() . Then, inside of the program main loop, the height of the ground of the sector 255 is fixed with the function set_sector_height() . The function get_sector_height() allows you to find the ground and ceiling heights in a mode 8 sector. ---See: get_sector_height() - start_mode8() - STRUCT m8","title":"set_sector_height()"},{"location":"help/#get_sector_height","text":"get_sector_height( , , ) Returns: The height of the ground and ceiling of a mode 8 sector (in the variables which offset are indicated as the two last parameters). Description: This function allows you to determine in a program, the height of the ground and ceiling of a determined sector, inside of a mode 8 sector. To do this, the is required , and the OFFSET (address of memory) of the two variables where the result will be returned. This information also can be obtained inside of the editor of three-dimensional maps as explained in the user's manual. Example program: PROGRAM example_get_sector_height; GLOBAL ceiling_height; floor_height; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtain the heights of a sector get_sector_height(255,OFFSET floor_height,OFFSET ceiling_height); // ... END - This small example shows how the function get_sector_height() must be called to obtain the heights of a sector (in this case, in the variables ceiling_height and floor_height these values are obtained for the sector number 255 ). To establish the height of a sector, the function set_sector_height() must be used. ---See: set_sector_height() - start_mode8() - STRUCT m8","title":"get_sector_height()"},{"location":"help/#set_point_m8","text":"set_point_m8( , , ) Description: Modifies the coordinates of a three-dimensional map's vertex on a mode 8 sector. The following parameters are required: - Number of vertices of the map which position is wanted to modified. This number can also be obtained from the editor of the three-dimensional maps, as is explained in the user's manual. , - The new coordinates of the vertex must be defined. The coordinates inside of a three-dimensional map are placed with the rank ( 0 .. 30200 ). To create a mode 8 region, the function start_mode8() must be called. Note: This is a function which can give rise to multiple errors of visibility . For that reason, it is not recommended for use by inexperienced users. The vertices can only move inside of the sector in which they started, sector boundaries can't be crossed (not the vertex, nor the lines which these make) and, besides, all sectors which can't contain processes may not be moved. Example program: PROGRAM example_set_point_m8; GLOBAL position1; position2; angle1; angle2; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=64; LOOP position1=3400+get_distx(angle1,150); angle1+=5000; position2=3400+get_distx(angle2,150); angle2+=7000; set_point_m8(1620,position1,9280); // Fixes the vertex 1620 set_point_m8(1621,position2,9456); // Fixes the vertex 1621 FRAME; END END - This small example initialises a mode 8 region, loading the map wld_view.wld , and places it in the predetermined coordinates with the function go_to_flag() . Then, inside of the program's main loop, the position of the vertex 1620 and 1621 is fixed with the function set_point_m8() . The function get_point_m8() allows you to find the coordinates of a vertex of a three-dimensional map in a mode 8 region. ---See: get_point_m8() - start_mode8() - STRUCT m8","title":"set_point_m8()"},{"location":"help/#get_point_m8","text":"get_point_m8( , , ) Returns: The coordinates of a vertex of a mode 8 map (in the variables which offset , indicated as the two last parameters). Description: This function allows you to determine inside of a program, the coordinates of a specific vertex, inside of a mode 8 region. To do this, the is required, and the OFFSET (pointer) of the two variables where the result is stored. This information can also be obtained from the three-dimensional maps editor, which is explained in the user's manual. Example program: PROGRAM example_get_point_m8; GLOBAL position_x; position_y; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains a vertex's coordinates get_point_m8(1620,OFFSET position_x,OFFSET position_y); // ... END - This small example shows how the function get_point_m8() is called to obtain the position of a sector vertex (in this case, in the variables position_x and position_y ). To set or establish the positions of a vertex, the function set_point_m8() must be used. ---See: set_point_m8() - start_mode8() - STRUCT m8","title":"get_point_m8()"},{"location":"help/#set_fog","text":"set_fog( , ) Description: Modifies the fog of a mode 8 region initiated with the function start_mode8() , to do this, the following parameters are required: - Percentage or initial distance of the fog (from 0 to 100), in this way, the point from which the effect is applied is determined. - Percentage or final distance of the fog (from 0 to 100), in this way, the point from which the fog is solid/completely opaque is determined. Normally the position or final percentage is established as the double of the initial, the further apart the values are, the more slowly the fog will appear. Example program: PROGRAM example_set_fog; GLOBAL fogpos; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); FRAME; z+=128; LOOP fogpos=25+get_distx(angle1,20); angle1+=5000; set_fog(fogpos,fogpos*2); // Establishes the fog level of the mode 8 FRAME; END END - This small example shows how the function set_fog() must be called to modify the fog of a mode 8 region. The variable position varies from 5 to 45 (using the function get_distx() ), this will be the initial position, the final one will be fixed as double the initial one. Note: The function set_env_color() allows you to fix the ambience colour or the fog colour of a mode 8 region. ---See: set_env_color() - start_mode8() - STRUCT m8","title":"set_fog()"},{"location":"help/#set_sector_texture","text":"set_sector_texture( , , , ) Description: Modifies the textures of ground and ceiling of a mode 8 sector. The following parameters are required: - Number of the map sector for which textures are to be modified. This number can be obtained from the three-dimensional maps editor, as is explained in the user's manual of the program. - The code of the new texture graphic to be used as the ground texture of the sector (ie: the number of the graphic inside of the FPG which contains every texture of the mode 8 region). If a ** -1** is indicated as parameter the current texture will remain (to modify just the ceiling texture). - The code of the new texture graphic to be used as the ceiling texture of the sector (ie: the number of the graphic inside of the FPG which contains every texture of the mode 8). If a ** -1** is indicated as parameter the current texture will remain (to modify just the ground texture). - Luminosity of the texture, from 0 (ambience colour, which is normally black) up to 15 (texture with the original colours). If a ** -1** is indicated, the current level of luminosity in the sector will remain unchanged. Note: every texture must be contained in the same file FPG, this is the file which is loaded with load_fpg() function and which number is given as the parameter of the function load_wld() . Example program: PROGRAM example_set_sector_texture; GLOBAL texture=94; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=128; m8.angle=-64; LOOP IF (texture++==103) texture=94; END set_sector_texture(255,texture,-1,15); FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , which is placed at the predetermined coordinates with the function go_to_flag() . Then, inside of the program main loop, the ground texture of the sector 255 is set with the function set_sector_texture() . The function get_sector_texture() allows one to find the textures (and luminosity) that are assigned to a mode 8 sector. The function set_wall_texture() allows you to establish the texture of a wall. ---See: get_sector_texture() - set_wall_texture() - set_sector_height()","title":"set_sector_texture()"},{"location":"help/#get_sector_texture","text":"get_sector_texture( , , , ) Returns: The luminosity, and the textures of the ground and ceiling of a mode 8 sector (stored in the variables which offset are indicated as the parameters). Description: This function allows you to determine which are the textures in a program for the ground and the ceiling and/or the luminosity of a determined sector, inside of a mode 8 region. To do this, the is required , and the OFFSET (pointer) for the variables where the results will be stored are also required. Example program: PROGRAM example_get_sector_texture; GLOBAL ceiling_texture; floor_texture; luminosity; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains the luminosity and textures of a sector get_sector_texture(255,OFFSET ceiling_texture,OFFSET floor_texture,OFFSET luminosity); // ... END - This small example shows how the function get_sector_texture() must be called to obtain the textures and the luminosity of a sector (in this case, in the variables floor_texture , ceiling_texture and luminosity these values are obtained for the sector number 255 ). The function set_sector_texture() allows you to establish the textures and luminosity of a mode 8 sector dynamically. The function get_wall_texture() allows you to find what the assigned texture of a mode 8 wall is . ---See: set_sector_texture() - get_wall_texture()","title":"get_sector_texture()"},{"location":"help/#set_wall_texture","text":"set_wall_texture( , , ) Description: Modifies the wall texture of a mode 8 sector. The following parameters are required: - Number of the wall texture required. This number can be obtained in the three-dimensional maps editor, as is explained in the user's manual of the program. - The code of the graphic which is to be assigned as the new wall texture (the number of the graphic inside of the FPG which contains every mode 8 texture) must be indicated. If a ** -1** is indicated as the parameter, the current texture will remain unchanged. - Luminosity of the texture, from 0 (ambience colour, which is normally black) up to 15 (texture with the original colours). If a ** -1** is indicated, the current level of luminosity will remain unchanged. Note: every texture must be contained in the same file FPG, this is the file which is loaded with load_fpg() and which number is given as a parameter to the function load_wld() . Example program: PROGRAM example_set_wall_texture; GLOBAL texture=104; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(1); FRAME; z+=128; LOOP IF (texture++==113) texture=104; END set_wall_texture(511,texture,15); // Modifies a wall texture FRAME; END END - This small example starts a mode 8 region, loading the map wld_view.wld , and it is placed in the predetermined coordinates with the function go_to_flag() . Then, inside the program main loop, the texture of the wall number 511 is fixed with the function set_wall_texture() . The function get_wall_texture() allows you to find the current texture of a wall. The function set_sector_texture() allows you to establish the {textures of ground and ceiling} of a mode 8 sector. ---See: get_wall_texture() - set_sector_texture() - set_sector_height()","title":"set_wall_texture()"},{"location":"help/#get_wall_texture","text":"get_wall_texture( , , ) Returns: The luminosity and the texture of a mode 8 wall (in the variables which offset are indicated in the parameters). Description: This function allows you to determine inside of a program, what the texture and the luminosity is of a determined wall, inside of a mode 8. To do this, the is required, and the OFFSET (pointer) of the variables where the result will be stored. Example program: PROGRAM example_get_wall_texture; GLOBAL texture; luminosity; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); // ... // Obtains the luminosity and texture of a wall get_wall_texture(255,OFFSET texture,OFFSET luminosity); // ... END - This small example shows how the function get_wall_texture() must be called to obtain the texture and the luminosity of a wall in a sector (in this case, the variables texture and luminosity are assigned to the wall number 255 ). The function set_wall_texture() allows you to establish the texture and luminosity of a mode 8 wall dynamically. The function get_sector_texture() lets us know which are the floor and ceiling textures of a mode 8 sector. ---See: set_wall_texture() - get_sector_texture()","title":"get_wall_texture()"},{"location":"help/#set_env_color","text":"set_env_color( <% red> , <% green> , <% blue> ) Description: Modifies the colour of the ambience or fog of a mode 8 sector, to do this the components (red), (green) and (blue) of the sector are required. The three components must be specified as percentage, from 0 to 100 . By default, the fog is set as a black colour (0,0,0), but this colour can be modified to create a different ambience. Example program: PROGRAM example_set_env_colour; GLOBAL light; angle1; BEGIN load_fpg(\"help/WLD_VIEW.FPG\"); load_wld(\"help/WLD_VIEW.WLD\",0); start_mode8(id,0,0); ctype=c_m8; go_to_flag(0); FRAME; set_fog(30,90); z+=128; LOOP light=50+get_distx(angle1,50); angle1+=5000; set_env_color(light,light,light); // establishes the ambience colour FRAME; END END - This small example shows how the function set_env_color() must be called to modify the fog colour of a mode 8 region. The variable light varies from 0 to 100 (using the function get_distx() ), this percentage is the same for the three components of the colour, so this will gradually change from black to white , going through all the grey scale in between. Note: The function set_fog() allows you to fix the density of the fog or ambience of a mode 8 region. ---See: set_fog() - start_mode8() - STRUCT m8","title":"set_env_color()"},{"location":"help/#strcpy","text":"strcpy( , ) Returns: Copies a string from the origin to the string destination. Description: Copies the to the , (the original content of the string destination will be lost). The must be a data type STRING , of a length long enough to contain the text of the . Example program: PROGRAM example_strcpy; GLOBAL STRING string1=\"Initial text\"; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,192,0,\"Press [SPACE] to copy another text in \"); LOOP IF (key(_space)) strcpy(string1,\"Final text\"); // Modifies string1 END FRAME; END END - When the length of the copied string is smaller than 1024 characters, this same operation can be done with the following statement: (continuing with the previous example): string1 = \"Final text\"; With a generic statement of assignation as the following: = ; The Being always of a data type STRING . To join some text strings together the function strcat() must be used. ---See: strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel()","title":"strcpy()"},{"location":"help/#strcat","text":"strcat( , ) Returns: Joins two strings together and returns the address of the string destination. Description: Joins two text strings, copying the and adding on the end of the text contained in the . The must be of data type STRING , of a length long enough to contain both strings. Example program: PROGRAM example_strcat; GLOBAL STRING string1=\"Beginning \"; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,192,0,\"Press [SPACE] to add a text to \"); LOOP IF (key(_space)) strcat(string1,\"Final\"); // Adds a text to string1 END FRAME; END END - When the length of the resultant string is smaller than 1024 characters, this same operation can be achieved with the following statement : (continuing with the previous example): string1 = string1 + \"Final\"; (or) string1 += \"Final\"; Or with a generic statement of assignation (or with the symbol += , of operative assignation) such as the following: = + ; (or) += ; Being always of data type STRING . To copy text strings, the function strcpy() must be used. To separate (or substrate) text strings, the function strdel() must be used. ---See: strcpy() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel()","title":"strcat()"},{"location":"help/#strlen","text":"strlen( ) Returns: The length of the string, in characters (with spaces included). Description: Counts the number of characters of the text given as a parameter, or contained currently in the passed string. The can be a literal (text between quotation marks) or data of any other type. Example program: PROGRAM example_strlen; GLOBAL STRING string1=\"Text example\"; length_string1; BEGIN write(0,0,0,0,\"Text contained in :\"); write(0,0,10,0,string1); write(0,0,20,0,\"Length of :\"); length_string1=strlen(string1); // calculates the length write_int(0,0,30,0,OFFSET length_string1); LOOP FRAME; END END - A character or string can be added to another string with the function strcat() , or with a statement of assignation such as the following: string1+=\"a\"; To remove characters of a string use strdel() , although it is possible to eliminate characters at the end of a string with statements such as the following: string1--; string1-=1; string1=string1-1; ---See: strcpy() - strcat() - strcmp() - strchr() - strstr() - strset() - upper() - lower() - strdel()","title":"strlen()"},{"location":"help/#strcmp","text":"strcmp( , ) Returns: ** +n** - If the first string is bigger than the second. ** 0** - If the strings are identical. ** -n** - If the first string is smaller than the second. Description: Compares two text strings, character per character, giving back 0 when both strings are identical. Example program: PROGRAM example_strcmp; GLOBAL STRING mystring; BEGIN // ... IF (strcmp(mystring,\"abc\")==0) // The two strings are identical ... END // ... END - if the strings have less than 1024 characters, the comparison of strings can also be done with the typical operators of comparison. For example, the comparison of the previous example could be done with the following statement: IF (mystring==\"abc\") //... END In the same way, the symbol <> can be used to compare if the two strings are different, with the symbols < or <= if a string is smaller, or identical to another, etc. To search for a string inside another (to see if it is contained in it), the function strstr() , must be used, and to see if a string contains a specific character the function strchr() must be used. ---See: strcpy() - strcat() - strlen() - strchr() - strstr() - strset() - upper() - lower() - strdel()","title":"strcmp()"},{"location":"help/#strchr","text":"strchr( , ) Returns: ** -1** If none of the characters were found inside of the string. ** +n If one of the characters was found in the position n** of the string. Description: Searches for one or some in a . It receives the string as first parameter and, as the second, one or more characters in a literal (between quotation marks). This function will determine if the string contains any of the characters and, if so, will indicate at which position inside the string (from 0) the character appears. In the character appears on more than one occasion, the function will always return the first position the character occurred. Example program: PROGRAM example_strchr; GLOBAL STRING mystring=\"FGHIJK\"; position; BEGIN write(0,0,0,0,\"First vowel of is in position:\"); position=strchr(mystring,\"AEIOU\"); write_int(0,0,10,0,OFFSET position); LOOP FRAME; END END - In this example the function strchr() is used to determinate the first vowel of mystring is the position 3 of the string. The characters of a data of STRING can be accessed always as if this would be a table of characters. For example, to change in the data mystring of the previous example, the character \"I\" for a character \"-\" the following statement could be used: mystring[3]=char(\"-\"); To convert a character, contained in a literal, in its ordinal value (ASCII) the function char() is used. To determinate if a string is completely contained in another (if appears as a substring inside of the same), the function strstr() must be used. ---See: strcpy() - strcat() - strlen() - strcmp() - strstr() - strset() - upper() - lower() - strdel()","title":"strchr()"},{"location":"help/#strstr","text":"strstr( , ) Returns: ** -1** If the substring wasn't found inside of the string. ** +n If it was found in the position n** of the text string. Description: Searches for the sequence of characters contained in the in a . This function will determine if a text string contains the substring (as \"HOUSE\" contains \"USE\") and, if so, will indicate whereabouts the substring appears inside of the string (from 0, 1 in the previous example). If the substring on more than one occasion, the function will return the position where the string first occurred. Example program: PROGRAM example_strstr; GLOBAL STRING mystring=\"This is an example string.\"; position; BEGIN position=strstr(mystring,\"an\"); write_int(0,0,10,0,OFFSET position); LOOP FRAME; END END - In this example the function strstr() is used to determine where the substring \"is\" is found inside mystring , it will return the position 8 . To change from capital letters to small letters the functions upper() and lower() can be used. To determine if a string contains a character, the function strchr() must be used, which, allows you to search for any character inside the specified group simultaneously. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strset() - upper() - lower() - strdel()","title":"strstr()"},{"location":"help/#strset","text":"strset( , ) Description: Assigns to every position of the the indicated as the second parameter. The function can receive the in two ways; as a literal (the character between quotation marks), or as its ordinal (its ASCII value) which must be a value between 0 and 255 . The complete string will be replaced with this character. The length of the string depends on the indicated value between \"[]\" in its initiation, if the function doesn't know the length of the data of type STRING , a string of 256 characters will be created (from the position 0 to 255). Example program: PROGRAM example_strset; GLOBAL STRING mystring=\"This is an example string.\"; BEGIN write(0,0,0,0,\"content of (press space to change it):\"); write(0,0,10,0,mystring); LOOP IF (key(_space)) strset(mystring,\" \"); // Fills up the string with \" \" END FRAME; END END - To calculate the current length of a string, the function strlen() will be used. To delete characters from a string (from the beginning and from the end) the function strdel() must be used. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - upper() - lower() - strdel()","title":"strset()"},{"location":"help/#upper","text":"upper( ) Returns: If a character was a small letter (lowercase), it returns the same character but as a capital letter (uppercase). Description: converts a string (or just a character) to capital letters, including the special characters, like the letter \"\u00b1\" or the accentuated vowels. This function works in one of two ways, depending on the parameter it receives: If it receives a text string (or literal between quotation marks), it will convert to capital letters every contained character in the string and won't return any significant value (just the cursor of the receipt string). If it receives just one character (its ordinal value or ASCII value), it will return the character converted into a capital letter (but just its ordinal value), and the function will not change any data in memory. Example program: PROGRAM example_upper; GLOBAL STRING mystring=\"This is an example string.\"; STRING myletter=\"a\"; BEGIN upper(mystring); // converts a string to capital letters upper(myletter); // converts a character to capital letters write(0,0,0,0,mystring); write(0,0,10,0,OFFSET myletter); LOOP FRAME; END END - This example has defined two global data ( mystring and myletter ), the function upper() will be used to convert it to capital letters, and then it will be shown on screen. This function will not modify those characters which are not small (lowercase) letters. The function lower() is the opposite to upper() , because it can converts a string (or a character) to small (lowercase) letters. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - lower() - strdel()","title":"upper()"},{"location":"help/#lower","text":"lower( ) Returns: If a character is given to a capital letter (uppercase), it returns the character changed to a small letter (lowercase). Description: Converts a string (or a simple character) into small letters, including the special characters, like the letter \"\u00b1\" or the accented vowels. This function can work in one of two modes, depending on the parameter given: If it receives a text string (or literal between quotation marks), it will change into small letters every character contained in the string and will not return any significative value (just the cursor of the string given). If it receives just a character (its ordinal value or ASCII), it will return the character changed into a small letter (its ordinal value), and the function won't change any data in memory. Example program: PROGRAM example_lower; GLOBAL STRING mystring=\"THIS IS AN EXAMPLE STRING\"; STRING myletter=\"A\"; BEGIN lower(mystring); // Changes a string into small letters lower(myletter); // Changes a character into small letters write(0,0,0,0,mystring); write(0,0,10,0,OFFSET myletter); LOOP FRAME; END END - This example has defined two global data ( mystring and myletter ), the function lower() will be used to convert them into small letters, and then will be shown on screen. This function won't modify those characters which are not capital letters. The function upper() is the opposite to lower() , because it changes a string (or a character) into capital letters. ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - strdel()","title":"lower()"},{"location":"help/#strdel","text":"strdel( , , ) Description: This function deletes characters from a . Characters Will be eliminated from the beginning of the string and characters from the end of it. To eliminate just characters from the beginning of the string you must indicate 0 as the , and to eliminate just from the end, set 0 as { }. Example program: PROGRAM example_strdel; GLOBAL STRING mystring=\"This is an example string.\"; BEGIN strdel(mystring,5,9); write(0,0,0,0,mystring); LOOP FRAME; END END - This example uses the function strdel() to eliminate the first 5 characters of and the last 9 , and then, show the resultant string on screen (\"is an examp\"). Note: If the quantity of characters to delete is negative (for the beginning or for the end), the function will add spaces to the string. It is also possible to eliminate characters from the end of a string with statements such as the following: string1--; string1-=1; string1=string1-1; ---See: strcpy() - strcat() - strlen() - strcmp() - strchr() - strstr() - strset() - upper() - lower()","title":"strdel()"},{"location":"help/#screen_copy","text":"screen_copy( , , , , , , ) Description: Copies a screen region to a region of any graphic. This is a potent function that can be very useful, because it gives \"feedback\" from the computer screen, and can send an image of the screen to a graphic (opposite operation to the normal). First you must define the number of the rectangular which is going to be copied from the screen (of the previous image of the program), these regions are defined with the function define_region() . The region number 0 is always related to the entire screen. Then, the graphic where the image is going to be transferred to must be indicated with the parameters and (the file will be the number 0, if the graphic belongs to the first FPG loaded, or if it has been loaded already). Finally, the zone inside of the graphic the image must be transferred to will be defined. This will be defined as , , and , related to the coordinates inside of the graphic (being the coordinates [0,0] its upper left corner). Example program: PROGRAM example_screen_copy; GLOBAL angle1; angle2; BEGIN load_fpg(\"help/help.fpg\"); graph=2; x=160; y=100; put(0,graph,x,y); LOOP // Copies the screen (region 0) to the graphic 2 screen_copy(0,0,2,0,0,320,200); angle1+=1000; angle2+=1971; angle=get_distx(angle1,25000); size=95+get_disty(angle2,30); FRAME; END END - In this example the file help.fpg is loaded, in which the graphic number 2 is a cell of different colours, and is placed on the screen and defined as the graphic of the main process, which will rotate and change its size (depending on the angle and angle2 , respectively). Then the function screen_copy() is used again to send the updated image of the screen to this graphic, so this effect happens. Note: The size of the screen region (the transferred zone) and the size of the graphic region (where it's transferred) doesn't have to match . The function screen_copy() will do a reduction or ampliation when needed to adjust the size of the transferred zone. ---See: define_region() - clear_screen() - graph","title":"screen_copy()"},{"location":"help/#qsort","text":"qsort( , , ) Description: Orders or shuffles one of the fields of a program structure . It is a simple but useful function which allows the quick ordering and shuffling of data structures. Its use is very simple, all is required is the , the one of the , and the ; one of the indicated now: 0 - Ascendent ordination (from min to max). 1 - Descendent ordination (from max to min). 2 - Random ordering (shuffling) Any of the data contained in the structure can be used as the index field, without depending on if it is numeric data or a string of text (in which case it will be ordered alphabetically) Example program: PROGRAM example_qsort; GLOBAL STRUCT mystructure[9]; STRING name[32]; points; x,y; END BEGIN //... // Orders the registers of mystructure, the one with the biggest // score being placed at the beginning qsort(mystructure,points, 1); //... END - This example shows the easy use of the function qsort() to order a structure, that can represent any type of object inside of a program. It is not necessary that the field used as index ( points in this case) is the first field of the structure. Note: The shuffling of a structure requires a field which makes differences between the different registers of the same. This operation can be useful to give \"randomness\" to a program (for example, to \"mix\" or \"shuffle\" a deck of cards).","title":"qsort()"},{"location":"help/#load_song","text":"load_song( , ) Returns: Identifier of the loaded song, or -1 if an error occurs. Description: Loads a song from an file MOD, S3M or XM, to its later reproduction. The function requires the name of the file which contains the music module, and if this one must be played back just once (indicating 0 in ) or indefinitely (indicating 1 ). These music modules can be composed with multiple shareware programs or freeware programs. In DIV Games Studio these music modules can be played back, in the created programs, but you cannot compose new modules. Example program: PROGRAM example_load_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); // Loads an XM module, with replay song(id_song); write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() , indicating that this one must be played back indefinitely. The reproduction of the file is begun with a call to the function song() . To delete a song from memory, the function unload_song() must be used. The sound volume of the song can be controlled with the function set_volume() and the data contained in the setup structure . Note: With this version of DIV Games Studio comes included some files of freeware music modules in the directory MOD . Note: To reproduce songs contained in a CD-Audio track the functions play_cd() and stop_cd() must be used. ---See: unload_song() - song() - play_cd() - Setup structure","title":"load_song()"},{"location":"help/#unload_song","text":"unload_song( ) Description: Deletes from memory the music module whose identifier is given as the parameter. This is the value which the function returns load_song() when is loaded into memory. After deleting a module you must be very cautious not to use it again in the program, otherwise the program would crash. It is not necessary to delete the modules before finishing the program because the system will do it automatically. So, just delete from memory the modules which are not going to be used for the time being in order to liberate computer memory to load other resources (other files of graphics, sounds, fonts, etc). Example program: PROGRAM example_unload_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); // Sets free the filled memory by the module END - This example loads the module contained in the file help.xm with the function load_song() . The playback of the file is indicated with a call to the function song() . The program will continue to play this module until the ESC key is pressed, the module is then deleted from memory with the function unload_song() , indicating as the parameter id_song which contains the identifier of the module returned when loaded. Note: songs that are CD-Audio tracks, which can be played with the function play_cd() , don't use up computer memory, so they cannot be deleted with the function unload_song() . ---See: load_song() - song()","title":"unload_song()"},{"location":"help/#song","text":"song( ) Description: Starts playback of a music module loaded with the function load_song() . The function will receive as its only parameter the { } to play back. Just one module can be played at the same time, if another starts, the previous module will stop. But a music module, a CD-Audio track (see play_cd() ) and multiple sound effects (see sound() ) can be played at the same time . The playback will always begin from the start of the module (the beginning of the song). To play a specific part of the module then use the function set_song_pos() , which sets the position from where playback of the module will start. Example program: PROGRAM example_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); // Starts the reproduction of the music module write(0,0,0,0,\"Press ESC to finish\"); REPEAT FRAME; UNTIL (key(_ESC)); unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() , indicating that this must be played indefinitely (this must be indicated in the file's load). Then the playback of the file begins with the function song() . The program will then enter a loop in which this module will still be playing, until the ESC key is pressed and the program finishes. The sound volume of playback can be controlled with the function set_volume() and the contained data in the setup structure . Note: To finish the playback of a music module the function stop_song() must be used. Note: The function is_playing_song() can find if the module is being currently played. ---See: load_song() - stop_song() - play_cd() - sound()","title":"song()"},{"location":"help/#stop_song","text":"stop_song( ) Description: Stops the playback of the music module (MOD, S3M or XM) which is being played. This function doesn't require any parameter, because only one music module can be played at the same time. It is not essential to stop the playback of a music module before being deleted from memory (an operation made with the function unload_song() ), this is done automatically. Example program: PROGRAM example_stop_song; GLOBAL id_song; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press SPACE to stop the song ...\"); LOOP IF (key(_space)) stop_song(); // Stops the module END FRAME; END unload_song(id_song); END - This example loads the module contained in the file help.xm with the function load_song() . The playback of the file begins with a call to the function song() . The program will then enter into a loop in which this module will still be playing, when the space bar is pressed it makes a call to the function stop_song() and the module finishes. To delete a song from memory the function unload_song() must be used, all the programs created in DIV Games Studio will free any filled memory automatically at the end. Note: To stop a song of CD-Audio the function stop_cd() is used, and for a sound effect, use the function stop_sound() . Note: The function is_playing_song() can find out if a module is playing. ---See: song() - load_song() - play_cd() - sound()","title":"stop_song()"},{"location":"help/#set_song_pos","text":"set_song_pos( ) Description: Fixes the position of the music module playback (the \"pattern\" number). This is a number between 0 and the max number of pattern of the module. This value varies for each module, and can be defined in the programs used to compose them. The modules usually have quite a variable number of patterns, though the average is usually situated between 30 and 40. Inside each pattern, the modules have a determined number of lines (normally 64), in which appear the musical notes, so each pattern could be defined as a small section of the music module. To obtain the current position which is being played back the function get_song_pos() is used. The position of the module can be changed if the module is playing or has stopped. This function can be used to advance or to retard the playback of the module, to implement diverse loops in certain parts of a module, etc. Example program: PROGRAM example_set_song_pos; GLOBAL id_song; position_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Press SPACE to change the position of the module ...\"); write(0,0,20,0,\"position:\"); write_int(0,0,30,0,OFFSET position_module); LOOP IF (key(_space)) position_module=rand(0,19); set_song_pos(position_module); // Changes the position of the module END position_module=get_song_pos(); FRAME; END END - This program loads the module contained in the file help.xm and then starts its playback with the function song() . From this moment the current position of the module will be shown on screen and it can be changed by pressing the space bar (a random position will be assigned between 0 and 19, because this module has 20 patterns). Note: The playback line of a module can't be set (inside each pattern), but the value can be obtained with the function get_song_line() . ---See: get_song_pos() - song() - load_song()","title":"set_song_pos()"},{"location":"help/#get_song_pos","text":"get_song_pos( ) Returns: The current position of the musical module which is being played. Description: Returns the current position of playback of the musical module, this position can be set with the function set_song_pos() . This is a number between 0 and the max number of pattern of the module. This value is different for each module, and is defined in the programs used to compose them. The modules can have any variable number of patterns, although the average is between 30 and 40. Inside each pattern the modules have a determined number of lines (normally 64), in which appear the musical notes, therefore each pattern can be defined as a small section of the musical module. Example program: PROGRAM example_get_song_pos; GLOBAL id_song; position_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Position of the module:\"); write_int(0,0,10,0,OFFSET position_module); LOOP position_module=get_song_pos(); // Obtain the position FRAME; END END - This program loads the module contained in the file help.xm and then initiates its playback with the function song() . From this moment the current position of the module on screen will be shown, obtained with the function get_song_pos() . Note: the line number which is played back Can be obtained, inside the pattern, with the function get_song_line() . ---See: get_song_line() - set_song_pos() - song()","title":"get_song_pos()"},{"location":"help/#get_song_line","text":"get_song_line( ) Returns: The line number of the musical module. Description: The line number of a musical module playing can be obtained With this function. This current position, or pattern, can be obtained with the function get_song_pos() . Inside each pattern the modules have a determined number of lines (normally 64), in which appear musical notes. The modules often have a different number of patterns, although the average is between 30 and 40. Example program: PROGRAM example_get_song_line; GLOBAL id_song; line_module; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"Line of module:\"); write_int(0,0,10,0,OFFSET line_module); LOOP line_module=get_song_line(); // Obtain the number of line FRAME; END END - This program loads the module contained in the file help.xm and then initiates its playback with the function song() . From this moment the current line of the module is shown on screen, obtained with the function get_song_line() . Note: The line of a musical module Cannot be set, although it is possible to fix the position where playback begins with the function set_song_pos() (always will begin from the line 0 of the pattern). ---See: #219,get_song_pos()} - set_song_pos() - song()","title":"get_song_line()"},{"location":"help/#is_playing_sound","text":"is_playing_sound( ) Returns: 0 - If the channel is stopped. 1 - If is going the sound by the channel. Description: This function allows you to know if one of the sound channels are playing sound or if it is disposed. the is required as the parameter, this value is obtained as the return of the function sound() after initiating the playback of the sound effect. Example program: PROGRAM example_is_playing_sound; GLOBAL sound_id; channel_id; BEGIN write(0,0,0,0,\"Press ESC to finish.\"); sound_id = load_pcm(\"help/help.pcm\",0); channel_id = sound(sound_id, 256, rand(100,400)); REPEAT // If the playback has finished, return the sound IF (NOT is_playing_sound(channel_id)) channel_id = sound(sound_id, 256, rand(100,400)); END FRAME; UNTIL (key(_ESC)); END - This example uses a function to continually test and restart the sound, controlled by the program, instead of automatically (as is often indicated in the loading of the sound, in the functions load_pcm() or load_wav() ). The playback again always initiates once the sound channel is free, it means, each time when playback of the sound has finished. The program uses this circumstance (manual control of the replay) to emit the sound with a different frequency in each case, this couldn't be done with the automatic replay. This frequency is obtained as a value between 100 and 400 with the function rand() . Note: The same sound can be played back by different channels each time, therefore it is necessary to save the channel number each time when the playback is initiated. ---See: sound() - change_sound() - is_playing_song()","title":"is_playing_sound()"},{"location":"help/#is_playing_song","text":"is_playing_song( ) Returns: 0 - Any module is playing. 1 - Is playing a musical module. Description: This function determines if a digital musical module of the file MOD, S3M or XM is being played. These modules must be loaded with the function load_song() and their playback is initiated with the call to song() . Only one module can be played back at the same time, therefore this function doesn't require any parameter, only returns 1 if there is one module reproducing. Example program: PROGRAM example_is_playing_song; GLOBAL id_song; sounding; BEGIN load_song(\"help/help.xm\",1); song(id_song); write(0,0,0,0,\"ENTER initiate the module / SPACE to stop it\"); write_int(0,0,10,0,OFFSET sounding); LOOP IF (key(_enter)) song(id_song); END IF (key(_space)) stop_song(); END sounding = is_playing_song(); // Determines if is playing FRAME; END END - This example loads musical module contained in the file help.xm and permits, inside one loop, initiate it with the key ENTER and stop it with the space bar. Inside the same loop is used the function is_playing_song() to determine if it is playing each moment. Note: To finish the playback of one musical module must be used the function stop_song() . ---See: load_song() - song() - is_playing_sound()","title":"is_playing_song()"},{"location":"help/#fopen","text":"fopen( , ) Returns: The handle or identifier of the open file, or 0 if an error was produced. Description: Opens a data file to read or write to, with the help of a handle or identifier of file which this function returns from the open or created file. the to open or create is required , and the of opening, which must be a literal (text in inverted commas) inside the following: \" r \" - Open the file for reading of the data contained in it. \" w \" - Create the file to write (if it already exists, it will lose the presently contained data). \" a \" - Open the file to write to after finishing with it, or it creates the file if it didn't exist. \" r+ \" - Open an existent file to activate it, permitting reading and writing. \" w+ \" - Create a file to write to, permitting also its reading. \" a+ \" - Open an file to read it from any position and write new data to add on the end. Once an file is opened, you can use all the functions for files based in handles , but once the necessary operations have been completed in the file must not be closed , you should then close it with the function fclose() . The main functions are fread() for reading the data inside the file and fwrite() to write the data; it is important to open the file in the appropriate mode for the requested operations. For example, you cannot write in the file if it was opened only for reading. Example program: PROGRAM example_fopen; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); // Open file to write fwrite(OFFSET list1,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); // Open file to read fread(OFFSET list2,4,myhandle); fclose(myhandle); END - This example program has defined two global lists; list1 with four values initiated in 11, 22, 33 and 44, and list2 with four without initiates (zero). The functions of files are used to write in one file the content of the list1 and then load it over the list2 . After finishing the program, the data of the first list will have been copied into the second. the function fopen() is called on two occasions, the first to {create it and write} in it and the second to open it and read its contents. It is important to underline that each time when you open or create the file, you must close it with the function fclose() (can be seen how in the example the file is closed on two occasions). The function fseek() allows you to situate the pointer of reading/writing at any position in the file. In this way, data at any point of the file can be read or written. The function flush() empties the buffers of writing and allows you also to check how many files are open at any moment. Note: The functions save() and load() allow you also to save the data in files of the disk and restore them. These functions are less useful, but their use is easier than the functions based in handles here described. ---See: fclose() fread() - fwrite() - save()","title":"fopen()"},{"location":"help/#fclose","text":"fclose( ) Returns: Number of closed files. Description: Closes an file opened with the function fopen() , fclose must receive as parameter the handle or identifier of file returned by this function. In the second modality, the function fclose() can {close all opened files} at one time, for this you indicate 0 (zero) as its parameter, instead of handle . Anyway, the function returns the number of files which were closed, if it returns 0 it can mean one of these cases: ** -** There was no open file. ** - The passed handle doesn't correspond to any opened file. ** - The file corresponding to this handle was already closed. All open files must be closed before the program finishes its execution. Example program: PROGRAM example_fclose; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET list1,4,myhandle); fclose(myhandle); // The file closes to be opened in other mode myhandle=fopen(\"help/help.dat\",\"r\"); fread(OFFSET list2,4,myhandle); fclose(myhandle); // The file closes definitively END - the functions of files Are used to write in one file the content of the list1 and then copy it over the list2 . After finishing the program, the data of the first will have been copied into the second. If the open file in one mode (with the function fopen() ) wants to access an file in a different mode, you must first close the file before opening it in the new mode; in the example, the file of writing is then closed to open it then in reading mode. The function flush() empties the buffers of writing and permits you also to check how many files are open at any moment. ---See also: fopen() fread() - fwrite()","title":"fclose()"},{"location":"help/#fread","text":"fread( , , ) Returns: 0 - If an error was produced , or all asked data was not read . 1 - If all data was read. Description: This function permits you to read the data of an file opened with the function fopen() , starting from the position indicated by the {pointer of reading/writing}. The file must be opened in the reading mode , or a mode which it permits reading of data. The pointer is situated at the beginning of the file, after it has been opened, and advances sequentially during the reading of the data. But this pointer can be situated in any position, using the function fseek() and the function ftell() allows you to obtain the current position of the pointer of an file. The function fread() requires as a parameter the < OFFSET of the data> in which must the data of file be read , it means, the memory address from where must be placed the data which are reading from the file. As second parameter is required the or total size of the data which you want to read, it means, the number of positions of memory which occupy these data. The length of one data can be obtained with the function sizeof() . The last parameter must be the handle or identifier of file which was obtained after open the file as value of return of fopen() . Example program: PROGRAM example_fread; GLOBAL list1[3]=11,22,33,44; list2[3]; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET list1,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); fread(OFFSET list2,4,myhandle); // Read the file about fclose(myhandle); END - This example program has defined two global lists; list1 with four values initiated as 11, 22, 33 & 44, and list2 with four without initiate (all zero). The file functions are used to write in one file the content of the list1 and then copy it over the list2 . After finishing the program, the data of the first list will have been copied into the second. The function fopen() is called on two occasions, the first to {create it and write} in it and the second to open it and read its contents. It is important to underline that each time you open or create the file, you must close it with the function fclose() (in the example the file is closed on two occasions). The inverse function to fread() , which permits you to write data in an file instead of read it, is fwrite() . The way to use this function and its parameters are similar to those of fread() . Note: By default, the is specified as the number of simple data, remembering that a simple data (a variable) occupies {4 bytes}. So for example, if ten data (indicating 10 as length)are read, these date will occupy 40 bytes of memory. This relation can be changed by modifying the global variable drive_size , which has a default value of 4 in all programs. ---See: fopen() - fwrite() - fseek() - drive_size","title":"fread()"},{"location":"help/#fwrite","text":"fwrite( , , ) Returns: 0 - If an error was produced or the data was not successfully written. 1 - If all the data was written. Description: This function allows you to write data into an file opened with the function fopen() , starting from the position indicated by the cursor of reading/writing . The file must have been opened in a write mode . The cursor is placed at the beginning of the file, when opened or created, and advances sequentially as the data is written. But this cursor can be placed in any position of the file using the function fseek() and the function ftell() allows you to obtain the current position of an file cursor. The function fwrite() requires as its first parameter the < OFFSET of the data> which must be written in the file, so, the address of memory. As second parameter is required the or total size of the data which are wanted to be written, the number of memory positions which fill these data. The length of a data can be obtained with the function sizeof() . The last parameter must be the handle or identifier of file which was obtained when the file was opened as return value of fopen() . Example program: PROGRAM example_fwrite; GLOBAL mytable[3]=11,22,33,44; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); // Writes in the file fclose(myhandle); END - This example program writes the contained data in in the file help.dat of the disk. The function fopen() is called to create it and to the function fclose() to close it once every data has been written. The opposite function to fwrite() ,that allows to read data in an file instead of write to it, is fread() . The way to use this function and its parameters is the same as fwrite() . Note: By default, the is specified as the number of simple data assuming that a simple data (a variable) fills 4 bytes of memory. So, if for example, ten data are written (indicating 10 as length), then 40 bytes of data will be written. This relation can be changed by modifying the global variable drive_size , which, by default is 4 in every program. ---See: fopen() - fread() - fseek() - drive_size","title":"fwrite()"},{"location":"help/#fseek","text":"fseek( , , ) Description: Places the cursor of reading/writing of an file at the indicated position. The function requires, first, the or identifier of the file returned by the function fopen() when opened. Then the new position where the of the file must be placed is defined. Now every future reading or writing operation which is done, will be from this position. As a last parameter the in which the new position of the cursor must be specified is indicated, can be one of the following three modes: seek_set - Position is in relation to the beginning of the file (0). seek_cur - Increment related to the current position (1). seek_end - Position is in relation to the end of the file (2). To obtain the current situation of an file cursor, the function ftell() must be used. Every reading or writing operation of an file is done automatically, so all these access functions are called sequentially (reading or writing the data one after another). Example program: PROGRAM example_fseek; GLOBAL mytable[3]=11,22,33,44; mydata; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); // Places the cursor to read the fourth data of the file (44) fseek(myhandle,3,seek_set); fread(OFFSET mydata,1,myhandle); fclose(myhandle); END - This example writes the four data items contained in mytable (11,22,33 and 44) in the file help.dat , and then, opens the file for reading and uses the function fseek() to place the cursor in the position 3 from the beginning of the file (with seek_set ). Then you can read from the fourth data item of the file, so that, when a value is read in the variable mydata this will be 44 , the fourth value of the table. Note: By default, the is specified as a number of simple data items, assuming that a simple data (a variable) fills 4 bytes of memory. If, for example, the cursor is placed in the tenth position from the beginning of the file, then the program can access the data from the fortieth byte. This relation can be changed, by modifying the global variable drive_size , which by default is 4 for every program. ---See: ftell() - fread() - fwrite() - drive_size","title":"fseek()"},{"location":"help/#ftell","text":"ftell( ) Returns: The current position of the cursor of reading/writing in an file. Description: Returns the position of the reading/writing cursor in an file, for which, the only parameter required is the or identifier of file returned by the function fopen() when the file was opened. To establish a new position for an file cursor, the function fseek() must be used. In contrast, the function, ftell() always returns the position of the cursor, related to the beginning of the file. Every reading or writing operation of an file automatically moves the cursor forward, so every access is done sequentially (reading or writing the data one after another). Example program: PROGRAM example_ftell; GLOBAL mytable[3]=11,22,33,44; midata1; midata2; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); midata1=ftell(myhandle); // Position of the cursor before writing fwrite(OFFSET mytable,4,myhandle); midata2=ftell(myhandle); // Position of the cursor after being written the data fclose(myhandle); END - This example writes the four data items contained in mytable (11,22,33 & 44) into the file help.dat . After opening the file with fopen() the position of the cursor is obtained and saved in the variable midata1 (this will be 0, the beginning of the file). Then, the four values contained in the table are written in the file and the position of the cursor is obtained again, which now is saved in midata2 (will be 4, at the end of the file, after the four written values). Finally, the file is closed with #224.fclose() before ends. Note: By default, the is specified as a number of simple data, assuming that a simple data (a variable) fills 4 bytes . So for example, if the cursor is placed in the tenth position from the beginning of the file, then the program can access the data from the fortieth byte. This relation can be changed, modifying the global variable drive_size , which by default is set at 4 for every program. Nota: The function filelength() allows you to find the length of an file, but to do this the file must already be open. ---See: fseek() - fread() - fwrite() - drive_size","title":"ftell()"},{"location":"help/#filelength","text":"filelength( ) Returns: The length of the file Description: This function obtains the length of an file already opened with fopen() , to do this you need as a parameter the or identifier of file returned by the fopen() function. This function doesn't modify the current position of the reading/writing cursor of the file, but simply returns the number of data items contained therein. Example program: PROGRAM example_filelength; GLOBAL mytable[3]=11,22,33,44; longitude; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); fwrite(OFFSET mytable,4,myhandle); fclose(myhandle); myhandle=fopen(\"help/help.dat\",\"r\"); longitude=filelength(myhandle); // Obtains the length of the file (4) fclose(myhandle); END - This example program creates first an file called help.dat , writing to it the four values contained in mytable . Once the file has been created, it will be reopened in read mode to obtain its length . Note: By default, the length of the file is obtained as the number of simple data items it contains, assuming that a simple data (a variable) fills up 4 bytes . If, for example, the length of an file is ten then it will occupy forty bytes of memory. This relation can be changed by modifying the global variable drive_size , which by default is 4 for every program. Note: The functions get_dirinfo() and get_fileinfo() allow you to obtain a lot of information about the structure of directories (folders) on the drive and about the files/files contained on it. ---See: fopen() - get_dirinfo() - drive_size","title":"filelength()"},{"location":"help/#flush","text":"flush( ) Returns: The number of opened files/files. Description: Empties the memory buffers, and ensures that all data written to a file which is still in the cache memory is saved in its correspondent file. This operation is not very necessary, because the administration of the cache that the operating system makes, is very effective and the data is not going to be lost due to not being correctly written to its corresponding file/file. But, this function has another utility. It will return the {number of files opened with} fopen() inside of a program. The file system allows just a maximum number of files to be open at once, which depends on the system's configuration. Every file must be closed with fclose() once the program has finished operating on them. This last function allows you to close just one file, or everyone which is open. Example program: PROGRAM example_flush; GLOBAL midata1; midata2; myhandle; BEGIN myhandle=fopen(\"help/help.dat\",\"w\"); midata1=flush(); // Obtains the number of opened files (1) fclose(myhandle); midata2=flush(); // Obtains the number of opened files (0) END - This example obtains on two occasions the number of files opened, with the function flush() . After the file help.dat has been opened, the function determines that there is one open file, and once closed, could be used to check that no files are still open. ---See: fopen() - fclose()","title":"flush()"},{"location":"help/#get_dirinfo","text":"get_dirinfo( , ) Returns: Number of files of the directory which coincides with the mask and the type selected. Description: This function allows you to obtain a list of the files in a directory (folder). The is required to select the type of files which must be listed. This is just a name of a partial file using jokers; for example, the mask \" . \" (must be indicated as a text between quotation marks) will select every file in the directory. You can also include in the mask, the path of the directory (if no path is defined the files of the current directory will be listed). For example, the mask \"C:\\WINDOWS\\SYS*.??E\" will select every file of the directory \"C:\\WINDOWS\" whose name starts with \"SYS\" and whose extension finishes with \"E\" . As a second parameter the must be indicated which are to be included in the list, this will be one of the following: ** _normal** - To list just the normal files. ** _hidden** - To include also all hidden files. ** _system** - To include also the system files. ** _subdir** - To include also the subdirectories. ** _volid** - To list just the label of the volume. The most common choice is to indicate _normal as the , this type covers most files, including read-only files, file files and read/write files (only some special files are excluded, which typically are internal system files). If _hidden , _system or _subdir is indicated in this parameter, these types of files will be included as well as the normal files (it's not necessary to specify _normal ). Also, you can select more than one of these types; for example, indicating _hidden+_system will list every normal file, as well as every hidden and system file. When {_volid) is indicated, just the name of the volume label of the disk will be listed, no file or subdirectory will be listed (you can't add other types to this). The function get_dirinfo() simply returns the total number of listed files; the names of these files are saved in the global structure dirinfo (the first name of the file is saved in dirinfo.name[0] , the second in dirinfo.name[1] , etc.). The total number of listed files which this function returns is saved in dirinfo.files . The list of file names is always saved in alphabetic order, but the function qsort() can be used to order the global structure dirinfo with any other criteria. This function just allows you to obtain the names of the files, to obtain further information about them (the attributes, the size, the data, etc.) the function get_fileinfo() must be used. Example program: PROGRAM example_get_dirinfo; GLOBAL counter; BEGIN write(0,0,0,0,\"List of files - Press ESC to finish\"); get_dirinfo(\"C:\\WINDOWS*.EXE\",_normal); // Obtains the list of files FOR (counter=0;counter<dirinfo.files;counter++) x=(counter%4) 80; y=16+(counter/4) 8; write(0,x,y,0,dirinfo.name[counter]); END REPEAT FRAME; UNTIL (key(_esc)); END - This example program lists every normal EXE file of the directory C:\\WINDOWS, and then shows them on screen. The loop FOR is the one that shows on screen the list of the files of the structure dirinfo in four columns, as otherwise the function get_dirinfo() doesn't show any information on screen, it just fills up the structure dirinfo with the names of the files found in the directory. To open or create a file the function fopen() can be used. To change the directory, you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to find out the free disk space on a drive. ---See: get_fileinfo() - fopen() - chdir() - mkdir() - disk_free()","title":"get_dirinfo()"},{"location":"help/#get_fileinfo","text":"get_fileinfo( ) Returns: 0 - Can't obtain any information about the file. 1 - The information about the file was saved correctly. Description: Obtains information about a file or directory on the disk, for which, the function requires the as a parameter (between quotation marks). You can either just indicate the filename, or include the path to the file as well. If the function finds the file in the specified directory (or in the current one, in the case of no directory being specified), it will return back the value 1 and will save all information about the file in the global structure fileinfo , which contains the following fields: ** fullpath** - Complete name (including the path). ** drive** - Disk drive (1-A:, 2-B:, 3-C:, ...). ** dir** - Directory of the file. ** name** - Name of the file. ** ext** - Extension of the file. ** size** - Size (in simple data, see drive_size ). ** day** - Day (data of the last access). ** month** - Month (data of the last access). ** year** - Year (data of the last access). ** hour** - Hour (hour of the last access). ** min** - Minute (hour of the last access). ** sec** - Second (hour of the last access). ** attrib** - Attributes of the file. The path to the file can be completely specified (from the main directory of the drive, as \"C:\\WINDOWS...\") or relative to the current directory (from which the game is executed, like \"MAP\\MIOS...\"). Anyhow, the complete path from the main directory will always be stored in fileinfo.fullpath , including the drive letter of the disk. The function get_fileinfo() just obtains information about a file, to obtain the complete list of files in a directory, the function get_dirinfo() must be used. Example program: PROGRAM example_get_fileinfo; BEGIN // ... get_fileinfo(\"help/HELP.FPG\"); // ... END - This small example asks for information about the file help.fpg contained in the directory help . It can be extracted and traced (with F12 ) to see how, after the call to the function, the global structure predefined as fileinfo has been filled up with information concerning the file. To open or create a file the function fopen() can be used, and to delete a file from the drive the function remove() can be used. The function disk_free() allows you to ascertain the free disk space of any drive. ---See: get_dirinfo() - fopen() - remove() - disk_free()","title":"get_fileinfo()"},{"location":"help/#getdrive","text":"getdrive( ) Returns: The number of the current drive. Description: This function allows you to determine which is the drive that is being currently used, this is returned as a number, where 1 corresponds to the drive A: , the number 2 to B: , 3 to C: , etc. There are no parameters required in the function call. The function setdrive() allows you to set the current drive; all access to the disk (reading and writing files) is always done on the selected drive which, by default, will be the drive on which the program is executed. Example program: PROGRAM example_getdrive; GLOBAL drive; BEGIN write(0,0,0,0,\"Current drive:\"); drive=getdrive(); write_int(0,0,20,0,OFFSET drive); LOOP FRAME; END END - This program shows on screen the number of the current drive obtained using the function getdrive() . To change the directory you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to ascertain the remaining free disk space on a drive. ---See: setdrive() - chdir() - mkdir() - disk_free()","title":"getdrive()"},{"location":"help/#setdrive","text":"setdrive( ) Description: This function allows you to set the current drive; all access to the disk (reading and writing files) is always done on the selected drive which, by default, will be the drive on which the program was executed. The must be indicated with a number, where the number 1 corresponds with the drive A: , the number 2 with B: , 3 the C: , etc. this function doesn't return any value. The function getdrive() allows you to obtain the number of the current drive. Example program: PROGRAM example_setdrive; GLOBAL drive; BEGIN // ... drive=getdrive(); setdrive(1); // Is placed in the drive A: // ... setdrive(drive); // Recovers the previous drive // ... END - This program first, obtains the current drive with the function getdrive() and saves it in the variable drive , then the drive is set to 1 (A:) before, finally, the drive is reset as the drive in which the program is being executed. Note: When a drive is changed with setdrive() no value is returned, but afterwards getdrive() can be called to check that the program has been placed on the correct drive. To change the directory you must use the function chdir() , and mkdir() to create a new directory. The function disk_free() allows you to ascertain the remaining free disk space on a drive. ---See: getdrive() - chdir() - mkdir() - disk_free()","title":"setdrive()"},{"location":"help/#chdir","text":"chdir( ) Returns: 1 - The indicated directory was changed. 0 - This directory can't be read. Description: Changes the current directory, on the selected drive. The directory must be indicated as a literal (text between quotation marks), and can be a relative path (from the current directory) or an absolute path (from the main directory). The ways of use and possibilities of this function are the same as the command CD that can be typed in at the command line of the operating system. Each program is placed at the beginning of the directory where the main executable is found. New directories (or folders)can be created on a disk with the function mkdir() , and with the function remove() the other directories can be eliminated. Example program: PROGRAM example_chdir; BEGIN chdir(\"MAP\"); // Is placed in the directory MAP\\ // ... chdir(\"..\"); // Comes back to the previous directory END - This small example shows how the function chdir() can be used to change the current directory. The function setdrive() allows you to set the current drive and the function getdrive() allows you to ascertain it; all access to the disk (reading and writing of files) is always done on the selected drive which, by default, will be the drive on which the program is being executed. Note: The list of a directory's files can be obtained with the function get_dirinfo() . ---See: mkdir() - remove() - setdrive() - getdrive()","title":"chdir()"},{"location":"help/#mkdir","text":"mkdir( ) Description: Creates a new directory (inside of the current directory or folder). You must indicate as a parameter the name of the directory to be created as a literal (text between quotation marks). The way of using and possibilities for this function are the same as the command MD which can be typed at the command line of the operating system. Each program is placed at the beginning of the directory where the main executable is found. You create a new directory with the function mkdir() , eliminate the other directories with the function remove() . . Example program: PROGRAM example_mkdir; BEGIN mkdir(\"temporal\"); // Creates a new directory // ... remove(\"temporal\"); END - This small program shows how the function mkdir() can be used to create a directory, and then it is deleted with the function remove() . The function setdrive() allows you to set the current drive and the function getdrive() allows you to ascertain it; all access to the disk (reading and writing of files) is always done on the selected drive which, by default, will be the drive on which the program is being executed. Note: The directory's list of files can be obtained with the function get_dirinfo() . ---See: chdir() - remove() - setdrive() - getdrive()","title":"mkdir()"},{"location":"help/#remove","text":"remove( ) Description: Deletes files or subdirectories contained inside of the current directory in which the program was executed. The must be indicated in a literal (text between quotation marks), also the joker/wild characters \"?\" and \" \" are accepted (as for example \" .bak\" to eliminate every file with the extension BAK). The files eliminated will always be inside of the current directory (see chdir() to change the directory) and on the current drive (see setdrive() to change the drive). With this function directories can also be eliminated, but only if they are empty (if there are no files or other subdirectories inside). Note: This function must be used with more caution, because the files deleted cannot be recovered, and information or programs contained on the disk can be lost . Example program: PROGRAM example_remove; BEGIN mkdir(\"temporal\"); // ... remove(\"temporal\"); // Deletes a directory END - This small example creates a directory with the function mkdir() and then eliminates it with the function remove() . Note: The directory's list of files can be obtained with the function get_dirinfo() . ---See: chdir() - setdrive() - get_dirinfo()","title":"remove()"},{"location":"help/#disk_free","text":"disk_free( ) Returns: The free disk space on the drive. Description: This function allows you to determine the free disk space of any drive. The number of the is required as the only parameter, the number 1 meaning the drive A: , 2 with B: , 3 with C: , etc. The remaining space on the drive is given in Kbs (in kilobytes, each one being a total of 1024 bytes). The current drive can be ascertained (the one where the program is being executed) thanks to the function getdrive() . Example program: PROGRAM example_disk_free; GLOBAL drive; free_space; BEGIN // ... drive=getdrive(); free_space=disk_free(drive); // ... END - This program uses first the function getdrive() to determine on which drive the program is being executed (where the variable drive )is stored on, and then determines the free disk space of that drive with disk_free() . To obtain information about the size of the files etc... you must be use the functions get_dirinfo() and get_fileinfo() . Note: The function memory_free() allows you to determine the free RAM memory, the quantity of memory that is available to run the program. ---See: getdrive() - memory_free()","title":"disk_free()"},{"location":"help/#memory_free","text":"memory_free( ) Returns: The free memory available for the program. Description: This function allows you to determine the computer's RAM memory that is available for the use of the program. No parameter is required, and the memory total is returned in Kbs (in kilobytes, each one being a total of 1024 bytes). This quantity of memory will be available for the program to load all its resources (graphics, sounds, etc.), it is useful to check with this function, at the start of a program, that the computer has enough memory to load all the necessary resources. Example program: PROGRAM example_memory_free; GLOBAL free_memory; BEGIN // ... free_memory=memory_free(); // ... END - This small example uses the function memory_free() to save the quantity of RAM available for the program in the global variable free_memory . Note: The function disk_free() allows you to determine the free disk space on a computer drive. ---See: disk_free()","title":"memory_free()"},{"location":"help/#ignore_error","text":"ignore_error( ) Description: This function allows you to ignore a specified execution error, the is required as a parameter; this is the present number in the information window of an error which appears on occasions when a program is being executed. At the beginning it is not recommended to ignore the execution errors, because the program may not work correctly, and you may need some information relative to the error to solve the problem. When a program produces an execution error, it is always for a reason; and to ignore the error will not solve the problem. Note: Not all the errors can be ignored, there are some errors which make it impossible for the program to run properly. These are the errors denoted as \"serious\", which will always cause the program to abort. Example program: PROGRAM example_ignore_error; BEGIN ignore_error(145); // To ignore the divisions by zero x=x/0; END - In this example the function ignore_error() is called to advise the system that, from now on, it should ignore all divisions by zero (these will produce an unquantifiable result). Now a division by zero is made, to check that the program doesn't emit an error message. This error number is 145 , the same as the number given with the call to the function ignore_error() of the previous example. List of codes of execution errors: 100 There is not enough memory to run the program. 101 Call to key() with a nonexistent key code. 102 The palette was not loaded, file not found. 103 An invalid palette file was loaded. 104 Too many FPG files are open at the same time. 105 The file was not loaded, file not found. 106 An invalid FPG file was loaded. 107 Number of scroll invalid (must be between 0 and 9). 108 Number of region invalid (out of range). 109 file Code invalid. 110 Code of graphic invalid. 111 An FPG file was used before it was loaded. 112 A graphic's code is needed for the scroll. 113 Too many fonts have been loaded. 114 The font was not loaded, file not found. 115 An invalid font file was loaded. 116 Identifier code of fonts invalid. 117 Code of text centre invalid. 118 There are too many blocks of text currently active in the program. 119 Identifier of text invalid. 120 Screen region is defined incorrectly. 121 Nonexistent graphic was used. 122 A block out of memory was written. 123 The file you are attempting to write to hasn't been opened. 124 Can't write to the file (check space on disk). 125 A block out of memory was read. 126 Can't open the file for reading. 127 Can't read the file. 128 Can't load the sound effect. 129 Can't play the wanted sound effect. 130 Can't start the wanted animation. 131 Number of mode 7 invalid (must be between 0 and 9). 132 A code of graphic for the mode 7 is needed. 133 Number of checkpoint invalid. 134 Number of button incorrect (must be between 0 and 3). 135 Number of axis incorrect (must be between 0 and 3). 136 Address of the palette table out of memory. 137 Can't check regions in mode 7 graphics. 138 Code of graphic information incorrect. 139 Can't check collisions in mode 7 graphics. 140 Access out of rank. 141 An invalid process was accessed.. 142 The process looks like a block, expecting FRAME. 143 Can't load the map, file not found. 144 An invalid map file was loaded. 145 A division by zero was made. 146 The size of the region is incorrect. 147 Can't load FLI/FLC animation, file not found. 148 Value of timeout incorrect (must be between 1 and 60). 149 Number of players incorrect (must be between 2 and 8). 150 Only global data can be sent . 151 Size of the square invalid (must be between 1 and 256). 152 searching Map invalid (from 1x1 to 128x128). 153 Size of the map incorrect (from 1x1 to 32768x32768). 154 Number of colour incorrect (must be from 0 to 255). 155 The centre is outside of the graphic's limits. 156 The object is outside of the map and will be eliminated. 157 Map texture not found. 158 Texture size incorrect. 159 Can't load the world, file not found. 160 Can't load the world, file not valid. 161 Flag number invalid. 162 Dispositive invalid (just 1-IPX,2-SERIAL,3-MODEM). 163 Packet size invalid (just from 1 to 199). 164 The string of text destination is invalid. 165 Null cursor was accessed. 166 The access mode to the file is invalid. 167 Can't load the module. 168 Too many ignored errors. 169 To many files opened.. 170 Identifier of file (handle) not valid. 171 Value out of rank. 172 Too many graphic objects visualised. 173 Type of graphic object is not known. 174 Percentage of link out of rank (0..15). 175 Number of graphic object invalid. 176 Error variable of type: Texture of map [a] not found in file [b]. 177 Map texture. 178 Not found in file. 179 Too many partitions of dynamic memory were made.. 180 The cursor doesn't correspond to any of the reserved blocks. 181 Can't reserve blocks of less than one position. 182 A block outside of the memory was (de)encrypted. 183 Can't load another palette when the current one is enforced. 200 file with corrupted data, can't be loaded. Note: With the compilation options (see Compiler_options ) the errors of execution can be ignored , but this practice is not recommended. ---See: Compiler_options","title":"ignore_error()"},{"location":"help/#save_map-save_pcx","text":"save_map( , , ) save_pcx( , , ) Returns: 1 - If the file was loaded successfully. 0 - While saving the file there was an error. Description: Creates a MAP or PCX file from a graphic loaded in memory. The function requires the and codes which identify the graphic, and the MAP or PCX which must be created on the disk containing that image. The name of the file must be specified as a literal (text between quotation marks, as \"image.pcx\"). Graphics loaded with the functions load_map() or load_pcx() (or created with new_map() ) will be used as if they were from the first file (the file with the code 0). The function save_map() always creates MAP files, and save_pcx() will always create PCX files, independent of the indicated extension in the . If there is no error, the function will create the file with the image and will return back the value 1 . These maps can be loaded in the graphical environment of DIV Games Studio or in the programs, using the functions load_map() o load_pcx() . Example program: PROGRAM example_save_map; BEGIN load_fpg(\"help/help.fpg\"); save_pcx(0,1,\"help/help.pcx\"); // Creates a PCX file END - This example uses the function save_pcx() to create a PCX file containing an image previously loaded inside of the file help.fpg with the function load_fpg() . A graphic can be created with the function new_map() , and to modify a graphic the following functions can be used: map_block_copy() - Transfers a block of a graphic to another. map_get_pixel() - Obtains the colour of a graphic pixel. map_put() - Puts a graphic into another. map_put_pixel() - Fixes the colour of one point in a graphic. map_xput() - Places a graphic into another, with added effects. Note: The function write_map() allows you to write text in a graphic created in memory (instead of writing it on screen). ---See: load_map/pcx() - unload_map/pcx()","title":"save_map() / save_pcx()"},{"location":"help/#sin","text":"sin( ) Returns: The sin of a given angle. Description: Calculates the sin in thousandths of the angle given as the parameter. The angles are always manipulated in thousandths of degree (see the use of angles in the language ), and the sin will be returned in thousandths of a unit as well (as a value from -1000 to 1000). For example, sin(90000) will return 1000 , because the sin of 90 degrees is 1. Example program: PROGRAM example_sin; GLOBAL angles[15]; sine[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Sins\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); sine[n] = sin(angles[n]); // The sin of the angle is calculated write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset sine[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and use the function sin() to calculate the sine of them. ---See: Expression - See: Use of the angles in the language","title":"sin()"},{"location":"help/#cos","text":"cos( ) Returns: The cosine of a given angle. Description: Calculates the cosine in thousandths of the angle given as the parameter. The angles are manipulated always in thousandths of a degree (see the use of angles in the language ), and the cosine will be returned in thousandths of a unit also (as a value from -1000 to 1000). For example, cos(0) will return 1000 , because the cosine of 0 degrees is 1. Example program: PROGRAM example_cos; GLOBAL angles[15]; cosine[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Cos\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); cosine[n] = cos(angles[n]); // The cosine of the angle is calculated write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset cosine[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and will use the function cos() to calculate the cosine of them. ---See: Expression - See: Use of the angles in the language","title":"cos()"},{"location":"help/#tan","text":"tan( ) Returns: The tan of a given angle. Description: Calculates the tangent in thousandths of the angle given as the parameter. The angles are manipulated always in thousandths of a degree (see the use of angles in the language ), and the tan will be returned in thousandths of also (as a value inside of the rank min_int ... max_int ). For example, tan(45000) will return 1000 , because the tan of 45 degrees is 1. Example program: PROGRAM example_tan; GLOBAL angles[15]; tangent[15]; n; BEGIN write(0,0,0,0,\"Angles\"); write(0,160,0,0,\"Tans\"); FROM n=0 TO 15; angles[n] = rand(0, 360000); tangent[n] = tan(angles[n]); // calculates the tan of the angle write_int(0, 0, 20+n 10, 0, offset angles[n]); write_int(0, 160, 20+n 10, 0, offset tangent[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the angles, randomly chosen between 0 and 360000 (from 0 to 360 degrees), and will use the function tan() to calculate the tangent of them. ---See: Expression - See: Use of the angles in the language","title":"tan()"},{"location":"help/#asin","text":"asin( ) Returns: The arcsine of a given sine. Description: Calculates the arcsine of the sine given as the parameter in thousandths, the corresponding angle to a sine value is obtained (opposite operation to sine, which can be obtained with the function sin() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the asin will be returned in thousandths of a degree also (as a value inside of the rank min_int ... max_int ). The is required as a value from -1000 to 1000 (from -1.0 to +1.0), and the result is returned as an angle between -90000 and 90000 (from -90 to +90 degrees). Example program: PROGRAM example_asin; GLOBAL sine[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Sin\"); write(0,160,0,0,\"Asin (angle)\"); FROM n=0 TO 15; sine[n] = rand(-1000, 1000); angles[n] = asin(sine[n]); // calculates the arcsine of a sine write_int(0, 0, 20+n 10, 0, offset sine[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of sines, randomly chosen between -1000 and 1000 (represented in thousandths), and will use the function asin() to calculate the arcsine of these values. ---See: Expression - See: Use of the angles in the language","title":"asin()"},{"location":"help/#acos","text":"acos( ) Returns: The arccos of a given cos. Description: Calculates the arccos of the cosine given as the parameter in thousandths, the corresponding angle to a cosine is obtained (inverse operation to the cosine, which can be obtained using the function cos() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the acos also returns values in thousandths (as a value inside of the rank). The is required as a value from -1000 to 1000 (from -1.0 to +1.0), and the result is returned as an angle between ** -90000 and 90000** (from -90 to +90 degrees). Example program: PROGRAM example_acos; GLOBAL cosine[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Cos\"); write(0,160,0,0,\"Acos(angle)\"); FROM n=0 TO 15; cosine[n] = rand(-1000, 1000); angles[n] = acos(cosine[n]); // The acos of a cos is calculated write_int(0, 0, 20+n 10, 0, offset cosine[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the sins, randomly chosen between -1000 and 1000 (represented in thousandths), and will use the function acos() to calculate the asin of them. ---See: Expression - See: Use of the angles in the language","title":"acos()"},{"location":"help/#atan","text":"atan( ) Returns: The arctan of a given tangent. Description: Calculates the arctan of the tan given as a parameter in thousandths, the corresponding angle to a tan is obtained (inverse operation to the tan of an angle, which can be obtained with the function tan() ). The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the arctan will be returned in thousandths of a degree also. The is required as a value inside of the rank min_int ... max_int (from -inf to +inf), and the result is returned as an angle between -90000 and 90000 (from -90 to +90 degrees). Note: There is another function to calculate the arctan called atan2() , this function takes as its parameters the values and and returns the arctan of y/x between -180000 and 180000 (of -180 to 180 degrees). Example program: PROGRAM example_atan; GLOBAL tangent[15]; angles[15]; n; BEGIN write(0,0,0,0,\"Tan\"); write(0,160,0,0,\"Atan(angle)\"); FROM n=0 TO 15; tangent[n] = rand(-1000, 1000); angles[n] = atan(tangent[n]); // The arctan of a tan is calculated write_int(0, 0, 20+n 10, 0, offset tangent[n]); write_int(0, 160, 20+n 10, 0, offset angles[n]); END write(0,0,192,0,\"Press ESC to finish ...\"); REPEAT FRAME; UNTIL (key(_esc)); END - This program will print on screen a list of the tans, randomly chosen between -1000 and 1000 and use the function atan() to calculate the arctan of them (between -45 and 45 degrees). ---See: Expression - See: Use of the angles in the language","title":"atan()"},{"location":"help/#atan2","text":"atan2( , ) Returns: The arctan of / . Description: Calculates the arctan of the tan obtained as the division of the two values, given as the parameter ( / ), the angle corresponding to arctan (inverse operation to the tan of an angle, which can be obtained with the function tan() ) is obtained. The angles are always manipulated in thousandths of a degree (see the use of angles in the language ), and the arctan is also returned in thousandths as a value between -180000 and 180000 (from -180 to +180 degrees). Note 1: Another function exists to calculate the arctan called simply atan() , this function takes as its only parameter the tan of an angle and returns its arctan between -90000 and 90000 (from -90 to 90 degrees). Note 2: There is also a version of atan2() , which is more simply adapted to the geometric concepts; it is the function denoted as fget_angle() which obtains directly the angle between two points. ---See: Expression - See: Use of angles in the language","title":"atan2()"},{"location":"help/#draw","text":"draw( , , , , , , , , ) Returns: The identifier of the primitive graphic painted. Description: This is a generic function able to draw some primitive graphics on screen (such as lines, boxes and circles). The following parameters must be indicated: - Type of primitive graphic, as one of the following: 1 - Straight line. 2 - Rectangle. 3 - Filled rectangle. 4 - Ellipse. 5 - Filled ellipse. - colour of the ink with which the primitive will be drawn (from 0 to 255 , as a colour of the palette). - Level of opacity of the primitive, from 0 to 15 (to allow for transparency effects). - Number of region (window inside of the screen) where the primitive can be painted ; normally this value will be 0 to print the primitive in any position of the screen. To define a region on the function define_region() must be used. , - Starting point of the straight line, or the upper left corner of the box which contains the rectangle or ellipse. , - End point of the straight line, or the lower right corner of the box which contains the rectangle or ellipse. When a primitive graphic is painted with draw() this will remain fixed on screen until it is moved with the function move_draw() , or eliminated with the function delete_draw() . The identifier of the primitive returned by the function draw() will be necessary in order to move or delete the primitive. The representation system of these graphic primitives is quite similar to the system for texts; texts are painted with write() and will remain fixed until they are moved with move_text() or eliminated with delete_text() . Note: The level of impression or depth of the primitive graphics can be controlled with the predefined global variable draw_z . Example program: PROGRAM example_draw; GLOBAL counter; types; colour; opacity; x0,y0; x1,y1; BEGIN write(0,0,0,0,\"Press ESC to finish ...\"); REPEAT FROM counter=1 TO 10; types=rand(1,5); colour=rand(0,255); opacity=rand(0,15); x0=rand(0,319); y0=rand(0,199); x1=rand(0,319); y1=rand(0,199); // Paints a primitive graphic draw(types,colour,opacity,0,x0,y0,x1,y1); END FRAME; delete_draw(all_drawing); UNTIL (key(_esc)); END - This example program draws on screen 10 primitive graphics whose characteristics are selected randomly with the function rand() , and after creating an image with FRAME , it then deletes them with the function delete_draw() . The process is repeated until the ESC key is pressed. Note: a maximum of 256 primitive graphics can be represented on the screen at the same time. ---See: move_draw() - delete_draw() - draw_z","title":"draw()"},{"location":"help/#delete_draw","text":"delete_draw( ) Description: Deletes a primitive graphic which has been painted with the function draw() , for which the is required as a parameter, which is the numeric code which was returned when it was painted. If all_drawing is specified as a parameter the function will delete every primitive graphic represented on screen, the identifier is only necessary in the case of wanting to eliminate a particular primitive graphic. Example program: PROGRAM example_delete_draw; PRIVATE id_draw; types; colour; opacity; x0,y0; x1,y1; BEGIN write(0, 160, 8, 1, \"[ENTER] To show a primitive / [SPACE] to delete it\"); draw(2,127,15,0,0,0,319,199); LOOP types=rand(1,5); colour=rand(0,255); opacity=rand(0,15); x0=rand(0,319); y0=rand(0,199); x1=rand(0,319); y1=rand(0,199); id_draw=draw(types,colour,opacity,0,x0,y0,x1,y1); WHILE (NOT key(_space)) FRAME; END delete_draw(id_draw); // We delete the graphic WHILE (NOT key(_enter)) FRAME; END END END - In the previous example, a primitive is painted on screen, then the program waits for the space bar to be pressed, at which moment the primitive is deleted and then when the ENTER key is pressed the program repeats the loop. This is the second primitive, which identifier has been saved in the variable id_draw (the first primitive is the rectangle which has the same size as the screen and is painted with the first call to the function draw() of the program). To delete every primitive graphic call the function delete_draw(all_drawing); , the parameter all_drawing will also eliminate the rectangle. Note: The characteristics of a graphic primitive presented on screen (position, colour, opacity and size) can be modified with the function move_draw() . ---See: draw() - move_draw()","title":"delete_draw()"},{"location":"help/#move_draw","text":"move_draw( , , , , , , ) Description: Modifies a primitive graphic which has been painted with the function draw() , to do this, the following parameters are required: - Is the numeric code which was returned by the function draw() when the primitive graphic was painted and which is now wanted to be modified. - colour of ink for the primitive (from 0 to 255 , as a colour of the palette). - Level of opacity of the primitive, from 0 to 15 (to allow for transparency effects). , - Initial point of the straight line, or the upper left corner of the box which contains the rectangle or ellipse. , - Final point of the straight line, or the lower right corner of the box which contains the rectangle or ellipse and the screen coordinates ( x , y ) where it must be moved to. Example program: PROGRAM example_move_draw; PRIVATE id_draw; colour; opacity; BEGIN write(0, 0, 0, 0, \"Move the mouse ...\"); id_draw=draw(4, 127, 15, 0, 0, 0, 32, 32); LOOP colour=rand(0,255); opacity=rand(0,15); // The graphic primitive is moved to the mouse coordinates move_draw(id_draw, colour, opacity, mouse.x-16, mouse.y-16, mouse.x+16, mouse.y+16); FRAME; END END - In the example a circular primitive graphic is painted with the function draw() , and its identifier of graphic primitive is saved in the global variable id_draw . Then, inside of a loop, the function move_draw() will be used to place the circle at or near the mouse coordinates, and assign a randomly chosen colour and opacity to each image. Note: To eliminate (delete) a primitive graphic the function delete_draw() is used, and with the predefined global variable draw_z the priority of impression of them can be handled . ---See: draw() - delete_draw() - draw_z","title":"move_draw()"},{"location":"help/#write_in_map","text":"write_in_map( , , ) Returns: The created code of the graphic containing the text. Description: Creates a new map in memory (without loading it on disk, very similar to the function new_map() ), and writes in the map some text which characteristics are described with the following parameters: - The code of the font or type of letter which is going to be used. Here a 0 must be placed when you want to use the system font (font of white colour, small, of 6 to 8 points), or the code of font returned by the function load_fnt() when a new font is loaded in the program. - specify the text to be written as a literal, as text between quotation marks (see the delimitation symbols of literals ). - This code value determines where the centre of the text will be placed on the checkpoint of the created map. its possible values are: 0 -Up left 1 -Up 2 -Up right 3 -Left 4 -centre 5 -Right 6 -Down left 7 -Down 8 -Down right The text will always be fitted in a new map of the same dimensions, but this checkpoint will specify which point of the map will centred on the coordinates where it will then be placed. This function works practically the same as load_map() , but instead of reading a file on the disk which contains the graphic it creates a graphic which contains a written message. The code of the graphic is given as the return value, which is a numeric value which must be specified in order to use the graphic in the variable graph or, in any function which requires a code of graphic as its parameters. When the code of file which belongs to the graphic is wanted inside of a function the code 0 must be indicated (which is the code of the first file FPG which is loaded in the program). Example program: PROGRAM example_write_in_map; GLOBAL mi_font; BEGIN mi_font=load_fnt(\"help/help.fnt\"); // A new map is created with the text \"MOUSE\" // with the checkpoint in the centre, and is // assigned as the graphic of the mouse cursor. mouse.graph = write_in_map(mi_font,\"MOUSE\",4); REPEAT FRAME; UNTIL (key(_esc)); unload_map(mouse.graph); END - In the example a font is loaded with the function load_fnt() , and then a map is created with the function write_in_map() , saving the code of the graphic which is returned in the variable mouse.graph , so it will appear as the mouse cursor. The new map is created with the message \"MOUSE\" written with the font help.fnt , and its main checkpoint is placed in the centre (with the code 4 ). Pressing the ESC key will bring you out of the loop and the program will delete the graphic with the function unload_map() (exactly the same as if it were a file loaded from the drive). But, it is not necessary to delete the graphic from memory before finishing the program, because the system will do it automatically. The main advantage of the function write_in_map() is to be able to work with texts as if they were graphics, so they can be rotated, scaled, printed with transparency effects, etc... Note: write_in_map() can show a numeric value if used with the function itoa() , which allows you to convert a numeric value into a string of text. ---See: write() - unload_map/pcx() - graph - itoa()","title":"write_in_map()"},{"location":"help/#calculate","text":"calculate( ) Returns: The result of the numeric expression. Description: Allows you to convert a literal (or text between quotation marks), which contains a number or numeric expression, to a constant value which can be assigned to any data. Allows you to convert some text into a number; for example, the statement x=calculate(\"234\"); will assign the value 234 to the variable x (exactly the same as with the statement x=234; ). The function itoa() allows the opposite operation, to convert a number into text. But also, the function calculate() can evaluate an expression, contained in the text with some operators, that can be the following (all the symbols accepted by each operator are indicated): ** + -** Addition and substraction. ** * /** Multiplication and division. ** % MOD** Modulus, or rest of an entire division. ** < <<** Binary rotation to the left. ** > >>** Rotation to the right. ** ^ ^^ XOR** OR binary exclusive. ** | || OR** OR binary. ** & && AND** AND binary. ** ! NOT** Binary negation. ** SQRT** Square root. Parentheses ( ) can also be used the to indicate priorities inside of the calculation of the expression. For example, calculate( \"(2+3) 4\" ) would return the value 20 * as a result. Note: The operation of this function is very similar to the window of the calculator ( System\\Calculator ) of the windows environment. Example program: PROGRAM example_calculate; GLOBAL STRING calculation; result; BEGIN write(0,0,0,0,\"Introduce an expression:\"); write(0,0,10,0,calculation); write(0,0,30,0,\"Result:\"); write_int(0,0,40,0,OFFSET result); LOOP SWITCH(ascii) CASE 8: calculation--; END CASE 27: calculation=\"\"; END CASE 0..31: END DEFAULT: calculation+=ascii; END END result = calculate(calculation); // Evaluates the calculation IF (timer MOD 100>50) calculation+=\"_\"; ELSE calculation+=\" \"; END FRAME; calculation--; END END - This example program allows you to introduce an expression to a string of text (See STRING ) and then evaluates it with the function calculate() to show the result of the same string. Note: if an error is produced in the evaluation of the expression (for example, if there exists any parenthesis which are not closed again), the function will return 0 as its result. ---See: itoa() - write() - STRING","title":"calculate()"},{"location":"help/#itoa","text":"itoa( ) Returns: A string of text containing the result. Description: This function is used to convert a numeric value or into a string of text, that allows you to convert a number into text. The string will have as many types as digits has the result. The function calculate() allows the opposite operation; to convert a literal or string of text into a numeric value. Example program: PROGRAM example_itoa; GLOBAL STRING message; BEGIN load_fpg(\"help/help.fpg\"); mouse.graph=200; write(0,0,0,0,message); REPEAT // It makes a message with text and numbers using itoa() message = \"Cursor of the mouse in (\" + itoa(mouse.x) + \",\" + itoa(mouse.y) + \").\"; FRAME; UNTIL (key(_esc)); END - This example program creates a string of text called message (see STRING ) letters and numeric values (the coordinates of the mouse, see mouse ), and it is represented on screen with the function write() . The program loads the file help.fpg with load_fpg() and assigns the graphic 200 as the cursor of the mouse. The program will continue until the ESC key is pressed. Note: The name of the function itoa() , that comes from the C language, comes from the expression \"integer to ascii\". And the function that does the opposite operation, \"ascii to integer\" is called calculate() . ---See: Calculate() - Arithmetic expressions - Write()","title":"itoa()"},{"location":"help/#change_channel","text":"change_channel( , , ) Description: This is a complementary function to change_sound() , which modifies the properties of one of the sound channels which plays back the digital sound effects (See sound() ) or music modules (See song() ). The number which is wanted to be adjusted must be indicated, (normally the channel number returned by the function sound() ), and the two following values: - Is given as the volume of the channel, between 0 and 512 , independent of the volume of the sound and the general volume level. When the volumes of the different channels are too loud the sound will be distorted, so it is recommended to modify the volume of the sound effects through the function change_sound() which, also allows you to adjust the frequency of the sound. - Is the \"panning\" or difference of volume between the left speaker and the right one, it must be a value between 0 and 255 . Note: The general levels of volume can be adjusted with the global structure setup (digital sound, cd-audio and general volume). Example program: PROGRAM example_change_channel; PRIVATE balance=128; // volume level (0..256) id_sound; channel_id; BEGIN load_fpg(\"help/help.fpg\"); put_screen(0, 1); id_sound = load_pcm(\"help/help.pcm\", 1); channel_id = sound(id_sound, 256, 256); write(0, 160, 0, 1, \"Press right or left to change the balance.\"); write_int(0, 160, 10, 1, offset balance); LOOP // Changes the balance of the channel change_channel(channel_id, 50, balance); IF (key(_right) AND balance<255) balance++; END IF (key(_left) AND balance>0) balance--; END FRAME; END END - In the example a sound (contained in the file help.pcm )is loaded and played. Inside of the program's main loop the channel balance through which the sound with the function change_channel() is being played , can be changed using the cursor keys. Note: See also the global predefined table in the predefined global table channel , that indicates which of the sound channels are being used. ---See: change_sound() - sound() - song() STRUCT setup","title":"change_channel()"},{"location":"help/#malloc","text":"malloc( ) Returns: The OFFSET of the memory block asked, or 0 if the memory available is not enough. Description: This function assigns dynamic memory, or a new block of free memory if required, to the program. the of the memory block to be occupied is required as a parameter. This length is specified as a number of simple data blocks, each one of them taking up 4 bytes of memory; for example, if a block of length 100 is required then 400 bytes of memory will be put aside. A max number of 256 blocks can be requested inside of a program, irrespective of its size, the function free() allows you to liberate these memory blocks. Normally the OFFSET (memory address) returned by the function malloc() is assigned to a data of type pointer (See POINTER ). Example program: PROGRAM example_malloc; GLOBAL POINTER mytable[1000]; // pointer of a table of 1000 data counter; BEGIN mytable = malloc(1000); // Asks for 1000 memory positions FOR (counter=0;counter<1000;counter++) // Accesses the data mytable[counter]=-1; END free(mytable); // Liberates the memory occupied by the table END - This small example shows how a pointer to the table can be defined (the pointer contains none of the data of the table, just a handle to the table itself), and to assign memory to this pointer with the function malloc() . Once the memory is assigned to the table of data, the program accesses them (they are initiated to -1, as an example), and finally frees up the memory. The memory blocks which are not liberated with the function free() , will be liberated automatically by the system when the program has finished. Note: the quantity of available memory for the processing of program data (local and private data) can be controlled with the compilation options (See Compiler_options ). ---See: free() - POINTER","title":"malloc()"},{"location":"help/#free","text":"free( ) Description: Liberates a block of dynamic memory which has been reserved previously with the the function malloc() the OFFSET or memory address in which the block starts is required as a parameter, which is the value obtained when it is reserved. The memory blocks not liberated with the function free() , will be liberated automatically by the system when the program ends. Example program: PROGRAM example_free; GLOBAL POINTER mytable[1000]; // Pointer of a table of 1000 data counter; BEGIN mytable = malloc(1000); // Asks for 1000 positions of memory FOR (counter=0;counter<1000;counter++) // Accesses to the data mytable[counter]=-1; END free(mytable); // Liberates the memory filled up by the table END - This small example shows how a pointer to a table can be defined (the pointer contains none of the data of the table, just a handle to the table itself), memory assigned to this with the function malloc() . Once the memory is assigned to the table of data, the program accesses them (they are initiated to -1, as an example), and finally frees up the memory. ---See: free() - POINTER","title":"free()"},{"location":"help/#encode","text":"encode( , , ) Description: encrypt or un-encrypts a block of data in memory with a determined clue. The necessary parameters are the following: - Memory address in which starts the block which must be compressed, to obtain this address the operator OFFSET must be used. - Length of the data to be compressed, the number of positions of memory, filled up for the same, the length of any data can be obtained with SIZEOF() . - A literal (text between quotation marks) with the clue of encryption or decryption of the data. The algorithm is reversible so, to decrypt the data, simply you must to encrypt them with the same clue. The algorithm of encryption is very complex, so, any encrypted data with a clue just can be recovered applying to it the same clue again. Example program: PROGRAM example_encode; CONST password=\"mypass\"; GLOBAL table_original[14] =0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; table_encrypted[14]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; counter; BEGIN write(0,0, 0,0,\"Original values\"); write(0,160,0,0,\"encrypted values\"); write(0,0,190,0,\"[SPACE] to encrypt/decrypt the values\"); // encrypts the values of the second table encode(OFFSET table_encrypted,sizeof(table_encrypted),password); FOR (counter=0;counter<15;counter++) write_int(0,0, 20+counter 8,0,OFFSET table_original[counter]); write_int(0,160,20+counter 8,0,OFFSET table_encrypted[counter]); END LOOP IF (scan_code==_space) // encrypts and decodes of values of the second table encode(OFFSET table_encrypted,sizeof(table_encrypted),password); END FRAME; END END - This program has defined two tables of global data both with the same values and allows, pressing the space bar , to encrypt and decrypt one of the two tables (the denominated table_encrypted[] ). It can be seen how, when the data are encrypted a second time they are recovered in its original state. If a different clue is used, the result will be completely different. Note: There are other two functions which allow to encrypt and decrypt any kind of file, in this case must be used a function to each operation: encode_file() to encrypt and decode_file() to decrypt. ---See: encode_file() - decode_file()","title":"encode()"},{"location":"help/#encode_file","text":"encode_file( , ) Description: encrypts one or more files of the disk with a pre-determined clue. The necessary parameters are the following: - Description of a file which must be encrypted, a literal (text between quotation marks) with the name of the file. You can use the joker characters \"?\" and \" \" in the specifying of these files (for example, \" .BAK\" to encrypt every file with extension BAK). - A literal containing the clue of encryption of the file or files. The encryption algorithm is quite complex, but any encrypted file with a clue can be recovered simply by applying the same clue to it with the function decode_file() . If this function is not called, the resulted file will be completely useless, being impossible to recover the data contained in it. Files which are already encrypted cannot be encrypted a second time. Example program: PROGRAM example_encode_file; CONST password=\"mypass\"; GLOBAL mytable[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; BEGIN save(\"help/help.enc\",OFFSET mytable,sizeof(mytable)); encode_file(\"help/help.enc\",password); // encrypts the file END - This small program uses the function save() to create a file called help.enc with the data contained in mytable , and then the program encrypts it with the function encode_file() . You can see how the contents of the created file (inside of the directory help/ ) doesn't bear any relation to the original data (independent of what the encryption clue is). There is another function called encode() which allows you to encrypt and decrypt data in memory, in this case the operation is reversible, so the same function is used for both operations. Note: The functions compress_file() and uncompress_file() allow you to compress and uncompress files of the disk. The encrypted files cannot be compressed with the functions (as their contents are randomly organised). ---See: encode() - decode_file() - compress_file() - uncompress_file()","title":"encode_file()"},{"location":"help/#decode_file","text":"decode_file( , ) Description: Decodes one or more files on the disk, that share the same clue as the one they were encrypted with using the function encode_file() . The necessary parameters are the following: - Description of a file which must be unencrypted, a literal (text between quotation marks) with the name of the file. You can use the joker characters \"?\" and \" \" in the specifying of these files (for example, \" .BAK\" to decrypt every file with extension BAK). - A literal specifying the clue of encryption for the file or files. This clue must be exactly the same as the clue that the files were originally encrypted with, if {they are unencrypted with a different clue, the files will remain indecipherable}. The files unencrypted cannot be unencrypted again. Example program: PROGRAM example_decode_file; CONST pass=\"mypass\"; GLOBAL mytable[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14; BEGIN save(\"help/help.enc\",OFFSET mytable,sizeof(mytable)); encode_file(\"help/help.enc\",pass); // ... decode_file(\"help/help.enc\",pass); // decodes the file END - This small program uses the function save() to create a file called help.enc with the data contained in mytable , and is encrypted with the function encode_file() . Before the program finishes the contents of the file are recovered again using the function decode_file() which decodes the data. The file will be returned to its original form. The function encode() allows you to encrypt and decode data in memory, but in this case, the operation is reversible, so the same function is used for both operations. Note: the functions compress_file() and uncompress_file() allow you to compress and uncompress files on the disk. The files encrypted cannot be compressed with these functions (due to its content being completely randomly organised). ---See: encode_file() - encode() - compress_file() - uncompress_file()","title":"decode_file()"},{"location":"help/#compress_file","text":"compress_file( ) Description: Compresses one or more files of the disk, the only parameter required is the which must be compressed, as a literal (text between quotation marks). The joker characters \"?\" & \" \" can be used to specify some files (for example, \" .BAK\" to compress every file with the extension BAK). To uncompress these files the function uncompress_file() must be used. The format of file encryption is a format specific to DIV Games Studio, so it can't be uncompressed with any other external utility program. The file will be saved compressed with the same name and extension as the original. Files already compressed cannot be compressed a second time. Example program: PROGRAM example_compress_file; GLOBAL counter; mytable[999]; BEGIN FOR (counter=0;counter<1000;counter++) mytable[counter]=counter; END save(\"help/help.cmp\",OFFSET mytable,sizeof(mytable)); compress_file(\"help/help.cmp\"); // Compress the file. END - This small program uses the function save() to create a file called help.cmp with the data contained in mytable , this being a group of consecutive numbers from 0 to 1000. Once created, the file is compressed with the function compress_file() . In this case, the original size of the file is 4000 bytes (1000 blocks of data), and the size of the compressed file is 1441 bytes (36% of the original size). Note: the functions encode_file() and decode_file() allow you to encrypt and decode files on the disk. The files encrypted with these functions can't be compressed due to their being content completely randomly organised. But, {the files compressed can be encrypted}. ---See: uncompress_file() - encode_file() - decode_file()","title":"compress_file()"},{"location":"help/#uncompress_file","text":"uncompress_file( ) Description: Uncompresses one or more files on the disk, previously compressed with the function compress_file() , the only parameter required is the which must be uncompressed, as a literal (text between quotation marks). The joker characters \"?\" & \" \" can be used to specify some files (for example, \" .BAK\" to uncompress every file with extension BAK). The format of file encryption is a format specific to DIV Games Studio, so it can't be uncompressed with any other external utility program. The file will be uncompressed with the same name and extension as the one compressed. Files not compressed with the function compress_file() can't be uncompressed using this function. Example program: PROGRAM example_uncompress_file; GLOBAL counter; mytable[999]; BEGIN FOR (counter=0;counter<1000;counter++) mytable[counter]=counter; END save(\"help/help.cmp\",OFFSET mytable,sizeof(mytable)); compress_file(\"help/help.cmp\"); // Compress an file // ... uncompress_file(\"help/help.cmp\"); // Uncompress the file load(\"help/help.cmp\",OFFSET mytable); END - This small example uses the function save() to create a file called help.cmp using the data contained in mytable , this being a group of consecutive numbers from 0 to 1000, then the file is compressed with the function compress_file() . Once the compressed file has been created, it is then uncompressed with the function uncompress_file() and is again loaded over the original table using the function load() . Note: the functions encode_file() and decode_file() allow you to encrypt and decode files of the disk. The encrypted files, generated with these functions cannot be compressed due to their contents being completely randomly organised. But, the compressed files can be encrypted . ---See: compress_file() - encode_file() - decode_file()","title":"uncompress_file()"},{"location":"help/#find_color","text":"find_color( , , ) Returns: The colour number in the palette. Description: Finds the colour from the current palette nearest to the indicated colour. the desired colour must be specified in the palette using the three component RGB system of colour coding, that is (red), (green) and (blue), all of them being expressed as values between 0 and 63. the number of colour of the palette which is the nearest to the indicated component colours, will be given as the return value of the function. For example, if the program calls a function like find_color(63,63,0) , it will return the colour number of the palette which is the nearest to or identical to this colour, namely yellow . Note: the function find_color() doesn't modify the current palette , it just searches for the defined colours in the palette, to modify a colour of the palette the function set_color() must be used. Example program: PROGRAM example_find_colour; GLOBAL; blue; green; yellow; red; BEGIN blue=find_color(0,0,63); // Search for the colour blue green=find_color(0,63,0); // Search for the colour green yellow=find_color(63,63,0); // Search for the colour yellow red=find_color(63,0,0); // Search for the colour red draw(2,blue,15,0,0,0,79,79); draw(2,green,15,0,80,0,159,79); draw(2,yellow,15,0,160,0,239,79); draw(2,red,15,0,240,0,319,79); LOOP FRAME; END END - This example uses the function find_color() to define the colours blue , green , yellow and red inside of the palette, and then using the function draw() , shows four squares of these colours. The advantage of using this system is that it doesn't matter if the program changes the current palette, because the same colours can always be found. To modify the whole palette, the file must be loaded with the function load_pal() . To create other palette effects, the function roll_palette() can be used, which allows you to create cycles of colour, or the function fade() which allows you to create multiple fades and saturations of colour at different speeds. ---See: set_color() - roll_palette() - load_pal()","title":"find_color()"},{"location":"help/#load_screen","text":"load_screen( ) Description: Loads an image file MAP or PCX into the background of the screen. If the graphic is a different size (in pixels) to the screen size the graphic will be printed centred on the screen. To delete the screen background the function clear_screen() must be used. It is a function that combines three actions into one: 1 - To load a file which contains a map with the background image (using the function load_map() or load_pcx() ). 2 - To establish the image as the background (using put_screen() ). 3 - To delete the previous image file from memory (with unload_map() or unload_pcx() ) Example program: PROGRAM example_load_screen; BEGIN load_screen(\"help/help.map\"); LOOP FRAME; END END - In the example the background image contained in the file help.map is loaded with the function load_screen() . Note: If you want to print a graphic on a solid part of the screen or region which is not centred , then use the function put() in conjunction with it. The function xput() allows, you to print graphics rotated, scaled, mirrored and/or transparent on any region of the screen. ---See: load_map/pcx() - put_screen() - unload_map/pcx()","title":"load_screen()"},{"location":"help/#force_pal","text":"force_pal( ) Description: Loads a colour palette (a file of type PAL, FPG, MAP, PCX or FNT) and establishes it as the obligatory palette for all the graphics and fonts which are loaded thereafter. The functioning is very similar to load_pal() (which simply loads and activates a palette) but, once the palette has been loaded with force_pal() , every map, file and font loaded afterwards {will adapt automatically to the current palette}. The graphics already loaded before force_pal() was called {won't be adapted}, and as such, if all the graphics are wanted to be seen with a unique palette, this function must be called at the beginning of the program. It is important to note that the maps, files & fonts will just adapt in the computer's memory, the original files remain unaltered, each one with their own palette. Note: To stop adapting the loaded graphics to the unique palette, the function force_pal(0) must be called (indicating a 0 as its parameter, instead of the name of a file. Example program: PROGRAM example_force_pal; BEGIN force_pal(\"help/help.pal\"); // Now all the files, maps and fonts can be loaded // which are wanted, irrespective of their own palette, to be adapted // automatically to the current palette. // ... END - This small example shows how all the graphics can be forced to just one palette inside of a program by calling force_pal() at the beginning of program execution. A palette can't be deleted from the computer's memory, because this doesn't take up any space in memory. ---See: load_pal()","title":"force_pal()"},{"location":"help/#insufficient-memory","text":"There is not enough memory to compile the program.","title":"Insufficient memory."},{"location":"help/#ltobjdef-was-not-found","text":"The file has not been found in the DIV directory; this file is indispensable to compile the programs. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"ltobj.def was not found"},{"location":"help/#invalid-ltlexdef-file","text":"The changes made in the file are invalid . Recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"Invalid ltlex.def file."},{"location":"help/#invalid-ltlexdef-file_1","text":"Too many symbols have been defined in the file. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"Invalid ltlex.def file."},{"location":"help/#invalid-ltlexdef-file_2","text":"An invalid symbol has been defined in the file. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"Invalid ltlex.def file."},{"location":"help/#ltobjdef-was-not-found_1","text":"The file has not been found in the DIV directory; this file is indispensable to compile the programs. Recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"ltobj.def was not found"},{"location":"help/#invalid-ltobjdef-file","text":"The changes made in the file are invalid . Therefore, you must recover the original file if you have a copy. Otherwise, you will have to reinstall the application.","title":"Invalid ltobj.def file."},{"location":"help/#unknown-character","text":"A character that does not belong to any symbol of the language and that, moreover, is not valid to create a new name was found in the program. If it is a comment it is necessary to indicate it correctly with a symbol // at the beginning of the comments of a line, or the symbols / and / to indicate the beginning and the end, respectively, of comments occupying more than one line. If you intend to create a name you must replace that character by another one among the characters allowed by the language. ---See: Syntax - Comments","title":"Unknown character."},{"location":"help/#unclosed-literal","text":"Literals are texts in inverted commas . In the indicated position of the program, a literal starts but it is not closed. All the literals must be closed in the same line as they started. It is not possible to define literals occupying more than one line. The literals may start and finish with the character [ ' ] (but they have to start and finish with the same character). There are two ways to include the character [ \" ] in a literal, supposing that the aim is to define a literal containing the text: a\"B\"c Duplicating the character: \"a\"\"B\"\"c\" Defining it with the simple inverted comma: 'a\"B\"c' It happens the same regarding the character [ ' ]. ---See: Syntax","title":"Unclosed literal."},{"location":"help/#unknown-symbol","text":"In the indicated position of the program there is a symbol that does not belong to the language. Check the symbols available in the language to construct the expression correctly. It is probably a typographic mistake; check the syntax. ---See: Syntax","title":"Unknown symbol."},{"location":"help/#expecting-for-program","text":"All the programs must start with the reserved word PROGRAM followed by the program name. Before this word, only can appear comments (explanatory texts preceded by the symbol // or between the symbols / and /) or the compilation options . Check if the word has been correctly written, as no difference is made between uppercase and lowercase letters. Therefore, PROGRAM , program , Program , ... are valid words. Example: // ------------------- // Listing of my game // ------------------- PROGRAM my_game; BEGIN LOOP FRAME; END END - ---See: Syntax - Comments - Program's head","title":"expecting for [PROGRAM]"},{"location":"help/#expecting-for-the-programs-name","text":"expecting for the program's name to come after the reserved word PROGRAM . Example: PROGRAM program_name; BEGIN //... END - The name of this program is program_name . ---See: Syntax - Names - Program's head","title":"expecting for the program's name."},{"location":"help/#the-name-is-not-new","text":"As a name of the structure, it has been used a name that had already been given to another object previously defined. It can be a name, a constant, a variable, a table, a structure, a process or a function of the program. It is also possible that you have intended to use the same name inside the program to identify two different objects, or that a predefined name has been used for another use inside the language . In that case, it is possible to access the glossary to see which is the object that this name is referred to. Anyhow, that name must be replaced by another similar one . Example: PROGRAM program_name; GLOBAL position=0; STRUCT position[9] // Error: The name is not new. x, y; END BEGIN //... END - ---See: Syntax - Names - Glossary","title":"The name is not new."},{"location":"help/#expecting-for","text":"To define a table, its length is normally indicated in square brackets. If the number of elements of the table is not specified in square brackets, it is necessary to wait for it to be initialised so that the compiler can determine its length. A table without a defined length has been found. Thus, after the square brackets ( [] ) have been closed, the compiler was expecting for the symbol = to precede the initialisation of the table. Indicate the length of the table in square brackets, or assign values to the different positions of the table. When a table is not initialised, all its positions will be initialised at zero. Example: PROGRAM program's_name; GLOBAL table1[3]; table2[]=2, 4, 6, 8; table3[]; // Error: expecting for [=]. BEGIN //... END - In the example, two tables of four positions (0..3), table1 initialised at (0, 0, 0, 0) and table2 initialised at (2, 4, 6, 8) have been defined. ---See: Syntax - Declaration of table","title":"expecting for [=]"},{"location":"help/#expecting-for_1","text":"The compiler was expecting for a bracket previously open with the symbol ) ) to be closed at the indicated position. This error normally appears for one of the two following reasons: In an expression, several brackets have been opened and then some of them have not been closed. In this case, the opened brackets must be closed. Inside an expression in brackets, any operator has been omitted, then appearing two operands in a row, for instance, (2*3 4) . In this case, it is necessary to indicate the lacking operator. ---See: Syntax","title":"expecting for [)]"},{"location":"help/#expecting-for_2","text":"The compiler was expecting for a square bracket previously opened, with the symbol []](#]) to be closed in the indicated position. This error normally appears for one of the following reasons: The opening of a square bracket ( [ ) has been indicated in a table or structure and, after having indicated its length or index, it has not been closed. In this case, the symbol ] must be added in the indicated position. On indicating the index of a table or structure, any operator has been omitted, then appearing, two operands in a row, for instance table[2*3 4] . It is necessary now to indicate the lacking operator. ---See: Syntax","title":"expecting for []]"},{"location":"help/#an-operand-was-waited-for","text":"The indicated position in the program is inside the context of an expression and, at this point of the expression, an operand (a value on which it is possible to do some calculations) was waited for. Instead of it, another different element on which it is not possible to do any calculation is given. There are several causes that can provoke this error, among which the most frequent are the following ones: A reserved word of the language has been used as if it was a variable, for instance x=global*2; . In this case, it is possible to check whether it is a reserved word by accessing the glossary. An operand has been omitted inside an expression, for instance x=2+ /y; . A square bracket or a bracket that had not been previously opened has been closed inside an expression, for instance x=); . Anyhow, you must check the syntax of the indicated expression to correctly construct it. ---See: Syntax - Declaration of data","title":"An operand was waited for."},{"location":"help/#unknown-name","text":"A constant, a variable, a table or a structure is used in the indicated position of the program with the aim of accessing it before having declared it. The compiler can not resolve the problem because it does not know the kind of involved object. All the constants must be defined at the beginning of the program, inside the CONST section. The variables, tables and structures may be defined inside the GLOBAL , LOCAL or PRIVATE sections, depending on their scope, but they have always to be defined before being used. This error frequently appears in the following cases: A name has been incorrectly written, for instance; Example: PROGRAM my_game; CONST centre=160; BEGIN x=centre; // Error: Unknown name. //... END - An object is used before and then declared, for instance: Example: PROGRAM my_game; CONST double=simple 2; // Error: Unknown name. simple=1; BEGIN //... END - * In this case, the two previous declarations should be exchanged. On initialising a table or structure, a comma has been accidentally put after the list of values. Example: PROGRAM my_game; GLOBAL table[]=0, 1, 2, 3, a=0; // Error: Unknown name. BEGIN //... END - In this case, the compiler will report this error in the a variable, as it interprets that it is the following value in the list of the table's initialisation, and it is a name that has not been defined yet. ---See: Syntax - Constants declaration","title":"Unknown name."},{"location":"help/#expecting-for-begin","text":"This error appears when an invalid declaration is made inside the CONST , GLOBAL , LOCAL or PRIVATE sections. After the initial statement PROGRAM program's_name; wait for any of the sections previously mentioned to appear (always in the same order), finally appearing the word BEGIN . After the beginning of a process ( PROCESS process_name( ) or function ( FUNCTION name_of_function( ... )**) wait for the PRIVATE section or the BEGIN word to be shown. The error can appear under the following circumstances: The name of any section has been incorrectly written. Several sections have been put in an incorrect order: Example: PROGRAM my_game; LOCAL a=0; GLOBAL // Error: expecting for [BEGIN] b=0; BEGIN //... END - Keep in mind that the sections must appear in the following order: CONST GLOBAL LOCAL PRIVATE Inside any of the sections previously mentioned, an element that is not a valid declaration inside that section appear. Example: PROGRAM my_game; GLOBAL +variable=0; // Error: expecting for [BEGIN] BEGIN //... END - In this example, on reaching the symbol + the compiler determines that the GLOBAL section has already finished. Therefore, as the following element is not the beginning of the LOCAL or PRIVATE sections, the compiler is expecting for the BEGIN reserved word to appear, indicating the beginning of the program code. At the beginning of the program or on defining a process, the word BEGIN has been omitted. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process() FRAME; // Error: expecting for [BEGIN] END - ---See: Syntax - BEGIN","title":"expecting for [BEGIN]"},{"location":"help/#a-constant-expression-was-waited-for","text":"To initialise constants , variables, tables and structures it is necessary to use numeric values or expressions whose value may be determined when the program is compiled. An expression starts in the indicated position. The value of this expression has not been resolved in compilation time, probably because it uses global, local or private data, or because a function is called. In constant expressions, it is only possible to use: Constants previously defined. Numeric values . Arithmetic or logical operators . Literals (texts in inverted commas). The sizeof() function. Example: PROGRAM my_game; GLOBAL my_variable=4; position=2 my_variable; // Error: A constant expression was waited for. BEGIN //... END - * In this example, position can not be initialised, as the x local variable is being used for that purpose. ---See: Syntax - Definition of constants","title":"A constant expression was waited for."},{"location":"help/#the-table-has-been-exceeded","text":"The constant expression that starts in the indicated position of the program can not be calculated, as in it you access a table or structure out of its range of positions. Check the range of the table or structure in its definition. Keep in mind that a table defined, for instance, as table[10] has 11 positions (from table[0] to table[10]). Example: PROGRAM my_game; GLOBAL table[]=1, 3, 5; value=table[3]; // Error: The table has been exceeded. BEGIN //... END - In this example, the value variable can not be initialised as an non-existent table position is being used for this purpose. ---See: Syntax - Declaration of table","title":"The table has been exceeded."},{"location":"help/#the-offset-can-not-be-calculated","text":"In the expression indicated in the program, the offset operator (or the & synonymous symbol) is used with the aim of obtaining the address (offset) of an object. That object has no address, as it is not a variable, a table or a structure. Therefore, the compiler can not resolve the expression. Probably you have intended to obtain the address of a constant expression or an expression involving several operands. Now, a program is shown with several examples of valid and invalid uses of the offset operator. Example: PROGRAM my_game; CONST my_constant=0; GLOBAL my_offset=0; my_variable=0; my_table[10]; STRUCT my_structure[10] variable; END BEGIN // Correct examples my_offset=offset my_variable; my_offset=offset my_table; my_offset=offset my_table[my_variable]; my_offset=offset my_structure[0].variable; my_offset=offset id.x; // Invalid examples my_offset=offset (my_variable 2); my_offset=offset my_constant; my_offset=offset 0; write_int(0, 0, 0, 0, offset (my_variable+1)); END - * There is no difference between the use of the offset reserved word or the symbol & . The constants such as my_constant have no offset as they are just synonymous of the numeric value they represent. The statement my_offset=offset (my_variable*2); is invalid as the multiplication is made at first and, once it has been done, the my_variable*2 value is transformed into a numeric result that has no assigned address. Unlikely, the offset my_variable*2 expression is valid as, in this case, the address of my_variable is obtained at first and then, this address will be multiplied by 2 . ---See: Syntax - offset","title":"The offset can not be calculated."},{"location":"help/#too-many-values-for-the-table","text":"A table has been initialised with more values than it can contain. Example: PROGRAM my_game; GLOBAL table1[3]=0, 1,2 , 3, 4; // Error: Too many values for the table. BEGIN //... END - To initialise a table take into account that, at the most, it can have as many values as the number in square brackets plus 1 indicates. Example: PROGRAM my_game; GLOBAL table1[3]=2, 4, 6, 8; BEGIN //... END - In this case, the table table1 may contain four values (table1[0]=2, table1[1]=4, table1[2]=6 and table1[3]=8). Another option is not to indicate the size of the table , so the compiler will deduce it from its initialisation. Example: PROGRAM my_game; GLOBAL table1[]=2, 4, 6, 8; BEGIN //... END - In this case, if it was necessary to refer to the table's length inside the program, the sizeof(table1) expression should be used, being equal to 4 in this example. ---See: Syntax - Declaration of table - sizeof()","title":"Too many values for the table."},{"location":"help/#division-by-0","text":"In the indicated position of the program, a constant expression unresolved because it contains a division by 0 among its operations, appears. On dividing a number by zero results \u00b1 infinite and, as in the programming language only integers within the range ( min_int ... max_int ) can be used, it is not possible either to store the result of that operation in any variable or to relate it with a constant. Example: PROGRAM my_game; CONST infinite=1/0; // Error: Division by 0. BEGIN //... END - It is probably an involuntary error. Thus, on evaluating the expression it is necessary to avoid doing any division by zero. ---See: Syntax - Statement of assignment","title":"Division by 0."},{"location":"help/#table-of-negative-length","text":"To define a table indicating in square brackets its length, it is necessary to use a positive integer (0, 1, 2, 3, ...), taking into account that all the tables start in the zero position and finish in the position indicated in the index. Example: PROGRAM my_game; GLOBAL table1[9]; table2[-9]; // Error: Table of negative length. BEGIN //... END - The compiler has detected a table defined with a negative length such as table2 . In this example, it is necessary to define the table such as table1 that, in this case, will be a table of 10 positions (from table1[0] to table1[9]). ---See: Syntax - Declaration of table","title":"Table of negative length."},{"location":"help/#expecting-for_3","text":"The compiler is expecting for a bracket with the [(](#() symbol to be opened in the indicated position of the program. There are many cases in which the opening of a bracket is obligatory: After a process name or a function , its call parameters must always be indicated in brackets. Even when the process or the function have no parameters, a bracket must be opened and, later, closed. Example: PROGRAM my_game; BEGIN my_process(); //... END PROCESS my_process() BEGIN //... END - In the control statements requiring a condition to control the program's flow, that condition must be put in brackets. Example: PROGRAM my_game; BEGIN IF (x<10) //... END WHILE (x<10) //... END REPEAT //... UNTIL (x<10) SWITCH (x) //... END FOR (x=0;x<10;x++) //... END END - In this example, it is possible to see how the different control statements indicate the condition in brackets. There are two exceptions: The SWITCH statement does not require a condition, but a simple expression, which must be in brackets, anyhow. The FOR statement has three parts inside the brackets, separated by semicolons. These parts are the following ones: initialisation ( x=0 ), condition ( x<10 ) and increment ( x++ ). After the DUP operator (used to initialise tables and structures) it is also obligatory to open a bracket. Example: PROGRAM my_game; GLOBAL table1[]=10 dup (1, 2, 3); BEGIN //... END - In this example, table1 would be a table of 30 positions (from table1[0] to table1[29]) initialised in the following way: 1, 2, 3, 1, 2, 3, ... ---See: Syntax - ( )","title":"expecting for [(]"},{"location":"help/#only-can-be-repeated-once-or-twice","text":"The DUP operator used to initialise tables and structures allows us to repeat (duplicate) a sequence of values a specific number of times: from once (in this case, the operator is useless) to an undetermined positive number of times. Example: PROGRAM my_game; GLOBAL table1[]=10 dup (1, 2, 3); table2[]=-10 dup (1, 2, 3); // Error: Only can be repeated once or twice. BEGIN //... END - In this example, table1 would be a table of 30 positions (from table1[0] to table1[29]) initialised in the following way: 1, 2, 3, 1, 2, 3, ... It is also possible, moreover, to omit the DUP operator. In this case, the declaration of table1 would become as follows: table1[]=10(1, 2, 3); The effect is exactly the same as in the previous example. That is to say, when the compiler is in a table's initialisation, the number (sequence_of_values ... ) sequence interprets that you intend to repeat the sequence_of_values the number of times indicated. Therefore, it is not possible to repeat a sequence of values zero times or a negative number of times. ---See: Syntax - DUP","title":"Only can be repeated once or twice."},{"location":"help/#invalid-assignment","text":"The indicated assignment can not be done in this position of the program. In an assignment statement it is only allowed to assign values to objects such as variables (of any kind), to a position of a table, or to an element of a structure. It is not possible to assign a value to a constant , a function or to a process or, in general, to any numeric or logical expression. The following program shows examples of several kinds of invalid assignments: Example: PROGRAM my_game; CONST my_constant=0; BEGIN my_constant=1; // Error: Invalid assignment. type my_game=2; // Error: Invalid assignment. sizeof(mouse)=3; // Error: Invalid assignment. 4+5=6; // Error: Invalid assignment. //... END - All these assignments are invalid because the result of an expression, which is just a numeric value, can not be modified with an assignment. Thus, it is the same as to put a statement of the kind 2=4; that, obviously, is impossible. ---See: Syntax - Definition of expression","title":"Invalid assignment."},{"location":"help/#expecting-for-end","text":"A block of statements is waited for inside the BEGIN and END reserved words, as well as inside statements such as the following ones: IF ... ELSE ... END LOOP ... END WHILE ... END FOR ... END FROM ... END SWITCH ... END A block of statements finishes (and only can finish) with any of these three reserved words: END , UNTIL or ELSE . In the program, there is a block expected to finish with the END reserved word, but it finishes with another word. The two more usual cases are the following ones: That a REPEAT or a IF have been lost, finishing the statements block with a UNTIL or a ELSE . In this case, the REPEAT or IF associated must be looked for. Example: PROGRAM my_game; BEGIN // REPEAT //... UNTIL (key(_esc)); // Error: expecting for [END]. END - In this example, the statements block that started with the BEGIN of the main program has finished with an UNTIL (because the REPEAT has been accidentally commented), and the compiler was expecting for this block to finish with an END . That an END of any statement has been lost and the following PROCESS or the end of the program expecting for the END that has been lost is reached. Example: PROGRAM my_game; BEGIN IF (x<0) x++; END PROCESS my_process() // Error: expecting for [END]. BEGIN //... END - In this case, the END of the IF has not been put, interpreting the compiler that the IF finishes when the following END (the one of BEGIN ) is reached and, therefore, when the new PROCESS or {#1408,FUNCTION comes, it goes on expecting for the END of the BEGIN . ---See: Syntax - END","title":"expecting for [END]"},{"location":"help/#invalid-expression","text":"In the indicated position of the program there is an expression incorrectly constructed, so the compiler can not interpret it. Check the syntax of the expression. If the error is not found, try to express it in a different way. Try to divide the expression into several subexpressions, sequentially and separately doing the different calculations done in the original expression. For instance, the expression: x=(x*4+1)/2; can be expressed as the three following expressions: x=x*4; x=x+1; x=x/2; Thus, it is possible to locate the exact point in which the operation that can not be done is. ---See: Syntax - Definition of expression","title":"Invalid expression."},{"location":"help/#expecting-for-until","text":"A block of statements that started with the reserved word REPEAT must necessarily finish with the word UNTIL . In the indicated position of the program, the block of statements has finished with a different word. So probably: A REPEAT has finished with an END . In this case, if you intend to create a loop indefinitely, the LOOP ... END statement must be used. Example: PROGRAM my_game; BEGIN REPEAT //... END // Error: expecting for [UNTIL] END - Inside the REPEAT ... UNTIL loop will appear a spare word such as END or ELSE without its corresponding beginning ( IF , WHILE , ...). Example: PROGRAM my_game; BEGIN REPEAT IF (x<0) x++; END y++; END // Error: expecting for [UNTIL] UNTIL (x>=0); END - In this case, the END of the IF has been put twice, interpreting the compiler that the second END intends to close the REPEAT . Or finally, that you have forgotten to put the UNTIL of the REPEAT . ---See: Syntax - Statement REPEAT - IF - WHILE","title":"expecting for [UNTIL]"},{"location":"help/#local-variable-that-can-not-be-accessed","text":"In the indicated position of the program, the aim is to access a variable of another process. But this is not possible, as this variable is not local in the other process. It is necessary to verify that the variable intended to access either is defined inside the LOCAL section of the program, or is a local variable predefined in the language (such as x , y , graph , size , ...). Example: PROGRAM my_game; GLOBAL id_my_process; score=0; BEGIN id_my_process=my_process(); id_my_process.x=0; id_my_process.score=0; // Error: Local variable that can not be accessed. END PROCESS my_process() BEGIN //... END - In this case, the aim is to access the score of my_process , but score is just a single GLOBAL variable and not a LOCAL variable of every process. This can also happen by trying to access a constant (defined in CONST ) or an expression like: x=id_my_process.(x+1); In this example, the expression makes no sense at all. The following expression would probably be the one intended to be used: x=id_my_process.x+1; (equivalent to x=(id_my_process.x)+1; ). ---See: Syntax - Declaration of local data","title":"Local variable that can not be accessed."},{"location":"help/#invalid-parameter","text":"The processes can receive parameters in the following kinds of data: A predefined local variable (like x , size , flags , ...). A local variable defined inside the LOCAL section. A global variable defined inside the GLOBAL section. A private variable of the process declared inside the PRIVATE section of the process. A private variable not declared inside the PRIVATE section. In all these cases, it is understood that a variable can be referred to a variable, to a specific position of a table or to an element inside a structure. In the indicated position of the program, the aim is either to receive a parameter in an object different from those aforementioned, or to indicate an expression instead of a simple variable. These are some examples of invalid parameters' declarations: PROCESS my_process(my_constant) A parameter can not be received in a constant. PROCESS my_process(x*2) A parameter can not be received in an expression. PROCESS my_process(x=0) A parameter can not be received in an assignment. ---See: Syntax - Parameters of a process","title":"Invalid parameter."},{"location":"help/#expecting-for-another-parameter","text":"In the calls to processes or functions, it is necessary to put as many values or expressions as parameters are required, all of them inside the same bracket and separated by commas (,) . This error appears when the bracket is closed after a comma , as in the following example: Example: PROGRAM my_game; BEGIN signal(id, ); // Error: expecting for another parameter. END - There are two reasons for that: either a comma has been accidentally put after the last parameter, or the last parameter has been omitted (like in the previous example). ---See: Syntax - Parameters of a process","title":"expecting for another parameter."},{"location":"help/#invalid-number-of-parameters","text":"The process or function has a number of parameters different from the one that appears in the indicated position of the program. If it is a function, access Glossary to consult the required parameters or place the cursor on the name of the function in the program and then press F1 . If it is a process , then it is possible that in the indicated position, the number of parameters is correct, but a call to this process has previously appeared in the program with a different number of parameters. Example: PROGRAM my_game; BEGIN my_process(); END PROCESS my_process(x, y) // Error: Invalid number of parameters. BEGIN //... END - In this example, the error is not in the definition of the process as it is shown, but in the previous call to that process ( my_process(); ). This is like this because when the compiler finds a call to a process that does not know, it records it like a new process and notes down its number of parameters. If the next time it finds that process the number of parameters does not coincide with those it had recorded, then the error appears. Therefore, if the call or definition of the process shown in the program is correct, then use the search option ( ALT-F ) to check the number of parameters in the previous calls to that process. ---See: Syntax - Parameters of a process","title":"Invalid number of parameters."},{"location":"help/#expecting-for_4","text":"The FOR statement has three parts inside the brackets separated by semicolons. These parts are the following ones: FOR ( initialisation ; condition ; increment ) The initialisation is normally an assignment that sets the value of a variable when the FOR statement starts to run. The condition secondly established determines the continuance inside the loop. In every iteration it will be checked first whether this condition is complied with. Otherwise, the execution of the FOR statement will finish. The increment updates the variable's value that is used as a counter after every iteration of the loop. None of these three parts are obligatory, except the brackets and the two symbols semicolon (;) that separate the parts. Example: PROGRAM my_game; BEGIN FOR ( graph=10 ; graph<20 ; graph=graph+1 ) //... END FOR ( graph=10 ; graph<20 graph=graph+1) // Error: expecting for [;] //... END END - Several statements can be put inside every of the three parts providing that they are separated by commas (,) (several initialisations, conditions or increments). ---See: Syntax - Semicolon (;) - Statement FOR","title":"expecting for [;]"},{"location":"help/#break-does-not-appear-inside-a-loop","text":"The BREAK statement makes the program continue after the loop that is running. This statement is used to exit the following loops: LOOP ... END FROM .. TO .. STEP .. ... END REPEAT ... UNTIL ( ](#)) WHILE ( ](#)) ... END FOR ( ](#)) ... END A BREAK statement will make the program continue to be executed after the END or UNTIL of the loop closest to the statement. BREAK can only appear inside one of these loops. If there are several nested loops (one inside another one) the BREAK statement will exit the inner loop. Example: PROGRAM my_game; BEGIN LOOP REPEAT IF (key(_esc)) BREAK; END //... UNTIL (x==0); //... END BREAK; // Error: [BREAK] does not appear inside a loop. END - In this example the BREAK statement will exit REPEAT ... UNTIL (when the ESC key is pressed) but not LOOP ... END . ---See: Syntax - Statement BREAK","title":"[BREAK] does not appear inside a loop."},{"location":"help/#continue-does-not-appear-inside-a-loop","text":"The CONTINUE statement makes the program finish the current iteration of the loop that is running. This statement is used to go to the beginning/end of the following loops: LOOP ... END A CONTINUE statement inside this loop will jump to LOOP . FROM .. TO .. STEP .. ... END A CONTINUE statement inside this loop will make the increment ( STEP ) and, if the value indicated in the TO has not been passed, the program will continue at the beginning of the loop. REPEAT ... UNTIL ( ](#)) A CONTINUE inside this loop will jump to UNTIL . WHILE ( ](#)) ... END A CONTINUE inside this loop will jump to WHILE . FOR ( ](#)) ... END A CONTINUE inside this loop will make the increment and the comparison. If the latter is true, the program will continue at the beginning of the loop. But if it is false, the program will continue after the END of the FOR . CONTINUE must obligatory appear inside one of these loops . If there are several nested loops (one inside another) the CONTINUE statement will take effect only in the inner loop. Example: PROGRAM my_game; BEGIN FOR (x=0, y=0;x<10;x++) IF (x<5) CONTINUE; END y++; END END - In this example, after the whole loop has been executed, x will be equal to 10 and y will be equal to 5 as, providing that x is less than 5, the CONTINUE statement prevents the y++; statement from being executed. ---See: Syntax - Statement CONTINUE","title":"[CONTINUE] does not appear inside a loop."},{"location":"help/#expecting-for-case-default-o-end","text":"The syntax of the SWITCH statement is, broadly speaking, as follows: SWITCH ( ](#-)) CASE value : statements ; END CASE value .. value : statements ; END CASE value, value, value : statements ; END //... DEFAULT : statements ; END END The position indicated in the program is inside a SWITCH statement, but out of a CASE or DEFAULT section. For that reason, the compiler was expecting for one of the three following statements to appear in that position: The reserved word CASE starting a new section to be executed when the expression would coincide with the indicated value. The reserved word DEFAULT starting a section by default to be executed when the expression would not coincide with any of the values indicated in the different sections CASE . The reserved word END finishing the SWITCH statement. For a more detailed description of the SWITCH statement, consult the syntax of the language. ---See: Syntax - Statement SWITCH","title":"expecting for [CASE], [DEFAULT] o [END]"},{"location":"help/#expecting-for-end_1","text":"An END of the CASE or DEFAULT was waited for inside the SWITCH statement. Inside the reserved words SWITCH and END one or more sections of the following kind were waited for: CASE ... END DEFAULT ... END In the program, there is one of these sections that was expected to finish with the reserved word END , but it finishes with another word. The most usual case is the following one: That a REPEAT or a IF have been lost, finishing the block of statements with an UNTIL or an ELSE . In this case, the associated REPEAT or IF must be looked for. Example: PROGRAM my_game; BEGIN SWITCH (x) CASE 0: //REPEAT //... UNTIL (key(_esc)); // Error: expecting for [END] END END END - In this example, the section that started with CASE has finished with UNTIL (because REPEAT has been accidentally commented), and the compiler was expecting this section to finish with END . ---See: Syntax","title":"expecting for [END]"},{"location":"help/#expecting-for-process","text":"The compiler has interpreted that, in the indicated position of the program, the main program ( PROGRAM ... BEGIN ... END ), or the last process ( PROCESS or function ( FUNCTION ) and have finished and then, it was expected that either a process would start or the program would finish. The most frequent is to have duplicated END inside the last block of statements BEGIN ... END . Example: PROGRAM my_game; BEGIN IF (x<0) x++; END END FRAME; // Error: expecting for [PROCESS]. END - In this example, the END of the IF has been accidentally put twice, interpreting the compiler that the second is that of END of the BEGIN . Therefore, after this last END only the end of the program or the reserved word PROCESS or FUNCTION can come, marking the beginning of a new process. When a FRAME statement is placed in that position, the compiler reports the error. ---See: Syntax - Declaration of process","title":"expecting for [PROCESS]"},{"location":"help/#a-table-can-not-be-specified-as-a-parameter","text":"It is not necessary to declare the parameters of the process inside the PRIVATE section, as they are automatically declared. But if they are declared, they must be declared as variables, not as tables or structures, and they must not be initialised. You have probably intended to use the same name for two different objects. On the one hand, for the parameter of the process and, on the other hand, for a PRIVATE table of the same process. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a) PRIVATE a[9]; // Error: A table can not be specified as a parameter. BEGIN //... END - The compiler interprets that the parameter a is being typified as a table of 10 positions and, since a table can not be passed as a parameter, it reports the error. ---See: Syntax - Parameters of a process","title":"A table can not be specified as a parameter."},{"location":"help/#a-parameter-can-not-be-initialised","text":"It is not necessary to declare the parameters of the process inside the PRIVATE section, as they are automatically declared. But if they are declared, they must be declared as variables, not as tables or structures, and they must not be initialised. You have probably intended to use the same name for two different objects. On the one hand, for the parameter of the process and, on the other hand, for a PRIVATE variable of the same process. Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a) PRIVATE a=0; // Error: A parameter can not be initialised. BEGIN //... END - The compiler interprets that the parameter a is being initialised at 0 and, as it is not allowed to initialise a parameter (as it will take its value depending on the call to the process), the error is reported. ---See: Syntax - Parameters of a process","title":"A parameter can not be initialised."},{"location":"help/#the-end-came-inside-a-comment","text":"The end of the program has come inside a comment of several lines (those defined between the /* and */ symbols). This error appears because any comment has not been closed. Therefore, check that all the comments opened with the /* symbol have their corresponding */ symbol closing them. Example: PROGRAM my_game; BEGIN / Beginning of the comment FRAME; END // Error: The end came inside a comment. - * ---See: Syntax - Definition of comments","title":"The end came inside a comment."},{"location":"help/#it-is-not-possible-to-access-external-private-data","text":"In the indicated position of the program, there is an attempt to access a PRIVATE variable of another process. It is not allowed. If the aim is to access a variable of a process from another process, this variable must be declared inside the LOCAL section. Example: PROGRAM my_game; PRIVATE n; BEGIN my_process(); //... END PROCESS my_process() PRIVATE n; BEGIN father.n=0; // It is not possible to access external PRIVATE data. END - It is not possible to access PRIVATE data, even when the accessed process is of the same kind as the process that is trying to access the variable. The correct way to declare the variable n in the previous example is as follows: Example: PROGRAM my_game; LOCAL n; BEGIN my_process(); //... END PROCESS my_process() BEGIN father.n=0; END - Keep in mind that all the processes of the program will have the data declared inside the LOCAL section (all the processes of the previous example will have an own variable named n ). ---See: Syntax - Declaration of PRIVATE data","title":"It is not possible to access external PRIVATE data."},{"location":"help/#a-structure-must-contain-one-element-at-least","text":"In the indicated position of the program, the aim is to close the declaration of a structure without any element (field) defined in it with END . A structure ( STRUCT ) is like a list of index cards (records) with several pieces of information (fields) in every index card. STRUCT name_structure[10] x, y; END In this example, the structure (set of index cards) is called name_structure and it has 10 records (ten index cards) with 2 fields each one (with two pieces of information; x and y ). Therefore, defining a structure without fields makes no sense (since it is the same as defining a set of index cards with no piece of information). Then, to access the information of the index cards, the structure is used as follows (suppose that in the global variable n the aim is to put the value y of the index card number 5 ). n=name_structure[5].y; An invalid program is shown now. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[10] END // Error: A structure must contain one element, at least. BEGIN //... END - ---See: Syntax - Declaration of structure","title":"A structure must contain one element, at least."},{"location":"help/#expecting-for-an-element-of-the-structure","text":"In the indicated position of the program, the aim is to declare an invalid element (field) of the structure. A structure can just have the following kind of fields: A variable. In this case, the name of the declaration without being initialised must be indicated. A table, indicating its name and, subsequently, its length in square brackets (keep in mind that a table declared like my_table[9]; is a table of 10 positions, from my_table[0] to my_table[10]). They must not be initialised. Another structure. It is possible to include as many structures inside other structures as necessary, with no limit of nesting. An example of structures nesting is shown now. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[9] elements; STRUCT data[9] x, y; END END a, b; BEGIN FROM a=0 TO 9; my_structure[a].elements=-1; FROM b=0 TO 9; my_structure[a].data[b].x=-1; my_structure[a].data[b].y=-1; END END //... END - In this example, every record of my_structure will have a variable called elements and another structure with 10 elements, each one with two variables: x and y . Next, in the same example, it is possible to see an example of access to that structure with two nested loops that initialise all the values of the structure at -1 . To see how to initialise the values of a structure in the definition itself, go to the topic syntax . ---See: Syntax - Declaration of structure","title":"expecting for an element of the structure."},{"location":"help/#it-is-not-a-type-of-process","text":"The TYPE operator may only be used if it goes before a process name of the program or the word mouse (to detect collisions with the mouse pointer). In the indicated position of the program, it is not preceding a process name. It is probable either that the process name has been incorrectly written or that the type of a process is intended to be obtained from its identifying code . There is a way to obtain the type of a process having its identifying code , as it is shown below (suppose that we have the identifier in the id2 variable). id2.reserved.process_type Instead of TYPE id2 that is not allowed (as there is no process named id2 , since id2 is a variable). Next, an example of correct use of the TYPE operator is shown (with the aim of obtaining the identifying code of a process). Example: PROGRAM my_game; PRIVATE id2; BEGIN //... id2=get_id(TYPE my_process); //... id2=get_id(TYPE id2); // Error: It is not a type of process. //... END PROCESS my_process() BEGIN //... END - As it can be noticed, the TYPE operator requires the process name of the program with no brackets or parameters. ---See: Syntax - Types of processes","title":"It is not a type of process."},{"location":"help/#the-size-can-not-be-calculated","text":"The sizeof() function may be used to obtain the number of elements of a table or structure. For that purpose, it requires in brackets , the name of the table or structure (with no square brackets or index). It can also be used with the name of a variable but, in this case, the function will always return 1. It can indistinctly be used with global, local or private data. In the indicated position of the program, the aim is to obtain the size of an object that is not a variable, table or structure. For instance, this error will appear if the aim is to obtain the size of a constant, function, process, etc. Example: PROGRAM my_game; CONST my_constant=99; GLOBAL a=sizeof(my_constant); // Error: The size can not be calculated. BEGIN //... END - This example will provoke the error on trying to obtain the number of elements of a constant , as a constant is not an object having a size, but just a synonymous of the numeric values that it represents. ---See: Syntax - sizeof","title":"The size can not be calculated."},{"location":"help/#use-import-namedll","text":"The compiler was expecting for the file name to appear in inverted commas after the reserved word IMPORT . To declare the use of an external library, it is necessary to put a declaration like that of the following example. Example: PROGRAM my_game; IMPORT \"library.dll\"; BEGIN //... END - This program declares the use of the library called library.dll (alleged name of an hypothetical library of external functions). This declaration must be put just before the PRIVATE section or the BEGIN of the main program. It is possible to make several IMPORT declarations in a row to declare the use of more than one library ---See: Syntax - Declaration of libraries","title":"Use: import \"name.dll\""},{"location":"help/#use-of-an-invalid-external-dll","text":"In the indicated position of the program, the aim is to load an invalid DLL , which is explained for the following reasons: The file with the DLL has become corrupted because it has been stored in a damaged environment. It is not a DLL specifically designed for DIV Games Studio. The file with extension DLL is not found in the path specified by the IMPORT statement. It is not possible to use DLL of other languages, as they are not compatible with this language even if all the files have the extension DLL . When this DLL has been prepared for this language, check the installation instructions and verify either that the file with extension DLL is in the directory of DIV Games Studio, or that the IMPORT statement specifies the complete path of that file. ---See: Syntax - Declaration of libraries","title":"Use of an invalid external DLL."},{"location":"help/#expression-with-no-sense","text":"In the indicated position of the program, the compiler has supposed that a statement of the following types started: Assignments, e.g.: = ** ; ** Increments or decrements, e.g.: ++ ; Call to a process or function, e.g.: ( ... ) ; Nevertheless, it has found an expression that apparently makes no sense, as once its operations have been done, its result is not used for any purpose. It is probably an isolated operator that has been left out of a statement, for instance, because an operator has been lost. Example: PROGRAM my_game; BEGIN x+1; // Error: Expression with no sense. //... END - This error is reported in this example, as the x+1; statement is not useful; it adds the x variable and the constant 1 but then, this result is not used for any purpose. If the aim is to add 1 to the x variable, then the following statement must be used: x=x+1; Here, the x variable and the constant 1 are added and then this result is assigned to the x variable. It could have also been done with the x++; statement (incrementing x). ---See: Syntax - Statement of assignment","title":"Expression with no sense."},{"location":"help/#expecting-for_5","text":"The indicated position in the program is inside a SWITCH statement, after the beginning of a section with \" CASE value\". For that reason, the compiler was expecting for the symbol : to appear in this position preceding the statements of that section. The syntax of the SWITCH statement is, broadly speaking, as follows: SWITCH ( ](#-)) CASE value : statements ; END CASE value #, .. value : statements ; END CASE value, value, value : statements ; END //... DEFAULT : statements ; END END For a more detailed description of the SWITCH statement, consult the syntax of the language. ---See: Syntax - Statement SWITCH","title":"expecting for [:]"},{"location":"help/#expecting-for_6","text":"The compiler is expecting for a semicolon (;) in the indicated position of the program. In the language, the following points of the program must be indicated with semicolons: The end of the options of compilation . The end of the declaration PROGRAM . The end of a declaration of data . The end of a declaration IMPORT . The end of the following statements: Assignments or increments of data . Calls to processes . Calls to functions . FRAME , RETURN , DEBUG , BREAK and CONTINUE . The end of the beginning of a loop FROM . And as division of the different parts of a FOR statement. The compiler will indicate when the symbol ; is missing in any of these periods. Moreover, this symbol can be put in other specific points of the programs. For instance, after any other type of statement, even if, in this case, it will be optional and, therefore, the compiler will not notice its lack. ---See: Syntax - ;","title":"expecting for [;]"},{"location":"help/#expecting-for-a-variable","text":"The compiler was expecting for a global, local or private variable of the process in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly. If the aim is to use a variable of another process, a table or an element of a structure as a counter, the FOR statement must be used instead of FROM , as it allows us to define the conditions of the loop more freely. ---See: Syntax - Statement FROM","title":"expecting for a variable."},{"location":"help/#expecting-for_7","text":"The compiler was expecting for a symbol = (assignment) in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly, and then the symbol = (assignment). Example: PROGRAM my_game; GLOBAL id2; BEGIN //... FROM id2.x=0 TO 9; // Error: expecting for [=]. //... END END - In this example, the error will appear on detecting the symbol . (period) instead of = after the first name ( id2 ) that appears. This happens because a variable of another process can not be used as a counter of a FROM loop. If the aim is to use a variable of another process, a table or an element of a structure as a counter, the FOR statement must be used instead of FROM , as it allows us to define the conditions of the loop more freely. ---See: Syntax - Statement FROM","title":"expecting for [=]"},{"location":"help/#expecting-for-to","text":"The compiler was expecting for the reserved word TO of the FROM statement in the indicated position of the program. The syntax of the FROM loop statement is the following one: FROM = TO STEP ; ; ... END Being the STEP declaration optional. After the reserved word FROM , the name of a variable (normally local or private) of the process must appear directly, and then the symbol = (assignment), preceding a constant. After this constant value, only the reserved word TO can appear. Example: PROGRAM my_game; GLOBAL id2; BEGIN //... FROM id2.x=0 STEP 9; // Error: expecting for [TO]. //... END END - In a FROM statement, the initial and final values of the loop's counter variable must always appear in both sides of the word TO . ---See: Syntax - Statement FROM","title":"expecting for [TO]"},{"location":"help/#the-value-step-is-not-valid","text":"In a FROM statement: If the initial value is less than the final value, a negative value can not be specified in the declaration STEP . If the initial value is bigger than the final value, a positive value can not be specified in the declaration STEP . Example: PROGRAM my_game; BEGIN FROM x=0 TO 10 STEP -1; // Error: The value STEP is not valid. //... END END - This loop is not valid as, if 1 is subtracted from x (that originally will be equal to 0 ) in every iteration, it will never reach 10 . If the aim is to create a continuous loop, the LOOP statement must be used. ---See: Syntax - Statement FROM","title":"The value STEP is not valid."},{"location":"help/#invalid-from-statement","text":"In a FROM statement: The initial and final values of a FROM loop must be different. Example: PROGRAM my_game; BEGIN FROM x=0 TO 0; // Error: Invalid FROM statement. //... END END - Creating this loop makes no sense, as the inner set of statements will be repeated just once, which would be equivalent to initialising x at 0 (with the x=0; statement) and, then, to directly putting the inner statements, omitting the loop FROM . If the aim is to create an ever-repeating loop, the LOOP statement must be used. ---See: Syntax - FROM statement","title":"Invalid FROM statement."},{"location":"help/#correct-compilation","text":"The program has no errors of compilation. Press: Menu programs\\Execute or F10 . To save, compile and execute the program. Menu programs\\Debug or F12 . To save, compile and debug the program step by step.","title":"Correct compilation"},{"location":"help/#exceeded-the-capacity-of-the-names-vector","text":"The buffer to store the names of the program has been exceeded. This error can only be due to the fact that too long data names and processes have been used. The only solution to compile the program is to replace some of these names by other shorter names.","title":"Exceeded the capacity of the names vector."},{"location":"help/#exceeded-the-capacity-of-the-demo-version","text":"This DEMO version of DIV Games Studio does not allow us to create programs as big as this one. It can only compile programs of a specific number of variables and processes. In the complete version of DIV GAMES STUDIO does not exist this limit, being possible to create programs of any size. The only option to compile this program is first eliminating all the processes and data that are no longer required or indispensable.","title":"Exceeded the capacity of the demo version."},{"location":"help/#exceeded-the-capacity-of-the-table-of-objects","text":"The available space to store data records and the program's processes has been exceeded. This error should never happen, but when it happens it is difficult to resolve. The program is too big for this version of the compiler. If there is a new version of the compiler or any 'patch' that updates this limitation, it must be updated. Otherwise, the only option is to eliminate from the program all the processes and data that are not required or essential any longer.","title":"Exceeded the capacity of the table of objects."},{"location":"help/#expecting-for-the-structure-name","text":"To define a structure of data, its name must be specified after the reserved word STRUCT . Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END BEGIN //... END - This structure has been defined with the name positions and contains ten records (from 0 to 9) each one with two values x and y . ---See: Syntax - Names - Declaration Structures","title":"expecting for the structure name."},{"location":"help/#expecting-for-the-process-name","text":"To define a process, its name must be specified after the reserved word PROCESS . Example: PROGRAM my_game; BEGIN //... END PROCESS my_process() BEGIN //... END - This process has been declared with the name my_process . ---See: Syntax - Names","title":"expecting for the process name."},{"location":"help/#expecting-for-the-name-of-a-process","text":"The name of one of the processes defined in the program must be defined after the reserved word TYPE . Example: PROGRAM my_game; BEGIN //... signal(TYPE my_process, s_kill); //... END PROCESS my_process() BEGIN //... END - ---See: Syntax - Names - Types of processes","title":"expecting for the name of a process."},{"location":"help/#expecting-for-a-name","text":"As a parameter, the sizeof() function requires the name of a variable. It can also be the name of a variable, a table or a structure of the program. This function returns the number of data (or elements) that the object whose name is passed as an argument has. Therefore, if that object was a variable, the function would always return 1. Example: PROGRAM my_game; GLOBAL table[]=0, 1, 2, 3; length_table; BEGIN length_table=sizeof(table); END - In this example length_table will be equal to 4 after the statement execution, as the table contains four data. ---See: Syntax - Names - sizeof","title":"expecting for a name."},{"location":"help/#the-name-is-not-new_1","text":"A name has been used twice for a field of the structure. You must replace this name by another similar one. Example: PROGRAM name_of_the_program; GLOBAL STRUCT position[9] x0, x0; // Error: The name is not new. END BEGIN //... END - ---See: Syntax - Names - Declaration of structure","title":"The name is not new."},{"location":"help/#the-name-is-not-new_2","text":"An invalid program's name has been used as it was already predefined as the name of another object. You must replace this name by another similar one. In order to know which is the object identified with that name , it is possible to access the Glossary . Example: PROGRAM x; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as the name of the program, that is predefined as the name of the local variable that indicates the x coordinate of the processes. ---See: Syntax - Names - Glossary","title":"The name is not new."},{"location":"help/#the-name-is-not-new_3","text":"To define a constant , an invalid name has been used, as it was already predefined as the name of another object. It can be the name of a constant, variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; CONST x=0; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as a constant's name that is predefined as the local variable that indicates the x coordinates of the processes. ---See: Syntax - Names -----------------------------------------------------------------------------","title":"The name is not new."},{"location":"help/#the-name-is-not-new_4","text":"To define a new data, an invalid name has been used, as it was already predefined as the name of another object. It can be the name of a constant , variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; GLOBAL x[3]=0, 1, 2, 3; // Error: The name is not new. BEGIN //... END - In this example, the aim was to use x as a global table's name that is predefined as the local variable that indicates the x coordinates of the processes. ---See: Syntax - Names","title":"The name is not new."},{"location":"help/#the-name-is-not-new_5","text":"A name of an invalid process has been used, as it was already predefined as the name of another object. It can be the name of a constant , variable, table, structure, process or a function of the program. It is also possible either that the same name has been used inside the program to identify two different objects, or that a predefined name has been used with another purpose inside the language . In that case, it is possible to access the Glossary to see the object to which this name is referred. You must replace this name by another similar one. Example: PROGRAM my_game; BEGIN //... END PROCESS my_game() // Error: The name is not new. BEGIN //... END - In this example, the aim was to use the name that had been previously used to identify the main program as the name of a process. ---See: Syntax - Names","title":"The name is not new."},{"location":"help/#expecting-for_8","text":"To define a constant, a symbol = must be put after the name of the constant. The compiler has understood that the last defined word was the name of a new constant and, in the indicated position, it was expected for the symbol of assignment ( = ) to be shown. Example: PROGRAM my_game; CONST a=0; b=1; c,d; // Error: expecting for [=]. BEGIN //... END - ---See: Syntax - Declaration of data","title":"expecting for [=]"},{"location":"help/#too-many-values-for-the-structure","text":"A structure has been initialised with more values than it can contain. To initialise a structure, take into account the greatest number of values that it can contain. This number will be: N\u00ba of records X N\u00ba of fields Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END = 10 dup (-99, 99); BEGIN //... END - In this case, the structure positions has 10 records (from positions[0] to positions[9]) and 2 fields (x and y). Then, the greatest number of values that it can contain is 20 . In the example, all the fields x are initialised at -99 and all the fields y are initialised at 99 . ---See: Syntax - Declaration of structure","title":"Too many values for the structure."},{"location":"help/#unknown-name_1","text":"In the indicated position of the program, reference is made to a non-existent PROCESS FUNCTION , that can be one of the following cases: The name of a process has been incorrectly keyed. In this case, check the name of the original process, as it is possible that the name does not correctly appear in its definition. The aim has been to use a language function and its name has not been correctly written. In this case, it is possible to access the general index to look for the exact name of the function. Reference is made to a process whose code has not been defined yet. Therefore, if the aim is to compile the program, it is necessary to define the process, at least, as follows: Example: PROGRAM my_game; BEGIN my_process(); END PROCESS my_process() BEGIN END - Indicating in the process the parameters that it receives (in the previous example, it does not receive any parameter). ---See: Syntax","title":"Unknown name."},{"location":"help/#the-increment-can-not-be-performed","text":"In the indicated expression of the program the operator ++ (or the operator -- ) are incorrectly used with the aim of incrementing (or decrementing) an object. That object has no offset, as it is not a variable, table or structure. Thus, the compiler can not perform an increment (or decrement) about it. The aim has probably been to increment or decrement a constant expression or an expression involving several operands. Now, a program with several examples of valid and invalid use of the operators ++ and -- , is shown. Example: PROGRAM my_game; CONST my_constant=0; GLOBAL my_variable=0; my_table[10]; STRUCT my_structure[10] variable; END BEGIN // Valid examples my_variable++; my_table--; ++my_table[my_variable]; --my_structure[0].variable; id.x++; // Invalid examples (my_variable 2)++; my_constant--; ++0; --(my_variable+1); END - * The constants like my_constant can not be incremented as they are just synonymous of the numeric value they represent. The (my_variable*2)++; statement is not valid because the multiplication is first done and then, the value my_variable*2 becomes a numeric result that has no offset and, therefore, it is not possible to access it in order to increment it. In this case, the correct statement that should have been used is probably my_variable=my_variable*2+1; ---See: Syntax - ++ - --","title":"The increment can not be performed."},{"location":"help/#structure-of-negative-length","text":"To define a structure indicating its number of records in square brackets a positive integer (0, 1, 2, 3, ...) must be used, taking into account that all the structures start in the record zero and finish in the record indicated in the index. Example: PROGRAM my_game; GLOBAL STRUCT e1[9] x, y; END STRUCT e2[-9] // Error: Structure of negative length. x, y; END BEGIN //... END - The compiler has detected a structure defined with a negative number of records, like e2 . In this example, the structure must be defined as e1 that, in this case, will be a structure of 10 records (from e1[0] to e1[9]) and two fields (x and y). ---See: Syntax - Declaration of structure","title":"Structure of negative length."},{"location":"help/#a-statement-was-expected","text":"The indicated position of the program is within the context of a block of statements. Thus, a statement was expected to start in the indicated position. These are the possible types of statements: assignment statements = ; control statements IF and SWITCH . loop statements FROM , WHILE , REPEAT , LOOP and FOR . break statements BREAK , CONTINUE and RETURN . special statements FRAME , CLONE and DEBUG . Being possible that, in this position, one of the following reserved words that can mark the end of a block of statements appear: END , ELSE and UNTIL . Example: PROGRAM my_game; BEGIN CASE 0: // Error: A statement was expected. //... END END - This example will provoke error, because the reserved word CASE is not valid to start a statement. It is only valid inside a SWITCH statement. ---See: Syntax - Declaration of statements","title":"A statement was expected."},{"location":"help/#expecting-for-the-name-of-the-string","text":"To define a string of text you must specify the its name after the reserved word STRING . Example: PROGRAM my_game; GLOBAL STRING player[32]; STRING message; BEGIN //... END - In this example two global text strings were defined. The first is defined with the name player which can accumulate up to 32 characters and the second with the name message which with the undeclared length can accumulate up to 256 characters (because this is the application's maximum size of text strings). ---See: syntax - names","title":"expecting for the name of the string"},{"location":"help/#the-name-has-already-been-allocated","text":"An item has been given a name that has already been used. It could be a name, a constant, a variable, a table, a structure, a process or function of the program. You may be attempting to use the same name inside the program to identify two different objects, or {a name you allocated is predefined for another use was inside the language}. In this case you can access the glossary to see to which object the name belongs to. In each case, you must substitute this name with another one . Example: PROGRAM name_of_program; GLOBAL player=0; STRING player; // Error: The name is not unique. BEGIN //... END - ---See: syntax - Names","title":"The name has already been allocated"},{"location":"help/#text-string-has-a-negative-length","text":"To define a text string you indicate in brackets its length, it is necessary for its length to be defined as a positive whole number (0, 1, 2, 3, ...), remembering that all strings begin in the position null and finish in the position which indicates the index. Example: PROGRAM my_game; GLOBAL STRING string1[9]; STRING string2[-9]; // Error: Text string has negative length. BEGIN //... END - The compiler detected a text string with a negative string length such as string2 ; in this example you must define the string as string1 which will be the string of 10 characters (from string1[0] to string1[9]). ---See: syntax","title":"Text string has a negative length"},{"location":"help/#a-literal-was-expected","text":"Literals are texts in brackets . In the indicated position of the program a literal was expected to be given as the initial value of a text string. The text strings can be initiated as shown in this example. Example: PROGRAM my_game; GLOBAL STRING string=\"initial text in the string\"; BEGIN //... END - It is not obligatory to initiate the text strings of a program. In the case of initiation, the string could have an empty text (\"\") at the beginning of the program, so, these two declarations would be identical: STRING string; STRING string = \"\" ; In these cases, their length is not declared, therefore the strings can accumulate to a maximum of 256 characters (because this is the maximum size allowed for strings of text). ---See: syntax","title":"a literal was expected"},{"location":"help/#literal-is-too-long","text":"A text string was initiated with a literal with a bigger number of characters than the string can contain. Example: PROGRAM my_game; GLOBAL STRING string1[3]=\"ABCDE\"; // Error: Literal is too long BEGIN //... END - To initiate a text string you must remember that the maximum number of characters it can contain is the number contained in square brackets, plus one. Example: PROGRAM my_game; GLOBAL STRING string1[3]=\"ABCD\"; BEGIN //... END - In this case a text string string1 can contain four characters (string1[0]=char(\"A\"), string1[1]=char(\"B\"), string1[2]=char(\"C\") and string1[3]=char(\"D\")). The other option is not to indicate the size of the text string , establishing in this case the string size maximum of 256 characters. Example: PROGRAM my_game; GLOBAL STRING string1=\"ABCDEF\"; BEGIN //... END - In this case, string1 would contain initially six indicated characters (\"ABCDEF\"), but it can reach 256 during the execution of the program. ---See: syntax","title":"Literal is too long"},{"location":"help/#a-comma-was-expected","text":"It is accessing an array indicating less dimensions than required. It means that an array of two dimensions is pretending to take one dimension as its parameters or an array of three dimensions is attempting to use it as a two dimensional array. Example: PROGRAM my_game; GLOBAL array1[9,9]; BEGIN //... array1[0]=0; // Error: A comma was expected. END - Check the previous declaration of the named array of data in the program. ---See: syntax","title":"A comma was expected"},{"location":"help/#a-comma-was-expected_1","text":"It is accessing a structure indicating less dimensions than required. It means that a structure of two dimensions is attempting to use one dimension as its parameters or a structure of three dimensions is attempting to use it as a two dimensional structure. Example: PROGRAM my_game; GLOBAL STRUCT structure1[9,9]; n; //... END BEGIN //... structure1[0].n=0; // Error: A comma was expected. END - Check the previous declaration of the named structure of data in the program. ---See: syntax","title":"A comma was expected"},{"location":"help/#cannot-calculate-the-offset-of-the-data","text":"In the expression indicated in the program the operator offset is used (or synonymous symbol & ) with the goal to obtain the location (dislocation) of a character , byte or word which belongs to a table. It is only possible to obtain the location at the beginning of the table, but not of its data (except such data as int ). Shown below is a program with two examples of the use of the operator offset (or the symbol & ) for tables of such type byte ; one valid, another not. Example: PROGRAM my_game; GLOBAL BYTE my_table[99]; offset_data; BEGIN // Correct example offset_data=offset my_table; // Erroneous example offset_data=offset my_table[1]; END - It is also applicable to text strings (data like string ), meaning, it is not possible to obtain the location of a character inside of the string. In this case, the operator offset is not necessary to obtain the dislocation of a string of text (it can be omitted). It means, that both of these two statements would be valid: offset_string = offset my_string ; offset_string = my_string ; Note: To operate with the text strings one has to use the functions of the language which were written to manipulate text (see for example strcpy() ). ---See: syntax - offset","title":"Cannot calculate the offset of the data"},{"location":"help/#assignation-to-incorrect-string","text":"With text strings you can only realise assignations of three types: Conventional assignations (=), a copy of the string to the right of the = sign will be made to the left-hand string. Sum and assignation (+=), the substring on the right hand side will be added to the left-hand string. Subtraction and assignation (-=), characters of the string will be removed. If another type of assignation is attempted this error will be given. ---See: syntax - Definition of expression","title":"Assignation to incorrect string"},{"location":"help/#text-string-is-too-long","text":"To define a string of text indicating in brackets its length, one must use a whole number less than 1048576 , remembering that all strings start from the position zero and finish in the position which indicates the index. Example: PROGRAM my_game; GLOBAL STRING string1[29999999]; // Error: text string is too long. BEGIN //... END - The compiler detected a text string that was too long, such as string1 ; the maximum that can be declared is a string of text of 1 Megabyte, with such declaration: STRING string1 [ 1048575 ]; string1 can contain up to 1024*1024 characters, from string1[0] to string1[1048575]. ---See: syntax","title":"text string is too long"},{"location":"help/#incorrect-initiation","text":"The number of values indicated in the initiation does not coincide with the previous declaration of the structure. Example: PROGRAM my_game; GLOBAL STRUCT my_structure[9]; STRING name; x,y; END = 10 dup (\"AAA\",0); // Error: Incorrect initiation. BEGIN //... END - In the last example the program declares a structure of three fields, and then initiates it as if it had only two fields. You must check the original declaration, always remembering that a structure as my_structure[9] has 10 registers (from 0 to 9 ). For example, the valid initiation for the structure would be: 10 dup ( \"AAA\" , 0 , 0 ); ---See: syntax","title":"Incorrect initiation"},{"location":"help/#expecting","text":"The compiler expects a semicolon (;) in the position indicated in the program. In the language you must indicate the end of a declaration of data with a semicolon. ---See: syntax - ;","title":"expecting [;]"},{"location":"help/#expecting-a-compilation-option","text":"The compiler was expecting a compilation option in the indicated position of the program. See the options of compilation disposed in this version of the language. ---See: syntax - Headline of program","title":"Expecting a compilation option"},{"location":"help/#expecting_1","text":"To set a maximum number of processes you must use the statement compiler_options as it is shown in this program: Example: COMPILER_OPTIONS _max_process = 100; PROGRAM my_game; BEGIN //... END - In this case it was established that during the execution of the program ** a maximum of 100 processes** can execute simultaneously. ---See: syntax","title":"Expecting [=]"},{"location":"help/#assignation-inside-of-a-condition","text":"The compiler detected, in the fly out position of the program, a statement of assignation inside of one condition. Probably was intended to compare two values using for it the assignation symbol = , instead of the symbol of comparison / equivalence == . Note for new users: If you want to compare two values with the symbol = , you must include in the program the option _simple_conditions . For it you must put in the first line (before PROGRAM ... ) this statement: COMPILER_OPTIONS _simple_conditions; Note for users of the previous version: In this new version of the language are prohibited the assignations inside of one condition , to simplify the program syntax for new users. But it can be changed with the options of compilation (see _extended_conditions and _simple_conditions ). ---See: syntax - Compiler_options","title":"Assignation inside of a condition"},{"location":"help/#the-length-does-not-coincide-with-the-previous-declaration","text":"a text string or pointer was declared twice , as a parameter and as private data, and in the declarations a different length was specified. It is not necessary to declare this data as private, because you can specify its length in the same parameters of the process. Example: PROGRAM name_of_program; BEGIN //... END PROCESS my_process(string my_string[16]) BEGIN //... END - The process of this example receives a parameter in a private string (but this is not indicated in the process) of 17 characters in length (from my_string[0] to my_string[16]). The previous process can return to declare this string in the section PRIVATE (for example, to add an explanatory commentary), but in this case the specified lengths must coincide. In this case, my_string will be declared as shown below. Example: PROGRAM name_of_program; BEGIN //... END PROCESS my_process(string my_string[16]) PRIVATE string my_string[16]; // Here I will receive some text. BEGIN //... END - ---See: syntax - Declaration of private data","title":"The length does not coincide with the previous declaration"},{"location":"help/#expecting-a-name","text":"To define a table or group of bytes you must specify its name after the reserved word BYTE . Example: PROGRAM my_game; GLOBAL BYTE my_byte; BYTE my_table1[127]; BYTE my_table2[255,255]; BEGIN //... END - In this example three variable of this type were defined. The first is the name my_byte which can contain only the values (between 0 and 255), the second with the name my_table1 can contain up to 128 values from (from my_table1[0] to my_table1[127]), and the third, which is a table of bytes of two dimensions, can contain a total of 65536 values (the result of multiplying 256 by 256). ---See: syntax - Names","title":"Expecting a name"},{"location":"help/#value-of-byte-out-of-rank-0255","text":"a variable of type BYTE was initiated with a value too big, or negative. This type of data can only contain values inside the rank 0 ... 255 . Example: PROGRAM my_game; GLOBAL BYTE mi_value=300; // Error: Value of byte out of rank (0...255). BEGIN //... END - If you want to assign this value to the data, you must not declare the data of this type BYTE , as is shown in this program. Example: PROGRAM my_game; GLOBAL my_value=300; BEGIN //... END - As this form creates a variable which can contain a whole number value inside the rank ( min_int ... max_int ). ---See: syntax","title":"Value of BYTE out of rank (0...255)"},{"location":"help/#value-of-word-out-of-rank-065535","text":"A WORD was initiated with a value too big or negative. This type of data can only contain values inside the rank 0 ... 65535 . Example: PROGRAM my_game; GLOBAL WORD my_value=70000; // Error: Value of word out of rank (0...65535). BEGIN //... END - If you want to assign this value to the data, you must not declare the data as type BYTE , as is shown in this program. Example: PROGRAM my_game; GLOBAL my_value=70000; BEGIN //... END - As this form creates a data which can contain a whole number value inside the rank ( min_int ... max_int ). ---See: syntax","title":"Value of word out of rank (0...65535)"},{"location":"help/#expecting-a-name_1","text":"To define a table of bytes you must specify its name after the reserved word WORD . Example: PROGRAM my_game; GLOBAL WORD my_word; WORD my_table1[127]; WORD my_table2[255,255]; BEGIN //... END - In this example three variable of this type were defined. The first is the name my_word and can only contain a value (between 0 and 65535), the second with the name my_table1 can contain up to 128 values (from my_table1[0] to my_table1[127]), and the third, which is a table of bytes of two dimensions, can contain a total of 65536 values (because it is the result of multiplying 256 by 256). ---See: syntax - Names","title":"Expecting a name"},{"location":"help/#cannot-specify-a-table-as-the-parameter","text":"The parameters of the process must be declared as variables, not as tables or structures, and cannot be initiated (because they will receive their value with each call). Example: PROGRAM my_game; BEGIN //... END PROCESS my_process(a[9]) // Error: Cannot specify a table as the parameter. BEGIN //... END - The compiler interprets the parameter a as a table of 10 positions, and cannot pass a table as the parameter, so emits the error. ---See: syntax - Parameters of a process","title":"Cannot specify a table as the parameter"},{"location":"help/#statement-import-is-incorrect-see-corresponding-help","text":"The declaration of external libraries must be done {below the headline of the program}, in other words, after the declaration PROGRAM name_of_program; . Different declarations of IMPORT can be used to declare the use of more than one library, as in this example. Example: // Headline of the program PROGRAM my_game; // Declaration of libraries IMPORT \"lib1.dll\"; IMPORT \"lib2.dll\"; //... // And in continuation (optional) the rest of the sections that make up the program. CONST //... GLOBAL //... LOCAL //... PRIVATE //... BEGIN //... END - This program declares the use of the denoted libraries lib1.dll and lib2.dll (supposed names of hypothetical libraries with external functions). Note 1: In the original version of DIV, this declaration had to be done between sections LOCAL and PRIVATE of the program. Note 2: The libraries prepared in the original (DIV1) version of the language will not function correctly in DIV2, it is necessary first to re-compile these libraries with new files of declarations. It means, that the font code of the libraries will be valid, but beforehand they must be re-compiled with new headline files (because they contain declarations for the new data and structures which exist in the DIV2 language). ---See: syntax - Declaration of libraries","title":"statement IMPORT is incorrect (see corresponding help)"},{"location":"help/#expecting-a-name_2","text":"To declare a pointer you must specify its name after the reserved word POINTER (or the symbol * ). Example: PROGRAM my_game; GLOBAL POINTER ptr; WORD POINTER my_words[15]; BYTE POINTER my_bytes; BEGIN //... END - In this example three variable of this type were defined. The first with the name ptr is a pointer to any conventional data, and it has no limitation of rank in its access (you can access ptr[ n ]with n being any value). The second is a pointer to data of type WORD (whole value between 0 and 65535) with a limitation of access to the first 16 values only. And the third is a pointer of data of type BYTE (whole between 0 and 255) without limitation of rank. ---See: syntax - Names","title":"expecting a name"},{"location":"help/#expecting-a-name_3","text":"To declare a data type you must specify its name after the reserved word INT , but in this case it is not so important (because all the data by default will be of the same type). Example: PROGRAM my_game; GLOBAL INT a,b; // declare two whole number data c,d; // declare another two whole number data BEGIN //... END - In this example you can see 4 data of the type whole number declared, for the first two ( a and b ) the type was specified as (INT) (as in \"integer\"), but there is no difference, in the level of declaration, with the last two ( c and d ), because these would also be data of the type (INT). ---See: syntax - Names","title":"expecting a name"},{"location":"help/#incorrect-declaration-of-the-pointer-to-a-structure","text":"The compiler was expecting, at the indicated position of the program, the name of a structure previously declared, with the intention of declaring it as a pointer. To define a pointer to a data structure you must use the following syntax: STRUCT POINTER name_structure name_pointer; name_structure being the name of a data structure declared previously in the program, and name_pointer being the name of a pointer to the structure which is being declared. ---See: syntax - Names - Declaration Structures","title":"Incorrect declaration of the pointer to a structure"},{"location":"help/#cannot-receive-a-structure-as-the-parameter","text":"A process cannot receive a structure as its parameter, if you want to access an external structure from a process, the process must receive as its parameter a pointer to the structure. Example: PROGRAM my_game; GLOBAL STRUCT positions[9] x, y; END BEGIN my_process(OFFSET positions); //... END PROCESS my_process(STRUCT POINTER positions pos[9]); BEGIN //pos[ ... ].x = ... ; //... END - In this example you can access the structure inside my_process using the pointer pos . ---See: syntax - Names - Declaration Structures","title":"Cannot receive a structure as the parameter"},{"location":"help/#expecting-a-name-of-structure","text":"The indicated function requires as its parameter, at the indicated position, the name of a data structure of the program. You do not have to use the operator offset , you just need to indicate the name of the structure. Example: PROGRAM my_game; GLOBAL STRUCT records[9] STRING initials[2]; points; END BEGIN //... qsort(offset records,points,1); // Error: expecting a name. END - In this example the function qsort is used, which requires the name of a structure as its first parameter. In this case, the correct instruction to order the table records is this one: qsort(records,points,1); This instruction indicates how to order the structure, namely as a function of the field points and in descending order. Note 1: Also it is possible that the indicated name has nothing to do with a structure of data, but with the another type of object (for example, the name specified was of a table of data). Note 2: This data structure cannot belong simultaneously to another structure, so you cannot specify the name of a structure inside another one. ---See: syntax","title":"expecting a name of structure"},{"location":"help/#expecting-a-field-of-the-structure","text":"The indicated function requires as its parameter, in the indicated position, the name of a field pertinent to the structure previously indicated . You don't have to use the operator offset , you only need to indicate the name of the field. Example: PROGRAM my_game; GLOBAL STRUCT records[9] STRING initials[2]; points; END BEGIN //... qsort(records,&points,1); // Error: expecting a field of the structure. END - In this example the function qsort is used, which requires the name of a field of the structure as its second parameter. In this case, the instruction to order the table (records) would be : qsort(records,points,1); This instruction indicates how to order the structure, as a function of the field points and in descending order. Note: the indicated name does not always have to be a data structure. ---See: syntax","title":"expecting a field of the structure"},{"location":"help/#syntax-of-a-program","text":"Now, the general structure of a program is shown in the language. To see the corresponding syntactic definition, click on the section of your interest with the mouse. All the programs must respect the previous structure with an exception: it is possible to put explanatory comments in any point of the program. ---See: Index - Glossary","title":"Syntax of a program."},{"location":"help/#definition-of-a-name","text":"A name is a sequence of alphanumeric characters used to identify an object of the program, such as the name of a process, constant or variable. These names can be made up of the following characters: Symbols: _ # \u00aa \u00ba $ \u20a7 \u0192 \u00a3 \u00a5 \u00a2 Digits: 0123456789 Letters: abcdefghijklmnopqrstuvwxyz Letters (extended): \u00f1 \u00e7 \u00e6 \u00e2\u00e4\u00e0\u00e5\u00e1 \u00ea\u00eb\u00e8\u00e9 \u00ee\u00ef\u00ec\u00ed \u00f4\u00f6\u00f2\u00f3 \u00fb\u00fc\u00f9\u00fa \u00ff provided that the following rules to create new names are respected: The sequence of characters must not contain characters that are not in the previous list (except capital letters corresponding to lower case letters included in the list). Inside the sequence, it is not possible to put blanks. That is to say, enemy spacecraft is not a valid name as, for the compiler, it would imply two names. In this case, the name can be declared as enemy_spacecraft . A name can not start with a numeric digit. That is to say, 0a is not a valid name. Nevertheless, all the necessary digits can be included in the name after the first character ( a0 is indeed a valid name). The name must not coincide either with any of the language's reserved words or with any of the objects (constants, variables, etc.) predefined in the language. To check it, see the list of reserved words and predefined objects, being possible to access the Glossary at any moment. The reserved words appear in capital letters and the predefined objects in lower case letters. There is no difference between the capital and lower case letters (for the compiler, ABc and abC are the same name). The same name can not be used for two different objects. For instance, it is not possible to name a constant value and then, to declare a process PROCESS value(x, y); . ---See: Syntax - Glossary","title":"Definition of a name."},{"location":"help/#definition-of-comments","text":"A comment is an explanatory note about the program. The comments are not necessary for the program's correct working. There are two kinds of comments: Of a single line: they start with the symbol // and finish at the end of the line in which they are defined. Of several lines: they start with the symbol / and finish with the symbol / . Example: / This is an example of a comment of several lines in which explanations about the program can be given / PROGRAM my_game; // Example of a single line comment. BEGIN // The main program starts. FRAME; END // The main program finishes. - All the texts included in a comment are ignored by the compiler. As many comments as necessary can be put, in any point of the program. The comments starting with / and finishing with /** (comments of several lines) can also start and finish in the same line. ---See: Syntax","title":"Definition of comments."},{"location":"help/#programs-head","text":"PROGRAM ; All the programs must start with the reserved word PROGRAM followed by the name of the program and a symbol ; (semicolon) . This head is obligatory in all the programs. Before it, only one or several comments (explanatory texts preceded by the symbol // , or between the symbols / and /**) can optionally appear. In the names and reserved words there is no difference between capital and lower case letters, so PROGRAM , program , Program , ... are valid words. Example: // ------------------- // Listing of my game // ------------------- PROGRAM name_of_my_game; BEGIN //... END - ---See: Syntax","title":"Program's head."},{"location":"help/#declaration-of-constants","text":"CONST = ; ... This section of the programs is optional, as its utility deals with setting a series of synonymous for some numeric values. In a game, for instance, number 3 has been set in one or several points of the program as the maximum lives of the protagonist. If the aim is to modify this number, increasing or decreasing it, it will be necessary to look for this number and to replace it in the program. But there is a risk of replacing other '3' numbers appearing in the program with different aims. An alternative is to declare a constant called, for instance, maximum_lives as a synonymous of the numeric value 3 and use that constant in the program instead of the number. Now, if the aim is to replace this value by another one, it is done simply in the declaration of the constant maximum_lives . This section then establishes a list of names that are going to represent a series of numeric constants. This section must obligatory start with the reserved word CONST and then, for every declared constant, its name followed by the symbol = (assignment symbol) and a constant expression (numeric value) must appear. After the declaration of every constant, the symbol ; (semicolon) must appear. Example: PROGRAM my_game; CONST maximum_lives=3; BEGIN //... END - Once a value has been assigned to a constant, it won't later be possible to modify the former in the program. ---See: Syntax - Glossary","title":"Declaration of constants."},{"location":"help/#definition-of-a-constant","text":"A constant is a constant value or a numeric expression. As values, only integers within the range ( min_int ... max_int ) can be used. The constant numeric expressions are mathematical formulas in which it is possible to use: Constants previously defined. Numeric values . Arithmetic or logical operators . Literals (texts in inverted commas). The sizeof() function. These expressions will be evaluated when the program is compiled and their result will be used in the program's execution. The operators that can be used in a constant expression are the following ones (the synonymous of the operator, if they exist, are shown in brackets). + Addition - Subtraction (or negative sign) * Multiplication / Division MOD Module ( % ) << Rotation to the right >> Rotation to the left NOT Binary and logical negation ( ! ) AND AND binary and logical ( & , && ) OR OR binary and logical ( | , || ) XOR Exclusive OR ( ^ , ^^ ) == Comparison <> Different ( != ) > Greater than >= Bigger or equal ( => ) < Less <= Less or equal ( =< ) OFFSET Direction or offset ( & ) ( ) Brackets Now, some examples of valid constants are shown: ** 0** ** -1000** ** 2+2** ** \"Hello!\"** ** 4 (2+1) * ... ---See: Syntax - Glossary","title":"Definition of a constant."},{"location":"help/#declaration-of-global-data","text":"GLOBAL ; ... This section of the programs is optional. Global data, the data that can be used from any point of the program , are declared in this section. A section must obligatory start with the reserved word GLOBAL followed by a series of declarations of data finished with a symbol ; (semicolon). In general, all those data that establish general conditions of the game related to several processes are declared as global data. An example could be the score obtained by the player, that could be stored in the score global variable. Thus, any process of the game could increment it, if necessary. A declaration of global data will define a single data that can be used for all the program's processes. But, a declaration of local data will define a variable of this kind and name for each of the program's processes. Example: PROGRAM my_game; GLOBAL score=0; BEGIN //... END - ---See: Syntax - Glossary","title":"Declaration of global data."},{"location":"help/#declaration-of-local-data","text":"LOCAL ; ... This section of the programs is optional, as local data, the data that all the program's processes have are declared here, each one with its own values (as the x and y predefined local variables determine the coordinates of all the processes). A section must obligatory start with the reserved word LOCAL followed by a series of declarations of data finished with a symbol ; (semicolon). In general, the important information of the processes, the data to be consulted or modified from other processes, are declared as local data. The energy remaining a process (a spacecraft, a shotgun, the character, etc.) could be an example. This information could be stored in the energy local variable, so any process can access or modify the energy of the rest (for instance, on colliding with them, energy could be subtracted). Example: PROGRAM my_game; LOCAL energy=0; BEGIN //... END - If a variable declared as local is to be used only inside one process, then the former can be defined as a private data (inside the section PRIVATE of that process). ---See: Syntax - Glossary","title":"Declaration of local data."},{"location":"help/#declaration-of-private-data","text":"PRIVATE ; ... These sections of the programs are optional. Private data, data that are going to be used exclusively inside a process , can be declared in this section. This section is defined just before the BEGIN of the process that is going to use these data and must start with the reserved word PRIVATE followed by a series of declarations of data finished with a symbol ; (semicolon). The main program is also considered as a process. Its declaration of private data can go just before its BEGIN . In general, all the data that are going to contain information necessary only for a process, as well as those that can not be accessed from any other process, are declared as private data. Those variables that are going to be used as counters in a loop, variables to contain angles or secondary identifying codes, etc. are normally defined as private data. Example: PROGRAM my_game; PRIVATE n; BEGIN FROM n=0 TO 9; //... END //... END PROCESS my_process() PRIVATE id2; angle2; BEGIN id2=get_id(TYPE my_process); IF (id2<>0) angle2=id2.angle; //... END //... END - If you need to consult or modify a variable declared as private from another process (variable.identifier), then that data will have to be declared local (inside the program's section LOCAL ). Thus, all the processes will have the data and every process can access its value or the value that this data has in another process. ---See: Syntax - Glossary","title":"Declaration of private data."},{"location":"help/#declaration-of-a-variable","text":"In a declaration of a variable, three different kinds of objects can be shown: In general, a variable will store a simple numeric value. A table will store a list of numeric values. And a structure will store a list of records of several fields (such as a list of index cards with varied information). All the data will be declared with a name which, from that moment, will become the means to access or modify the information contained in those data. Each data will belong to a specific area, depending on the fact that its declaration has been made inside the GLOBAL , LOCAL or PRIVATE .. sections. It is possible to access all the global data from any point of the program. Local data belong to all the processes (every process has its own value in them). Finally, private data belong to a single specific process. ---See: Syntax","title":"Declaration of a variable."},{"location":"help/#declaration-of-a-variable_1","text":"(or, if the aim is to initialise) = To declare a variable inside a GLOBAL , LOCAL or PRIVATE section, suffice will be to indicate its name inside that section. In this case, the variable will be initialised at 0 (zero). To initialise the variable at other values, the symbol = (assignment) will be put after the name of the variable. The constant value at which the variable is intended to be initialised will be put after this symbol. A variable is a cell (or position) of the computer's memory to which we refer by its name and that can contain whole numeric values within the range ( min_int ... max_int ). ---See: Syntax - Glossary","title":"Declaration of a variable."},{"location":"help/#declaration-of-a-table","text":"[] (or, if the aim is to initialise the table) [] = (or, if it is initialised without defining its length) [] = To declare a table inside a GLOBAL , LOCAL or PRIVATE section, suffice will be to indicate its name followed by the length of the table in square brackets (symbols [] ). In that case, all the positions of the table will be initialised at 0 (zero). The table's length is expressed as the maximum value of its index. That is to say, all the tables range from the position 0 to the position indicated in the square brackets in their declaration. For instance, a table declared as my_table[9] , will be a table of length 10 (of 10 positions, from my_table[0] to my_table[9]). If the aim is to initialise the different positions of the table, it is necessary to put the symbol = (assignment) after the previous declaration and, after this symbol, a list of constants . If the table is initialised with a list, then it is not necessary to indicate the table's length in square brackets, as the compiler will create a table with as many positions as the number of values included in the list. A table is a series of cells (or positions) of the computer's memory that is called by its name, appearing after it, in square brackets, the number of cell inside the table intended to be accessed. Every table's cell is a variable that can contain whole numeric values within the range ( min_int ... max_int ). For instance, if we declare a table as the following one: my_table[]=33, -1, 6, -3, 99; We will be declaring a table whose name is my_table and that has 5 cells (or positions), from cell no. 0 to cell no. 4. In the previous declaration, cell 0 ( my_table[0] ) is initialised with the value 33 , cell 1 ( my_table[1] ) with the value -1 , etc. The language allows us to access cell 0 simply with the name of the table ( my_table ), as if it was a variable, omitting the zero in square brackets that should appear after. That is to say, for the compiler, my_table[0] will be the same as my_table (the first cell of the table). ---See: Syntax - Glossary","title":"Declaration of a table."},{"location":"help/#declaration-of-a-structure","text":"STRUCT [] ; ... END (or, if you initialise the structure) STRUCT [] ; ... END = To declare a structure inside a GLOBAL , LOCAL or PRIVATE section, it is necessary to put the reserved word STRUCT preceding its name. After it, the number of records of the structure must be indicated, in square brackets (symbols [ ] ). After this head defining the name of the structure and the number of records, all the data that belong to the structure and that will comprise its fields, will be declared. Finally, the reserved word END must appear to finish the declaration. The records' number of the structure is expressed as the maximum records' number of the structure. That is to say, all the structures have from record 0 to the record indicated in the square brackets. For instance, a structure declared as STRUCT my_structure[9] , will be a structure of 10 records (from the record my_structure[0] to my_structure[9]). A structure is like an index card file (records), each of them with different written information (fields). For instance, a structure in which we could include the initial and final positions of a series of processes of a game could be as follows (an index card file with 10 cards, each of them indicating the (x, y) initial and the (x, y) final of a process): STRUCT movement_enemies[9] x_initial; y_initial; x_final; y_final; END This structure, that would be accessed with the name movement_enemies , has ten records and four fields in each record (two coordinates that determine the initial position of the process [x_initial ,y_final], and two that determine the final position [x_final, y_final]). Movement_enemy[0].x_final would be used to access the x final of the first enemy. The language allows us to access the record 0 of the structure simply with the name of the structure ( movement_enemies.x_final ), omitting the zero in square brackets that should come later. That is to say, for the compiler movement_enemies[0].x_final will be the same as movement_enemies.x_final . Each field of the structure may be a variable, a table or another complete structure, with its different records and fields. If the aim is to initialise the structure (establishing the initial values of its fields in the different records), the symbol = (assignment) must be put after the reserved word END followed by a list of constants . If the structure is not initialised in this way, all the fields will be put at 0 by default. Keep in mind that , in order to initialise a structure, the first values will be the values of the fields of the first record, the following ones those of the second record, and so on. For instance, if the following declaration is made: STRUCT a[2] b; c[1]; END = 1, 2, 3, 4, 5, 6, 7, 8, 9; First, it must be taken into account that the structure a has 3 records (from a[0] to a[2]) and that there are three fields (b, c[0] & c[1]) in each record. Then, the previous declaration will initialise the structure in the following way: a[0].b=1; a[0].c[0]=2; a[0].c[1]=3; a[1].b=4; a[1].c[0]=5; ... ---See: Syntax - Glossary","title":"Declaration of a structure."},{"location":"help/#definition-of-a-list-of-constants","text":"A constant is a constant value or numeric expression (see ). The lists of constants are basically a series of constants separated by commas (,) and they are used to initialise the values of tables or structures. An example of a list of constants is shown below: 1, 2, 3, 4, 5; But, besides this basic definition, the use of the operator DUP is allowed to repeat a series of constants a specific number of times. For instance, the following list: 0, 100 DUP (1, 2, 3), 0; It is a list of 302 constants (0, 1, 2, 3, 1, 2, 3, ..., 1, 2, 3, 0). That is to say, that the operator DUP (duplication) allows us to repeat the sequence appearing after it in brackets, the indicated number of times. It is possible to nest operations DUP . For instance, the following list: 2 DUP (88, 3 DUP (0, 1), 99); would be equivalent to: 88, 0, 1, 0, 1, 0, 1, 99, 88, 0, 1, 0, 1, 0, 1, 99; Moreover, the omission of the operator DUP , that 2 DUP (0, 1) is equivalent to 2(0, 1) , is allowed. The operator DUP is specially useful to initialise structures. If, for instance, the aim is to initialise the following 100 record structure: STRUCT a[99] b; c[9]; d[9]; END With the fields b initialised at 0 , the fields c[9] at 1 and the fields d[9] at 2 , the following list of initialisation would be used: 100 DUP (0, 10 DUP(1), 10 DUP(2)); ---See: Syntax","title":"Definition of a list of constants."},{"location":"help/#declaration-of-libraries","text":"IMPORT The creation of libraries of functions for the language is a very advanced issue, only for programmers with broad experience in the C language and/or Assembler . The libraries must be distributed with two files: the first one, with extension DLL , containing the own library and, the second one, with the same name but with extension TXT , that must be a text file ascii (MS-DOS), explaining the purpose and working of the library. All the provided functions, the installation process and the use of the library must be explained in the second file. The libraries must be imported from the language, by inputting the reserved word IMPORT (after the declaration of local and global data) followed by the path of the file DLL . If the file with extension DLL has been copied in the directory of DIV Games Studio , then it is not necessary to specify the library's path. Example: PROGRAM my_game; IMPORT \"hboy.dll\"; BEGIN //... END - From the moment when the libraries of functions can freely be developed, {the correct working of DIV Games Studio is not guaranteed if external libraries DLL are used}. The incorrect working of the programs' debugger can be usual when a DLL which modifies vital parts of the library of functions or of the processes' manager of DIV Games Studio is stored in a game. Note 1: In the first version of the DIV programming language, this declaration had to be done between the LOCAL and PRIVATE sections of the program. Note 2: The libraries prepared for the first version of the language {will not function correctly} in later versions, you must first re-compile these libraries with the new declarations. In other words, the font code of the libraries will still be valid, but they must be re-compiled with new the headline files (because they contain the declarations for the new data and structures which exist in the language). Note 3: If you are a programming expert in C and Assembler, you can get more information about the creation of new libraries in the file DLL\\SOURCE\\Readme.TXT on the DIV CD. ---See: Syntax","title":"Declaration of libraries."},{"location":"help/#main-code","text":"BEGIN ; ... END The main code of a program starts with the reserved word BEGIN . After it, any number of statements may appear. The main code finishes with the reserved word END . This code controls the main process of the program, which initialises the program, controls the loops of the menu and game, and finishes the program. Example: PROGRAM my_game; GLOBAL option; // Option chosen in the menu. BEGIN // Beginning of the main code. set_mode(m640x480); // Beginning. set_fps(24, 4); // ... // Loads files, sounds, etc. REPEAT // Beginning main loop. option=0; // Control loop of the options menu. //... // Begins the options menu. REPEAT // ... IF (key(_enter)) option=1; END // Playing is chosen. IF (key(_esc)) option=2; END // Finishing is chosen. FRAME; UNTIL (option>0); IF (option==1) // If the playing option has been chosen. // Starts regions, scroll, etc. // Creates the game processes. // Loop of game's control, expecting for its end. END UNTIL (option==2); // End of the main loop. let_me_alone(); // Finishes all the processes. END // End of the main code. // ... // Declaration of the program's processes. - The end of the main code's execution does not imply the end of the program's execution, as it will continue if there are alive processes. To force the end of the program when the code finishes, it is possible to use, for instance, the let_me_alone() function just before the END that marks the main code's end, to eliminate the rest of processes that may remain alive. The execution of the program can also be finished at any of its points with the exit() function, which will automatically eliminate all the processes. ---See: Syntax","title":"Main code."},{"location":"help/#declaration-of-processes","text":"Two types of code blocks exist (besides the main code ): the PROCESS blocks (which will be detailed below), and the FUNCTION blocks. PROCESS ( ) BEGIN ; ... END A process must start with the reserved word PROCESS followed by its name and its call parameters in brackets. The parameters are a list of data in which the process is going to receive different values. The brackets are obligatory even if the process has no parameters. After this header, a PRIVATE section, declaring data to be used by the process exclusively, may be put optionally. And finally, the process code, that is a sequence of statements between the reserved words BEGIN and END , will be specified. A process normally corresponds with a kind of object of the game, such as a spacecraft, an explosion, a shot, etc. Inside the process' code, a loop (in which all the necessary values to display this object, such as graphic, coordinates, etc., will be established) is normally implemented. Then, with the FRAME statement, the order to display the object with the established attributes is given. Example: PROGRAM my_game; PRIVATE id2; BEGIN load_fpg(\"help/help.fpg\"); id2=my_process(160, 100); write_int(0,150,10,4,offset id2); write(0,100,10,4,\"Process ID=\"); // ... END PROCESS my_process(x, y) PRIVATE n; BEGIN graph=100; FROM n=0 to 99; x=x+2; y=y+1; FRAME; END END - As it can be noticed in this example, when a process is called, it returns its identifying code (that, in the example, is stored in the PRIVATE variable of the main program id2 ). If the aim is to implement a process in the style of the functions of other languages that returns a numeric result, then it is necessary to use the RETURN( ** statement, not using the FRAME statement inside the process, as this statement returns to the father process (caller), returning the process' identifying code as return value. ---See: Syntax - The blocks FUNCTION","title":"Declaration of processes."},{"location":"help/#declaration-of-statements","text":"A statement is an order to be executed by the computer in a program. The possible types of statements are the following ones: Assignment statements = Control statements IF SWITCH Loop statements LOOP FROM REPEAT WHILE FOR Break statements BREAK CONTINUE RETURN Special statements FRAME CLONE DEBUG Call statements Call to a process The statements always appear as a group of statements, from none (which makes no sense) to as many as necessary. All the statements will sequentially be executed (the first one, the second one, the third one ...), with the exception of the statements that can control the flow of the program (control, loop and break statements). ---See: Syntax","title":"Declaration of statements."},{"location":"help/#parameters-of-a-process","text":"The parameters of a process are basically a list of data in which the process will receive different information every time it is called or used from another process. The processes can receive parameters in the following types of data: A predefined local variable (such as x , size , flags , ...). A local variable defined inside the LOCAL section. A global variable defined inside the GLOBAL section. A process' private variable declared inside the PRIVATE section of the process itself. A private variable not declared inside the PRIVATE section. In all these cases, it is understood that a variable may be referred to a variable, to a specific position of a table or to an element inside a structure. As an example of the different types of parameters, a program with a process that receives five parameters different from the types respectively indicated in the previous list, is now shown. Example: PROGRAM my_game; GLOBAL score=0; LOCAL energy=0; BEGIN my_process(1, 2, 3, 4, 5); // ... END PROCESS my_process(x, energy, score, n, m) PRIVATE n; BEGIN // ... END - The process my_process receives five parameters in five variables: predefined local, local, global, private declared and private not declared variables. Receiving a parameter (such as the GLOBAL score variable) in a global data is equivalent to make the assignment ( score=3; ) and then, call the process. ---See: Syntax","title":"Parameters of a process."},{"location":"help/#assignment-statement","text":"The assignment statements are used to calculate expressions and to assign them to a variable. = ; The data in which the result of the expression is going to be stored must be indicated, followed by the symbol = (symbol of the assignment ), as well as the numeric or logical expression to evaluate when the statement is executed. After this statement, the symbol ;(semicolon) must always be put. In an assignment statement it is only allowed to assign values to objects such as any kind of variables, to a position of a table , or to an element of a structure . It is not possible to assign a value to a constant , to a function or to a process or, in general, to any numeric or logical expression . Now, a program with several assignments is shown. Example: PROGRAM my_game; BEGIN x=x+1; angle=(angle 3)/2-pi/2; size=(x+y)/2; z=abs(x-y) 3-pow(x, 2); // ... END - This is the basic form of the assignments, even if there are other symbols of assignment that, instead of assigning a new value to the referred variable, modify its value. These are the symbols of operative assignments : += Adds to the variable the result of the expression x=2; x+=2; -> (x==4) -= Subtracts from the variable the result of the expression x=4; x-=2; -> (x==2) *= Multiplies the variable by the result of the expression x=2; x*=3; -> (x==6) /= Divides the variable by the result of the expression x=8; x/=2; -> (x==4) %= Puts in the variable the remainder of dividing it by the result of the expression x=3; x%=2; -> (x==1) &= Performs an AND (binary and/or logical) between the variable and the result of the expression, assigning it as a new variable's value x=5; x&=6; -> (x==4) |= Performs an OR (binary and/or logical) between the variable and the result of the expression, assigning it as a new variable's value x=5; x|=6; -> (x==7) ^= Performs an exclusive OR (XOR binary and/or logical) between the data and the result of the expression, assigning it as a new variable's value x=5; x^=3; -> (x==3) >>= Rotates the variable to the right as many times as indicated by the result of the expression (each rotation to the right is equivalent to dividing the variable by 2) x=8; x>>=2; -> (x==2) <<= Rotates the variable to the left as many times as indicated by the result of the expression (each rotation to the left is equivalent to multiplying the variable by 2) x=2; x<<=2; -> (x==8) Within the category of assignment statements, the increments and decrements of a variable are also allowed. For instance, if we wanted to add 1 to the local variable x we could do it either with the x=x+1; or x+=1; statements, or with the operator of increment: x++; o ++x; . That is to say, increments ( ++ ) or decrements ( -- ) of a variable are accepted as assignment statements. ---See: Syntax","title":"Assignment statement."},{"location":"help/#if-statements","text":"IF ( ](#)) ; ... END (or) IF ( ](#)) ; ... ELSE ; ... END The IF statement is used to run a block of statements optionally, when a condition is complied. In the second aforementioned variant, another block of statements will also be executed (inside the ELSE section) when the condition is not complied. A program with several IF statements is now shown. Example: PROGRAM my_game; BEGIN IF (key(_esc)) exit(\"Good by!\", 0); END IF (x>100 AND x<220) y=y+4; ELSE y=y-8; END IF (size>0) size=size-1; END IF (timer[5]>1000) z=1; ELSE z=-1; END // ... END - It is possible to nest IF statements with no limits. That is to say, more IF statements can be put inside the part that is running when the condition is complied ( IF part ) or inside the one that is executed when the condition is not complied (part ELSE ). ---See: Syntax","title":"IF statements"},{"location":"help/#switch-statement","text":"SWITCH ( ](#)) CASE : ; ... END ... DEFAULT : ; ... END END A SWITCH statement is made up with a series of CASE sections and, optionally, of a DEFAULT section. When a SWITCH statement is executed, the expression is first evaluated and then, if the result is within the range of values included in the first CASE section, its statements will be executed and the statement will finish. If the result of the expression is not in the first CASE , it will be looked for in the second, third, etc. CASE . Finally, if there is a DEFAULT section and the result of the expression has not coincided with any of the CASE sections, then the statements of the DEFAULT section will be executed. Example: PROGRAM my_game; BEGIN SWITCH (x) CASE 1: x=-1; END CASE 2: x=-2; END CASE 3: x=-3; END CASE 99: x=-99; END DEFAULT: x=0; END END END - The SWITCH statement of this program will change the sign of the x variable if it is equal to 1 , 2 , 3 or 99 . Otherwise, the statement will put the variable at 0 . Range of values of a case section --- A value, a range of values (minimum .. maximum), or a list of values and/or ranges separated by commas (,) may be specified in a case section. For instance, the previous statement could have been expressed as follows: SWITCH (x) CASE 1..3, 99: x=-x; END DEFAULT: x=0; END END Once one of the CASE sections of a SWITCH statement has been executed no more sections will be executed , even if they also specify the result of the expression, for instance, in the following statement: SWITCH (2+2) CASE 3..5: x=x+1; END CASE 2, 4, 6: y=y-1; END END The x=x+1; section will be executed and then, the statement will finish and the y=y-1; section won't be executed as, even if the result of the evaluated expression ( 4 ) is included in it, it is also included in the previous section, (as 4 is within the range 3..5). It is not necessary to arrange the CASE sections according to their values (smaller to larger, or larger to smaller), but it is indispensable that the DEFAULT section (if it exits) is the last section. There can only be one DEFAULT section. It is possible to nest SWITCH statements with no limits. That is to say, new SWITCH statements (and any other kind of statement) can be put inside a CASE section. ---See: Syntax","title":"SWITCH statement"},{"location":"help/#while-statement","text":"WHILE ( ](#)) ; ... END The WHILE statement implements a loop . That is to say, it is capable of {repeating a group of statements a specific number of times}. In order to implement this loop, the condition that has to be complied for the group of statements to be executed must be specified in brackets, after the reserved word WHILE . All the statements that necessarily have to be repeated will be put after the specification of this condition. Finally, the end of the loop will be marked with the reserved word END (It doesn't matter whether more words END appear inside the loop when they belong to internal statements of that loop). When a WHILE statement is executed, the specified verification will be carried out. If the result is true, the internal statements will be executed. Otherwise, the program will continue from the END , that marks the end of the WHILE . If the internal statements have been executed (what is called to make a loop's iteration ), the condition will be verified again. If it is true, another iteration will be made (the internal statements will be executed again). This process will be repeated until it is verified that the condition of the WHILE is false. If the condition turns to be false directly while a WHILE statement is executed, then the internal statements will never be executed. Example: PROGRAM my_game; BEGIN x=0; WHILE (x<320) x=x+10; FRAME; END END - In this example, the x local variable ( x coordinate of the process) will be put at zero and then, providing that x is less than 320, 10 will be added to x and a FRAME will be performed. A BREAK statement inside a WHILE loop will immediately finish it, continuing the program from the following statement to that loop. A CONTINUE statement inside a WHILE loop will force the program to verify the initial condition immediately and, if it is true, to execute again the internal statements from the beginning (after the WHILE ). If the condition turns to be false, the CONTINUE statement will finish the loop. The internal statements of a WHILE loop can be as many as desired, and of any kind, obviously including new WHILE loops. ---See: Syntax","title":"WHILE statement"},{"location":"help/#repeat-statement","text":"REPEAT ; ... UNTIL ( ](#)) The REPEAT (REPEAT ... UNTIL( ... )) statement implements a loop . That is to say, it is capable of repeating a group of statements a specific number of times . In order to implement this loop, it is necessary to start with the reserved word REPEAT , followed by the statements that you want to repeat once or more times, and the end of the statement will be determined by putting the reserved word UNTIL , followed by the condition that has to be complied for the statement to finish . When a REPEAT statement is executed, the internal statements (those placed between the REPEAT and the UNTIL ) will be executed first and then, the condition specified in the UNTIL will be verified. If it is still false, the internal statements will be executed again. The process will be repeated until the condition of the UNTIL turns to be true, continuing then the execution of the program after this statement. Every time that the internal statements are executed, a loop's iteration has been made. The REPEAT ... UNTIL (the is complied) statement will always execute the internal statements at least once, so it always verifies the condition after the execution. Example: PROGRAM my_game; BEGIN x=0; REPEAT x=x+10; FRAME; UNTIL (x>320) END - In this example, the x local variable (x coordinate of the process) will be put at zero and then, 10 will be added to x and a FRAME will be performed until x becomes a number bigger than 320. A BREAK statement inside a REPEAT loop will immediately finish it, continuing the program from the following statement to that loop. A CONTINUE statement inside a REPEAT loop will force the program to immediately make the verification of the UNTIL and, if it is true, it will execute again the internal statements from the beginning (after the reserved word REPEAT ). If the condition turns to be true, the CONTINUE statement will finish the loop. The internal statements of a REPEAT ** loop can be as many as desired, and of any kind, obviously including new REPEAT** loops. ---See: Syntax","title":"REPEAT statement"},{"location":"help/#loop-statement","text":"LOOP ; ... END The LOOP statement implements an infinite loop . That is to say, it indefinitely repeats a group of statements . In order to implement this loop, it is necessary to start with the reserved word LOOP , followed by the statements intended to be repeated continuously, putting the reserved word END at the end. When a LOOP ... END statement is found in a program, all the internal statements of that loop will repeatedly be executed from this position. In order to finish a LOOP loop, it is possible to use the BREAK statement which, on being executed inside a loop of this kind, will force the program to continue from the END . Every time that the internal statements are executed, a loop's iteration has been made. The CONTINUE statement inside a loop will finish the current iteration and will start the following one (the program will go on running after the reserved word LOOP . Example: PROGRAM my_game; BEGIN x=0; LOOP IF (key(_esc)) BREAK; END x=x+1; FRAME; END END - In this example, the x local variable (x coordinate of the process) will be put at zero and then, 1 will be added to x and a FRAME will continuously be done. If the escape key ( ESC ) is pressed, then the BREAK statement will be executed, finishing the LOOP loop. The internal statements of a LOOP loop can be as many as desired, and of any kind, obviously including new LOOP loops. ---See: Syntax","title":"LOOP statement"},{"location":"help/#for-statement","text":"FOR ( ](#)) ; ... END The FOR statement (replica of the C language) implements a loop and is capable of {repeating a group of statements a specific number of times}. In order to implement this loop, three different parts must be specified in brackets, separated by symbols ; (semicolon) after the reserved word FOR . These three parts, that are optional (they can be omitted), are the following ones: Initialisation . An assignment statement is normally codified in this part. This kind of statement establishes the initial value of the variable that is going to be used as a counter of the loop's iterations (each execution of the inner group of statements is called a loop's iteration ). The assignment statement x=0 , that would put the x variable at zero at the beginning of the loop (value for the first iteration), is an example. Condition . A condition is specified in this part. Just before each iteration, this condition will be checked and, if it is true, the group of statements will be executed. If the condition is false, the FOR loop will finish, continuing the program after the END of the FOR loop. An example of condition can be x<10 , that would allow the inner group of statements to be executed only when the x variable is a number less than 10 . Increment . The increment of the variable used as a counter for each iteration of the loop is indicated in the third part. It is normally expressed with an assignment statement. For instance, the x=x+1 statement would add 1 to the x variable after each iteration of the loop. The group of inner statements of the loop that are going to sequentially be repeated while the condition of continuance (second part) is complied, must appear after the definition of the FOR loop with its three parts. After this group of statements, the reserved word END will determine the end of the FOR loop. When a FOR statement appears in a program, the part of the initialisation will be executed first, checking the condition. If it is true, the inner group of statements first and, the part of the increment then, will be executed, being the condition checked again, etc. If, before any iteration, the condition turns to be false, the FOR loop will immediately finish. A program with a FOR loop containing the three parts mentioned in the previous sections is now shown. Example: PROGRAM my_game; BEGIN FOR ( x=0 ; x<10 ; x=x+1 ) // The internal statements would be put here. END END - This loop would first run with the x variable equal to 0 , the second one equal to 1 , ..., and the last variable equal to 9 . The part of the increment would be executed after this iteration, becoming x equal to 10 . Then, on checking the condition of continuance in the loop ( x is less than 10 ), if it is false, the loop would finish. As it has been mentioned, the three parts in the definition of the loop are optional. If the three were omitted: FOR ( ; ; ) // ... END Then, this loop would be equivalent to a LOOP ... END loop. Moreover, several parts of initialisation, condition or increment can be put in a FOR loop, separated by commas ( , ). At first, all the initialisations will be executed. Then, all the conditions of continuance will be checked (if any of them turns to be false, the loop will finish). The inner statements and, after every iteration, all the increments, will finally be checked. Example: PROGRAM my_game; BEGIN FOR ( x=0, y=1000 ; x<y ; x=x+2, y=y+1 ) // The internal statements would be put here. END END - A BREAK statement inside a FOR loop will immediately finish it, continuing the program from the following statement of this loop. A CONTINUE statement inside a FOR loop will force to execute the part of the increment directly and then, to verify the condition of continuance. If it is true, then the inner statements will be executed again from the beginning. If the condition turns to be false, then the CONTINUE statement will finish the FOR loop. A FOR loop is practically equivalent to a WHILE loop, implemented in the following way: Example: PROGRAM my_game; BEGIN x=0; WHILE (x<10) // The internal statements would be put here. x=x+1; END END - With the only exception that a CONTINUE statement, inside this WHILE loop, would not execute the part of the increment, while it would do so inside a FOR loop. If, after the execution of the initialisation, the condition turns to be false directly inside a FOR loop, no inner statements will ever be executed. The internal statements of a FOR loop can be as many as desired, and of any kind, obviously including new **FOR ** loops. ---See: Syntax","title":"FOR statement"},{"location":"help/#break-statement","text":"A BREAK statement inside a loop will immediately finish it, continuing the program from the following statement to that loop. This statement can only be put inside the following loops: LOOP ... END FROM .. TO .. STEP .. ... END REPEAT ... UNTIL ( ](#)) WHILE ( ](#)) ... END FOR ( ](#)) ... END A BREAK sentence will make the program continue its execution after the END or the UNTIL of the loop closer to the statement. If there are several nested loops (one inside another one), the BREAK statement will only exit the inner loop. Example: PROGRAM my_game; BEGIN LOOP REPEAT IF (key(_esc)) BREAK; END //... FRAME; UNTIL (x==0); //... END END - In this example, the BREAK statement will exit the REPEAT ... UNTIL (when the ESC key is pressed), but not the LOOP ... END . Important --- The BREAK statement is not valid to finish IF , SWITCH (or the CASE sections of this statement), or CLONE statements. BREAK can only finish the statements that implement a loop. ---See: Syntax","title":"BREAK statement"},{"location":"help/#continue-statement","text":"A CONTINUE statement inside a loop will force the program to finish its current iteration and start the following iteration. We call iteration to each execution of the set of statements internal to a loop (the statements between a LOOP and its END , for instance). This statement can only be put inside one of the following loops: LOOP ... END A CONTINUE inside this loop will jump to the LOOP. FROM .. TO .. STEP .. ... END A CONTINUE inside this loop will perform the increment (STEP) and, if the value indicated in the TO has not been passed, the program will continue at the beginning of the loop. REPEAT ... UNTIL ( ](#)) A CONTINUE inside this loop will jump to the UNTIL. WHILE ( ](#)) ... END A CONTINUE inside this loop will jump to the WHILE. FOR ( ](#)) ... END A CONTINUE inside this loop will perform the increment and the comparison. If the latter is true, the program will continue at the beginning of the loop. But if it is false, the program will continue after the END of the FOR. If there are several nested loops (one inside another), the CONTINUE statement will take effect only in the inner loop. Example: PROGRAM my_game; BEGIN FOR (x=0, y=0;x<10;x++) IF (x<5) CONTINUE; END y++; END END - In this example, after the whole loop has been executed, x will be equal to 10 and y will be equal to 5 as, providing that x is less than 5, the CONTINUE statement prevents the y++; statement from being executed. Important --- The CONTINUE statement is not valid inside IF , SWITCH (or the CASE sections of this statement), or CLONE statements (as these statements do not implement loops and, therefore, they do not make iterations). ---See: Syntax","title":"CONTINUE statement"},{"location":"help/#return-statement","text":"The RETURN statement immediately finishes the current process, as if the END of its BEGIN was reached. When this statement is included in the main code, it will finish the current process. But if there are alive processes, they will go on running. For instance, the exit() function can be used to finish a program and all its processes. A RETURN inside a process will finish it, killing this process. Example: PROGRAM my_game; BEGIN LOOP IF (key(_esc)) RETURN; END FRAME; END END - In this example, the RETURN statement will be executed by pressing the escape key ( ESC ), finishing the program. Use of RETURN to return a value --- It is possible to design processes with a performance similar to the functions of other programming languages, that {receive a series of parameters and return a value}. For instance, a process receiving two numeric values and returning the biggest one. For that, this statement must be used with the following syntax: RETURN( ) It is also important not to use the FRAME statement inside the process, as this statement will immediately return to the calling process. When the compiler finds the FRAME statement inside a PROCESS , it directly classes it as a process, ruling out its hypothetical use as a function. Important: To return a value with the RETURN statement after execution of one or more FRAME statements , you must make a block of this type, ie. a FUNCTION . The example proposed before is shown now: an implementation of the mathematical function max that returns the greater of its two parameters. Example: PROGRAM my_game; BEGIN x=max(2, 3)+max(5, 4); END PROCESS max(a, b) BEGIN IF (a>b) RETURN(a); ELSE RETURN(b); END END - After the execution of this program, the x variable of the main process will be equal to 8 (3+5). Important --- By default, if the RETURN statement is used without the expression in brackets or the FRAME statement is used in a process, its return value will be its identifying code of the process}. ---See: Syntax","title":"RETURN statement"},{"location":"help/#frame-statement","text":"The FRAME statement is an essential part of the language. A program's working is described below in general terms: The main program starts its execution. This process may create more processes (objects of the game) at any point. All the processes may finish at any moment, and they may create or eliminate other processes. The games will always be displayed frame by frame. In each frame, the system will execute all the processes existing at that moment, one by one, until each one executes the FRAME statement, which will indicate that it is ready for the next display (frame). In the preparation of each frame, all the processes will be executed in the established priority order (the priority local variable of the processes determines this order). Therefore, this statement is similar to an order for the processes to be displayed. If a process starts its execution and it neither finishes nor executes this statement, then the program will become blocked, as there is a process that is never ready for the next display. Therefore, the system won't be capable of showing the following frame. Example: PROGRAM my_game; BEGIN my_process(); my_process(); LOOP IF (key(_esc)) my_second_process(); END FRAME; END END PROCESS my_process() BEGIN LOOP FRAME; END END PROCESS my_second_process() BEGIN LOOP END END - In this program, the main process (a my_game type process) creates other two processes ( my_process type). From that moment, the three processes will continuously be executed, each one to their FRAME statement. But if the escape key ( ESC ) is pressed, then the main process will create a new process ( my_second_process type) that will remain in a LOOP loop indefinitely, without executing any FRAME . Consequently, the program will be interrupted (the system will report such a situation after few seconds; see max_process_time ). Basically, all the processes that correspond with objects of a game construct a loop inside which, every frame establishes all its display values ( x , y , graph , size , angle , ...), executing then the FRAME statement. Synchronisation of processes --- It is possible to use this statement with the following syntax: FRAME( ) By putting in brackets a whole percentage, from 0 to 100 or bigger, after the reserved word FRAME . This figure will indicate the percentage of the following frame, completed by the process. That is to say, the absence of this percentage is equivalent to putting FRAME(100) (100% of the work previous to the following display has been completed by the process). For instance, if a process executes the FRAME(25) statement in a loop, it will need to execute it 4 times before it is ready for the next display (as 4*25% is the 100%). On the other hand, if a process executes the FRAME(400) statement inside its loop, after its first execution, it will have completed 400% the display. Therefore,even after the display, a completed 300% of display will still be missing. For that, in the preparation of the following 3 frames the system won't execute this process, as it is ready for the display. Then, this process would be executed just once every 4 frames (unlike the example of the previous paragraph, in which it was executed 4 times every game's frame). The processes won't reach the next display unless they give 100%, at least . For instance, if a process always executes FRAME(80) statements, it will execute them twice before the first display, so it will have completed 160% (2 80%) the display. Therefore, it will have pre calculated 60% (160%-100%) for the next display. For that reason, in the second display it will only require a FRAME(80) * statement to be displayed, as this 80%, plus the remaining 60% of the first display, will be equal to a 140% completed. Therefore, it will immediately be displayed ,and a 40% will be left to prepare the next frame. A FRAME(0) statement completing a 0% of the next display only makes sense in the two following cases: It can be a way to force the system to execute in this point the rest of the processes having the same priority as the current one and, after them, the system will execute the latter again. It can also be a way to initialise functions such as get_id() or collision() , as they return some specific values for every frame. If the aim is to obtain values again, it is possible to execute a FRAME(0) statement that will be interpreted as a new frame by these functions. ---See: Syntax","title":"FRAME statement"},{"location":"help/#clone-statement","text":"CLONE ; ... END This statement creates a new process identical to the current one, with the exception that the statement between the reserved words CLONE and END will only be executed in the new process, but not in the current one. For instance, if any process of the program, with specific coordinates ( x , y ) and with a specific graphic ( graph ), executes the following statement: CLONE x=x+100; END A new process will be created, identical to the former, with the same graphic and the same values in all its variables, with the exception of the x coordinate that, in the new process, will be placed 100 pixels farther to the right. This statement is used to create replicas of a process, dividing it into two processes (almost) similar. Example: PROGRAM my_game; BEGIN // ... x=0; y=0; CLONE x=x+10; END CLONE y=y+10; END // ... END - In this example, the 2 CLONE statements will create 3 copies of the main process (and not 2, as it could have been expected). On executing the first CLONE statement, a new process will be created. Thus, there will be 2 processes: one in (x=0, y=0) and the other in (x=10, y=0). These two processes will execute the second CLONE statement. The first one (the original one) will create a new process in (x=0, y=10), and the second one will create the new process in (x=10, y=10). To create only 2 copies of the original process, the program could have been constructed, for instance, in the following way: Example: PROGRAM my_game; BEGIN // ... x=0; y=0; CLONE x=x+10; CLONE y=y+10; END END // ... END - The original process (x=0, y=0) will create one in (x=10, y=0) and the latter will create another one in (x=10, y=10). Therefore, only two copies of the original will be created. Much care must be taken when it comes to using the CLONE statement sequentially or inside a loop , as it is necessary to take into account that the first ' clones ' may also create new ' clones '. This statement can be used without putting statements between the words CLONE and END . But, intending to have two identical processes with the same coordinates, the same graphic and executing the same code, seems to make little sense, at least at first. ---See: Syntax","title":"CLONE statement"},{"location":"help/#debug-statement","text":"The DEBUG statement will call the interactive debugger when it is executed. It is normally used to debug programs, to find possible errors of the programs. On some occasions, it is normally put in the following points. Where you want to verify that a part of the program has done what was expected. After the execution of that part, DEBUG will call the debugger, from which it is possible to check all the active processes and the value of all their variables. When you are not very sure whether something can happen in a program, you can put this statement in that point to report you whether what we are expecting actually happens. This statement is only used temporarily, until the error that is looked for is found. From that moment, the statement won't be necessary. Thus, it can be removed from the program since it has no additional effect. Example: PROGRAM my_game; BEGIN // ... IF (x<0) DEBUG; END // ... END - In this example, it is verified that, in a specific point of the program, the x coordinate of the process is not a negative number (less than zero). If this happens, the debugger will be called to find out why it has happened. When this statement is executed, a dialog box appears, offering us the following options: To disable the DEBUG statement, preventing it from being activated in this execution of the program. To stop the program and enter the debugger, to be able to examine all the processes and their variables. Or to finish the execution of the program immediately, returning to its edition in the windows' graphic environment. Moreover, if the escape key ESC is pressed in that box, the DEBUG statement will simply be ignored, and the program will continue to be executed as usual. When a program is executed from the windows' graphic environment, the debugger can be called at any moment by pressing the F12 key. On invoking the debugger in this way, the program will always be interrupted just before starting the processing of a new frame. All the processes to be executed will appear before the next display. ---See: Syntax","title":"DEBUG statement"},{"location":"help/#list-of-functions-of-the-language","text":"Process interaction functions collision() get_angle() get_dist() get_distx() get_disty() get_id() let_me_alone() signal() Geometry functions advance() fget_angle() fget_dist() near_angle() xadvance() Path finding functions path_find() path_free() path_line() Mathematical functions abs() acos() asin() atan() atan2() cos() pow() sin() sqrt() tan() Random number functions rand() rand_seed() Graphics functions clear_screen() get_pixel() map_block_copy() map_get_pixel() map_put() map_put_pixel() map_xput() new_map() put() put_pixel() put_screen() screen_copy() xput() Primitive graphics drawing functions delete_draw() draw() move_draw() Audio system functions change_channel() change_sound() reset_sound() set_volume() Sound effect functions is_playing_sound() load_pcm() load_wav() sound() stop_sound() unload_pcm() unload_wav() CD music functions is_playing_cd() play_cd() stop_cd() Digital music functions get_song_line() get_song_pos() is_playing_song() load_song() set_song_pos() song() stop_song() unload_song() Input functions get_joy_button() get_joy_position() key() Palette control functions convert_palette() fade() fade_off() fade_on() find_color() force_pal() load_pal() roll_palette() set_color() Mode7 and scroll functions move_scroll() refresh_scroll() start_mode7() start_scroll() stop_mode7() stop_scroll() Mode 8 Functions (3D mode) get_point_m8() get_sector_height() get_sector_texture() get_wall_texture() go_to_flag() load_wld() set_env_color() set_fog() set_point_m8() set_sector_height() set_sector_texture() set_wall_texture() start_mode8() stop_mode8() Text display functions delete_text() load_fnt() move_text() write() unload_fnt() write_int() write_in_map() String handling functions char() lower() strcat() strchr() strcmp() strcpy() strdel() strlen() strset() strstr() upper() String conversion functions calculate() itoa() Animation functions end_fli() frame_fli() reset_fli() start_fli() Screen region functions define_region() out_region() Graphics information functions get_point() get_real_point() graphic_info() Initialisation functions set_fps() set_mode() Resource handling functions load_fpg() load_map() load_pcx() unload_fpg() unload_map() unload_pcx() save_map() save_pcx() Data IO functions load() save() File-handling functions fclose() filelength() flush() fopen() fread() fseek() ftell() fwrite() Directory-handling functions chdir() disk_free() get_dirinfo() get_fileinfo() getdrive() mkdir() remove() setdrive() File compression functions compress_file() uncompress_file() File encryption functions decode_file() encode() encode_file() System functions exit() ignore_error() system() Dynamic memory allocation functions free() malloc() memory_free() Network functions net_get_games() net_join_game() Note: To obtain help about a specific function directly, place the edit cursor on the name of the function (in the programs editor) and press F1 . ---See: Syntax","title":"List of functions of the language."},{"location":"help/#call-to-a-process","text":"( ) To call a process, put the name of the process, followed by a list including as many expressions separated by commas (,) , as parameters of the process, in brackets () . The brackets are obligatory, even if the process has no call parameters . A call to a process will always return a value that depends on which one of the following actions is performed first by the called process. If the FRAME statement is executed, then the process will return its identifying code . If the process executes the RETURN ( ](#)) statement, then the former will return the result of this expression. If the process finishes, either because the END of its BEGIN is reached or because a RETURN statement is executed with no expression, the process will return the identifying code of itself, but as the process has now finished (killed), it is necessary to take into account that this identifying code can be assigned by the system to any new process created from now on. The return value can be ignored, assigned to a variable or used inside an expression. Example: PROGRAM my_game; PRIVATE id2; BEGIN my_process(0, 0); id2=my_process(320, 200); // ... END PROCESS my_process(x, y) BEGIN LOOP FRAME; END END - In this example, the main process my_game makes two calls to the process my_process , which receives two parameters in its x and y local variables. As the process executes the FRAME statement, it will return its identifying code . It can be noticed how the value returned in the first call to the process is ignored (it is not used at all), and how, in the second call, the identifying code of my_process(320, 200) is assigned to the private variable of the main process id2 . When a call to a process is made, the execution of the current process is momentarily stopped, and the code of the called process is executed, until it is returned through one of the three mentioned cases (until it finishes or executes a FRAME or RETURN statement). If the process has finished with a FRAME statement, it will be displayed in the following frame according to the values established in its local variables ( x , y , graph , ...) and, in the preparation of the following frame, this process will go on running from the FRAME statement. ---See: Syntax - Parameters of a process","title":"Call to a process"},{"location":"help/#reference-to-a-variable","text":"A reference to a variable is any expression making reference to a cell or a position of the computer's memory. It is normally understood as one of the following aspects: If the variable is a variable, in order to refer to the variable in this way, we must simply specify its name. Example of a reference to a variable: x If the variable is a table, reference to it is normally made with its name followed by an expression in square brackets ( [ ] ).That expression will determine the position of the table intended to be accessed. If the index in square brackets is omitted, the first position of the table (position 0) will be accessed. Example of a reference to a table: timer[0] If the variable is a structure, reference to it will be made with its name followed by an expression in square brackets ( [ ] ) that will determine the number of records that will be accessed. After it, the symbol . (period) will be put, preceding the specific name of the structure's field that is going to be accessed. If the record number in square brackets is omitted, the first record of the structure (number 0) will be accessed. Example of a reference to a structure: scroll[0].z These three cases deal with accessing data of the process itself or global data. To access an alien variable (a local variable of another process), it will be preceded by the identifying code of the alien process and the symbol . (period) , operator of access to local data and structures). Example of a reference to an alien local variable: father.x ---See: Syntax","title":"Reference to a variable"},{"location":"help/#definition-of-an-expression","text":"An expression is basically a mathematical formula involving one or more operands ( x , 2 , id , ...) through different operators ( * , AND , >> , ...); some examples of expressions would be: 2 , 2+3 or (x 4)/-3 *. Only integers within the range ( min_int ... max_int ) can be used as values. The result of the expression will always be truncated within this range. These expressions will be evaluated when the statement containing them inside the program is executed. The operands that can be used in an expression are the following ones: Constants . Numeric values . Literals (texts in inverted commas). Variables, tables or structures of any kind. Any kind of function or process. Identifying code of the process. Type of process ( type ). The operators that can be used in an expression are the following ones (the synonymous of the operator, if they exist, are shown in brackets): + Addition - Subtraction (or sign negation) * Multiplication / Division MOD Module ( % ) << Rotation to the right >> Rotation to the left NOT Binary and logical negation ( ! ) AND Binary and logical AND( & , && ) OR Binary and logical OR( | , || ) XOR Exclusive OR ( ^ , ^^ ) == Comparison <> Different ( != ) > Greater than >= Bigger or equal ( => ) < Less <= Less or equal ( =< ) OFFSET Direction or offset ( & ) ++ Operator of increment -- Operator of decrement POINTER Addressing operator ( * , ^ , [ ] ) ( ) Brackets Click on \" Evaluation of an expression \" to see the order in which the calculations are made inside an expression and when the brackets must be used. Some examples of valid expressions are now shown: ** -33** ** 44-2 22 * ** id** ** x+1** ** (angle 3)/2-pi/2 * ** (x+y)/2** ** abs(x-y) 3-pow(x, 2) * ... ---See: Syntax - Evaluation of an expression","title":"Definition of an expression"},{"location":"help/#evaluation-of-an-expression","text":"It is important to know the way in which the expressions are evaluated in order to know where it is necessary to put brackets indicating the way in which the expression is intended to be evaluated. In the language, an expression can contain operators of different levels of priority. In the evaluation of an expression, the operators of priority 1 (if they exist), will always be processed first, and then, those of priority 2 , priority 3 and so on. Priority 1 ( ) Brackets, beginning and end of a sub expression Priority 2 . Period, access' operator to local data and structures Priority 3 NOT Binary and logical negation (#1045, ! ) OFFSET Offset (#1050, & ) POINTER Addressing operator ( * , ^ , [ ] ) ** -** Sign negation ++ Operator of increment -- Operator of decrement Priority 4 * Multiplication / Division MOD Module ( % ) Priority 5 + Addition - Subtraction Priority 6 << Rotation to the right >> Rotation to the left Priority 7 AND Binary and logical AND ( & , && ) OR Binary and logical OR ( | , || ) XOR Exclusive OR ( ^ , ^^ ) Priority 8 == Comparison <> Different ( != > Greater than >= Bigger or equal ( => < Less <= Less or equal ( =< Priority 9 = Assignment += Addition-assignment -= Subtraction-assignment *= Multiplication-assignment /= Division-assignment %= Module-assignment &= AND-assignment |= OR-assignment ^= XOR-assignment >>= Rotation to the right-assignment <<= Rotation to the left-assignment The operators of priority 3 are known as unary operators. They do not link two operands (unlike the binary operators such as, for instance, a multiplication), but they just affect the value of an operator. Inside the unary operators, those closest to the operand will be executed first. For instance, in the expression: NOT -x The operand x has two unary operators, the negation of sign - and the logical and/or binary NOT . Among them, the negation of sign will be executed first, as it is closer to the operand. From priority 4 , all the operators are binary and they will be executed according to their level of priority. Therefore, when in an expression there is more than one operator of the same level (for instance, a multiplication and a division, both of priority 4), they will be processed from left to right. That is to say, in the following expression: 8/2*2 The division will be executed first and then, the multiplication (it is the natural way to evaluate the expressions mathematically). The only exception are the operators of priority 9 ( assignment operators), that will be evaluated from right to left (instead of from left to right). That is to say, in the expression: x=y=0 y=0 will be processed first ( y will be put at 0 ) and then, x=y ( x will also be put at 0 , as y will now be equal to 0 ). As it can be noticed, the assignments work like an operator After the assignment, they return the value they have assigned as a result of the operation. ---See: Syntax - Definition of an expression","title":"Evaluation of an expression"},{"location":"help/#definition-of-a-condition","text":"The conditions are expressions normally similar to the following ones: x<320 size==100 AND graph>10 y==0 OR (x>=100 AND x<=200) ... In general, any expression is valid as a condition. In the language, all the ODD expressions are interpreted as true and all the EVEN expressions are interpreted as false . Example: PROGRAM my_game; BEGIN IF (20 2+1) x=x+1; END END - * In this example, the x=x+1; statement will always be executed, as the expression 20*2+1 is equal to 41 , an odd number. All the available operators are valid inside a condition. It is even possible to perform assignments inside a condition (the assignments are operations that return the assigned value as a result). All the identifying codes of processes are odd numbers. That is to say, all of them are true . Therefore, it is possible to implement conditions as the following one (supposing that id2 has been declared as a variable, and that shot is a type of process of the program). id2=get_id(type shot); WHILE (id2) id2.size=id2.size-1; id2=get_id(type shot); END In the id2=get_id(type shot) condition, the result of the get_id function is being assigned to the id2 variable. If that function has returned an identifying code , it will be an odd number and the condition will be evaluated as true (if get_id() does not find (more) identifiers of \" shot type\" processes, then it will return 0 (an even number), and the condition will be interpreted as false , finishing the WHILE statement. The previous statements would decrement the size variable of all the shot type processes existing in the program. ---See: Syntax - Definition of an expression","title":"Definition of a condition"},{"location":"help/#ways-to-obtain-the-identifying-code-of-a-process","text":"All the processes have their own identifying code in ID (reserved word in the language that is equivalent to the identifying code of the process). When a process is created (is called), it returns its own identifying code as return value, unless it has finished with a RETURN ( ](#)). That is to say, a process will always return its identifying code when it finishes (when its END is reached), when it executes the FRAME or the RETURN statements without expression in brackets. In the following example, a process ( my_process type) is created from the main program, and its identifier is stored in the id2 variable. Example: PROGRAM my_game; PRIVATE id2; BEGIN id2=my_process(); // ... END PROCESS my_process() BEGIN // ... END - All the processes have the following local variables predefined with identifiers of other processes: father - father, identifier of the process that created it (the one that made the call). son - son, identifier of the last process created by it (last called process). bigbro - Elder brother, identifier of the last process created by the father before creating it. smallbro - Younger brother, identifier of the following process created by the father after having created it. These variables can be equal to 0 if they have not been defined (for instance, son will be equal to 0 until a process is not created or if this process has disappeared). The processes' identifying codes allow us to access their local variables ( . ) and, as father , son , etc. are also local variables, it is possible to make combinations such as son.bigbro to access the identifier of the penultimate process created (as son is the last one; therefore, its elder brother will be the penultimate one). Besides creation or direct relationship, there are other ways to obtain identifying codes of processes, as indicated below: The get_id() function to obtain the identifiers of the processes of a specific type (spacecraft, shot, etc.) existing at a specific moment in the game. The collision() function to obtain the identifiers of the processes with which it is colliding. When a specific process needs to access from many others, as it is an important process such as, for instance, the protagonist spacecraft of a game, then it can be more useful to assign its identifier to a GLOBAL variable of the program (that can be accessed by any process at any point). Thus, any process will be able to interact with it, as it will have its identifier. Example: PROGRAM my_game; GLOBAL id_spacecraft; BEGIN id_spacecraft=spacecraft(); // ... END PROCESS spacecraft() BEGIN // ... END PROCESS enemy() BEGIN // ... id_spacecraft.z=0; // ... END - In this example, at a specific point the enemy type processes access the z variable of the spacecraft created by the main program, using for that purpose its identifier, that is included in the id_spacecraft global variable. ---See: Identifying codes of processes.","title":"Ways to obtain the identifying code of a process."},{"location":"help/#identifying-codes-of-processes","text":"A process is an object independent of the program, that executes its own code and that can have its own coordinates, graphics, etc. Processes of a program can be, for instance, a shot, spacecraft or enemy. When something similar to what is below is input inside a program: PROCESS shot( ... ); BEGIN ** // statements ...** END The statements that are going to execute the \" shot type\" processes (the code ruling their performance), are specified. As it can be noticed, more than one shot type process may exist in a program. Then, how can they be distinguished? Simply by their identifying code. Every time that a new process is created in a game, an identifying code is assigned to this process. This code is going to be the exclusive reference of the process until it disappears. Two different processes will never have the same identifying code at the same time. However, the code that belonged to a process that has already disappeared can be assigned to a new process (something similar to what happens in relation to an i.d.). The identifying codes are always whole, positive, odd numbers, like 471, 1937 or 10823. All the processes have their own identifying code in ID , that is something similar to a process' local variable local, with the proviso that it can not be modified. Moreover, the processes have the identifying code of the process that created them (that called them) in father . They have the identifying code of the last process they created (the last one they called) in son . And so on. (see Hierarchies of processes ). What are the identifying codes for? --- Normally, all the processes need the identifying code of the other processes in order to interact with them (to see where they are, to modify them, ...). For instance, it is not possible to subtract energy from the \" enemy type\" process, as many or none of this type of processes may exist. It is necessary to have the specific identifying code of the enemy process from which you want to subtract energy. A process accesses all its own variables simply by their names, such as x , size or graph . Thus, if the identifier of a process is known (in son , father or any variable defined by the user, such as id2 ), then it is possible to access the variables of that process, like ( son.x , father.size or id2.graph ). That is to say, the syntax to access local variables of another process is as follows: . These variables can normally be used to consult them modify them. It is not at all possible to access PRIVATE variables of another process at any rate . In order to access a private variable of another process, it is necessary to change its declaration to the LOCAL section to transform it into a local variable. Then, any process will be able to access that variable just having the identifying code of the process, as all the processes will have that variable. The identifiers have more utilities other than the access to alien local variables, such as the signal() function, that can send specific signals to a process if its identifying code is known (for instance, to eliminate the process). There are also other functions, such as collision() , used to detect collisions with other processes. When this function detects a collision, it returns the identifying code of the process with which it is colliding. Once this code is known, it is possible to access the variables of the process and send them signals. The get_id() function operates in a similar way to collision() , obtaining the identifying code of a process. But in this case, no collision with it is necessary. ---See: Ways to obtain the identifying code of a process.","title":"Identifying codes of processes."},{"location":"help/#states-of-a-process","text":"Processes are the different elements of a program (objects of the game). They may experience different states on creating, destroying or receiving specific signals with the signal() function. alive or awake. process A process is alive when it is running (when it is interpreting the statements located between its BEGIN and its END ). dead. process A process is dead when it finishes (either because its END is reached in the execution, a RETURN is executed or because it receives a signal s_kill or s_kill_tree ). asleep. process A process may receive the signal s_sleep (or s_sleep_tree ), then becoming asleep. In this state, this process will appear to be dead. But it is not as, at any moment, it may receive a signal s_wakeup and return to the alive or awake states. It is also possible to kill an asleep process. frozen. process The signal s_freeze (or s_freeze_tree ) freezes a process. In the frozen state, the process, that is still visible, remain blocked. It may be detected by the rest of the processes (for instance, as for collisions), but it is not executed (it stops interpreting its code statements). It will remain in this state until it receives another signal that changes its state or that kills it. A frozen process may be controlled (moved) by another process, directly manipulating its variables. When a signal is sent to a process, aiming at changing its state, this signal will have no effect before its following display ( FRAME ) is reached if the process is running. If the process is not running, then the signal will have an immediate effect. No signal must be sent to nonexistent processes (to an identifying code that does not correspond with any process). This signal will be ignored when the aim is to put a process in the state in which it is already. ---See: Hierarchy of processes.","title":"States of a process."},{"location":"help/#hierarchies-of-processes","text":"A process is an independent object of the program, that executes its own code and that may have its own coordinates, graphics, etc. For instance, a shot, spacecraft or enemy can be processes of a program. When a program starts to run there is only one process: the initial process, which starts the execution of the main code's statements. But, from this moment, this process can create new processes that, at the same time can create other processes, destroy them, etc. In order to clarify the events appearing through a program, we use a simile, treating the processes as if they were alive beings that are born and killed (when they are created or destroyed). For that reason, the following terms are established: Father , name given to the process that has created another one (mother would have been a more appropriate name). Son , process created by another one. Brothers , processes created by the same father. Orphan , process whose father has died (as it has been either eliminated or finished). This vocabulary may be spread as far as your imagination desires grandfathers , grandsons , uncles , etc. All the processes have direct access to the identifying codes of the processes with which they have direct relationship (see: Ways to obtain the **#1039,identifying code of a process**. Occasionally, reference is made to actions performed by \" the system \". This process, called div_main , controls the rest. Therefore, it is in charge of creating the initial process at the beginning of the execution, of setting the speed execution, the debugger, etc. All the processes that are orphaned become sons of this process. The div_main identifier can be obtained with get_id(0) . It can be used to send a tree signal to all the processes, but this process won't be displayed on screen , even if its x , y , graph , etc. variables are defined. ---See: States of a process","title":"Hierarchies of processes."},{"location":"help/#types-of-processes","text":"The blocks of the programs starting with the reserved word PROCESS determine the performance of a specific process type. Then, when the program is executed, any number of processes of this type will be able to exist at a specific moment. Each of these processes will have a different identifying code , but all of them are of the same type. Example: PROGRAM my_game; BEGIN // ... END PROCESS spacecraft() BEGIN // ... END PROCESS enemy() BEGIN // ... END PROCESS shot() BEGIN // ... END - In this example, four types of processes are defined: my_game (the type of the program's initial process), spacecraft , enemy and shot . The number of processes of each of these types existing in the game depends on the number of calls made to these processes. All the processes of spacecraft type will always execute the statements defined in the PROCESS spacecraft() of the program. A \"process type\" is a numeric code referred to the name of the PROCESS that determines how the process works during the game. This numeric code can be obtained with: TYPE . TYPE is an operator defined in the language that, applied to a process name, returns this numeric code. For instance, TYPE spacecraft will be equivalent to a specific numeric constant and TYPE enemy will be equivalent to another one. All the processes have a local variable containing this numeric code, which is: reserved.process_type . What is the process type for? --- The process type is used for several things, as it is mentioned below: For the get_id() function that receives a process type (for instance, get_id(TYPE enemy) ) as a parameter and returns the identifying codes of the processes of this type existing in the game at that moment. For the collision() function is similar to the previous one, with the proviso that it returns the identifying codes of the processes with which it is colliding (the graphics of both processes are partially superposed). For the signal() function, that may send a signal to all the existing processes of a specific type. Or to verify, from a process' identifying code , what kind of process it is (type spacecraft, type shot, etc.). The operator TYPE can only be used preceding a process name of the program or the word mouse , to detect collisions with the mouse pointer (with collision(TYPE mouse) ). ---See: Identifying codes of processes.","title":"Types of processes."},{"location":"help/#from-statement","text":"FROM = TO ; ; ... END (or) FROM = TO STEP ; ; ... END The FROM statement implements a loop . That is to say, it is capable of repeating a group of statements a specific number of times . A GLOBAL , LOCAL or PRIVATE variable of the process itself that can be used as a loop counter is needed to implement this loop. The reserved word FROM must be put before the statements that will comprise the inner group of statements. This word will be followed by the name of the counter variable , the symbol of assignment ( = ), the initial value of the variable, the reserved word TO and, finally, the final value of the variable. The symbol ; (semicolon) must be put after this declaration of the loop FROM . The inner group of statements that is intended to be repeated a specific number of times is put after this head defining the conditions of the loop. Finally, the reserved word END will be put. The name of iteration of the loop is referred to the number of times that the inner set of statements is executed. The first iteration will be performed with the initial value in the variable used as a counter. After this iteration, 1 will be added to this variable (if the initial value is less that the final value). Otherwise 1 will be subtracted from it. After having updated the value of the variable, it is necessary to pass to the following iteration, provided that the value of this variable has not reached (or exceeded) the final value of the loop. The reserved word STEP can be put as second meaning of the FROM statement, after the initial and final values of the statement. This word must be followed by a constant value indicating the increment of the counter variable after every iteration of the loop, instead of 1 or -1 , which are the increments that will be performed by default if the STEP declaration is omitted. The following example shows a program with two loops FROM : one without STEP declaration (with increment or decrement by default) and the other with it. Example: PROGRAM my_game; BEGIN FROM x=9 TO 0; // Inner statements ... END FROM x=0 TO 9 STEP 2; // Inner statements ... END END - The first loop will be executed 10 times with the x variable . Its value will range between 9 and 0 in the different iterations. By default, 1 will be subtracted from the variable each time, as the initial value (9) is bigger than the final value (0). In the second loop, constant 2 is indicated as the increment of the variable. Thus, the loop will be executed 5 times with the x variable, whose values will be 0 , 2 , 4 , 6 and 8 , respectively, in the consecutive iterations. As it can be noticed, no iteration will be performed with x being equivalent to 9 , even if it is the loop's final value . By default, if 2 had not been specified as STEP of the loop, 1 would have been added to the x variable after each iteration. A loop FROM can always be performed with the FOR statement, as it is now shown (with two loops equivalent to those of the previous example). Example: PROGRAM my_game; BEGIN FOR ( x=9 ; x>=0 ; x=x-1 ) // Inner statements ... END FOR ( x=0 ; x<=9 ; x=x+2 ) // Inner statements ... END END - The initial and final values of a loop FROM must be different. If the initial value is less than the final value, it is not possible to specify a negative value in the STEP declaration. If the initial value is bigger than the final value, it is not possible to specify a positive value in the STEP declaration. A BREAK statement inside a loop FROM will immediately finish it, continuing the program from the following statement to this loop (after the END ). A CONTINUE statement inside a FROM loop will force the program to increment the variable used as a counter immediately and then, if the final value has not been exceeded, to start the following iteration. The statements inner to a loop FROM may be as many as desired, of any kind, obviously including new loops FROM . ---See: Syntax","title":"FROM statement"},{"location":"help/#use-of-angles-in-the-language","text":"In the language, all the angles are specified in degree thousandths. For instance: 0 is 0 degrees (to the right) 90000 are 90 degrees (up) ** -45000 are -45 degrees** (down right diagonal) If 360 degrees (360000) are added to or subtracted from any angle, an equivalent angle is obtained. For instance, the angles -90000 and 270000 are equivalent (the angles of -90 degrees and 270 degrees go both downwards) The constant PI predefined as 180000 , 3.1415 radians or, what is the same, 180 degrees , can be used as reference. For instance, PI/2 will be equal to 90 degrees (90000). Some of the functions dealing with angles are mentioned below: get_angle() get_distx() get_disty() fget_angle() near_angle() advance() xadvance() All the processes have a predefined local variable called angle which, by default, will be equal to 0 . If its value is modified, the display's angle of the graphic of the process will be changed (the graphic will rotate in the indicated degrees, from the original graphic). ---See: Syntax","title":"Use of angles in the language."},{"location":"help/#not","text":"Unary operator of logical and binary negation used in expressions and conditions. The reserved word NOT and the symbol ! are synonymous. NOT logical: If the operand is true , on applying this operator to it, a false expression will be obtained, and vice versa. TRUE -> FALSE FALSE -> TRUE NOT binary: Changes all the bits of the operand. That is to say, it passes 0 to 1 and 1 to 0. Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). On changing the NOT operator, all the bits also change the last one, transforming then the even numbers into odd numbers (false expressions into true ones) and the odd numbers into even numbers (true expressions into false ones). ---See: Syntax - Expression - Condition","title":"NOT !"},{"location":"help/#_1","text":"Logical operator [ different from ] used in conditions. The symbols <> and != are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If both expressions have the same result (if these two expressions are equivalent), as they ARE NOT different. True - If the expressions have different results, as they ARE different. Examples: 2+2 <> 4 will return false . 0 <> -1 will return true . ---See: Syntax - Condition","title":"&lt;&gt; !="},{"location":"help/#_2","text":"Symbols delimiting literals. Literals are the texts in inverted commas . Literals may start and finish with the character [ ' ] or even with the character [ \" ] (but they have to start and finish with the same character). There are two ways to include the character [ \" ] in a literal, supposing that the aim is to define a literal containing the text: a\"B\"c Duplicating the character: \"a\"\"B\"\"c\" Defining it with the simple inverted comma: 'a\"B\"c' It happens the same regarding the character [ ' ], that can be included in a literal if it is duplicated, or if the literal is delimited with the character [ \" ]. All the literals must be closed in the same line as they started. It is not possible to define literals occupying more than one line. Literals of several lines. It is possible to define the literals over several lines, to do this you just need to divide the text into several lines, and put them successively (do not separate them with any symbol). For example, you could define a constant as: salute=\"\u00a1Ho\" ** \"la!\";** This also can be used to initiate the data of type STRING . There is no limit in the number of lines. Only Comments can appear between two successive literals. ---See: Syntax","title":"\" '"},{"location":"help/#mod","text":"Arithmetic operator of module or remainder of a whole division . The reserved word MOD and the symbol % are synonymous. This operator is used in the arithmetic expressions between two operands, to obtain the module of the first one divided by the second one. For instance, 7 MOD 3 will return 1, as the whole division of 7 by 3 give us 2 as quotient and 1 as remainder . That is to say, n MOD m will always return a number within the range (0..m-1). To understand easily how to obtain the remainder of an operation n MOD m , the following steps may be followed: Step 1 - If n is less than m , then the result of the operation MOD is n . Step 2 - (When n is bigger than or equal to m ), subtract m from n and go to step 1 . Use: On some occasions, this operator is used in the programs requiring that a counter variable always changes between 0 and other number . For instance, if the aim is that the x variable indefinitely varies between 0 and 319 (x=0, x=1, x=2, ..., x=319, x=0, x=1, ...), then there would be the following option: x=0; LOOP ** x=x+1;** ** IF (x==320) x=0;** ** // ...** END But many programs replace these statements by the following ones: x=0; LOOP ** x=(x+1) MOD 320;** ** // ...** END that fulfills the same function, as the operator MOD will truncate the expression when it is bigger than or equal to 320 at a lesser value. The quotient of a whole division is obtained through the operator / (division). ---See: Syntax - Expression","title":"MOD %"},{"location":"help/#_3","text":"Operative assignment. Operation of module or remainder of a whole division . The assignment statements are used to calculate expressions and to assign them to a variable. = ; If the symbol %= is used instead of = to perform the assignment, the following module or remainder of the division will be assigned to the variable: [ previous_value_of_the_variable ] / [ result_of_the_expression ] Example: x=3; x%=2; -> (x=1) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, a n %= m; type statement will be equivalent to this other n = n MOD m; statement. See the operator MOD for further information about the module . ---See: Syntax - Assignment","title":"%="},{"location":"help/#_4","text":"Bi functional symbol, that has two different uses depending on whether it is used as an unary or binary operator. An UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator & will be a synonymous of OFFSET . Example: &x is equivalent to OFFSET x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator & will be a synonymous of AND . Example: x&2 is equivalent to x AND 2 ---See: Syntax - OFFSET - AND","title":"&amp;"},{"location":"help/#and","text":"Binary operator of the logical product used in expressions and conditions. The reserved word AND and the symbol && are synonymous. AND logical: The conditions to the right and left of the operator are first evaluated and, if both are true , this operator will return true . Otherwise, the operator will always return false . FALSE AND FALSE = FALSE FALSE AND TRUE = FALSE TRUE AND FALSE = FALSE TRUE AND TRUE = TRUE These are used to verify that more than one condition is satisfied; for instance: (x>0 AND x<100) To verify that the variable is bigger than 0 AND less than 100. AND binary: Evaluates the bits of the expressions appearing before and after the operator, returning the value of the bits that are common to both expressions as follows: 0 AND 0 = 0 0 AND 1 = 0 1 AND 0 = 0 1 AND 1 = 1 This rule will be applied to all the bits of the operands (in the language, these are 32 bit integers). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator AND will only leave the last bit at 1 (it will only return true as a result} when both operands have this bit at 1 (when both are true expressions). Note: The symbol & can also be used as another synonymous of AND and ** &&**. ---See: Syntax - Expression - Condition","title":"AND &amp;&amp;"},{"location":"help/#_5","text":"Operative assignment. Binary operation of logical product ( AND ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol &= is used instead of = to perform the assignment, the following logical product will be assigned to the variable: [ previous_value_of_the_variable ] AND [ result_of_the_expression ] Example: x=5; x&=6; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n &= m; type statement will be equivalent to this other n = n AND m; statement. See the operator AND for further information about the logical product . ---See: Syntax - Assignment","title":"&amp;="},{"location":"help/#_6","text":"The symbols ( and ) , called brackets, must always appear in pairs and in this same order. They are used to delimit some calculations, parameters or conditions of the programs, marking their beginning with the symbol ( and the end with the symbol ) . Inside an expression, they indicate that the calculation within them must be done before the calculation out of them. For instance, the expression 2*3+2 will be evaluated as 8 , as the multiplication (2 by 3 equals 6) will be done first and then, the addition (6 plus 2 equals 8). Using brackets, it is possible to force to do the addition at first, expressing the calculation as 2*(3+2) , that will be evaluated as 10 , as now the addition (3 plus 2 equals 5) will be done first and then, the multiplication (2 by 5 equals 10). The brackets are also use to delimit the call parameters of the processes or the functions and inside the syntax of different statements of the language. ---See: Syntax - Expression","title":"( )"},{"location":"help/#_7","text":"Arithmetic operator of whole multiplication . This operator is used in the arithmetic expressions between two operands, to obtain the result of their multiplication. For instance, 2 * 8 will return 16 , 99 * 0 will return 0 , 2 * -1 will return -2 , etc. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the multiplication must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. This symbol is bi functional; it has two different uses depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator * will be a synonymous of POINTER . Example: &x is equivalent to POINTER x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator * will be the arithmetic operator of multiplication** previously explained. ---See: Syntax - Expression - POINTER","title":"*"},{"location":"help/#_8","text":"Operative assignment. Arithmetic operation of multiplication . The assignment statements are used to calculate expressions and to assign them to a variable. = ; If the symbol = * is used instead of = to perform the assignment, then the following multiplication** will be assigned to the variable: [ previous_value_of_the_variable ] * [ result_of_the_expression ] Example: x=2; x*=3; -> (x=6) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, a n *= m; type statement will be equivalent to this other n = n * m; statement. See the operator * for further information about the multiplication . ---See: Syntax - Assignment","title":"*="},{"location":"help/#_9","text":"Arithmetic operator of addition . This operator is used in the arithmetic expressions between two operands, to obtain their addition. For instance 2 + 6 will return 8, the result of 2 plus 6. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the addition must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. ---See: Syntax - Expression","title":"+"},{"location":"help/#_10","text":"Operator of increment. This operator, derived from the C language, allows us to increment the value of a variable (to add 1 to it) without requiring an assignment statement for that purpose. The variable can be a variable, a position of a table , or a field of a structure . This operator can be included in an expression with two forms: pre-increment and post-increment . Operator of pre-increment. When the symbol ** ++ is put just before a variable, 1 will be added to it before the execution of the statement**. As examples, see the following statements: ** ++x; - statement that will add 1 to the x** variable. ** z=++x+y; - statement that will add 1 to the x variable and then, it will assign the addition between x (already incremented) and y to the z** variable. Operator of post-increment. When the symbol ++ is put just after a variable, 1 will be added to it after the execution of the statement . As examples, see the following statements: ** x++; - statement that will add 1 to the x** variable. ** z=x+y++; - statement that will assign the addition between x and y to the z variable, incrementing then the y** variable. Summary: Generally, a ++variable; or variable++; type statement is always equivalent to the following statement: variable=variable+1; (or variable+=1; ). The difference between the pre-increment and the post-increment is that in the first case, the value of the variable already incremented is taken to evaluate the rest of the expression, while in the second case, the expression is evaluated with the value that the variable had before being incremented. ---See: Syntax - Expression - Decrement(--)","title":"++"},{"location":"help/#_11","text":"Operative assignment. Arithmetic operation of addition . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol += is used instead of = to perform the assignment, the result of the following addition will be assigned to the variable: [ previous_value_of_the_variable ] + [ result_of_the_expression ] Example: x=2; x+=2; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n += m; type statement will be equivalent to this other n = n + m; statement. See the operator + for further information about the addition . ---See: Syntax - Assignment","title":"+="},{"location":"help/#_12","text":"The symbol of the comma ( , ) is used inside the programming language, in different points of a program, to separate two consecutive elements of a list. It is used, for instance, in the following points: In the lists of constants to separate their different numeric values. In the definition of the parameters of a process to separate the names of the different parameters. In the call to a function and in the call to a process to also separate different expressions that will be assigned to the parameters of the function or process. In the FOR statement to separate different initialisations, conditions or increments. In the SWITCH statement to define the different values accepted in a block CASE ... END . The symbol of the comma can also be used to separate several declarations of data , instead of finishing each of them with a symbol semicolon ( ; ). ---See: Syntax","title":","},{"location":"help/#-","text":"Arithmetic operator of subtraction . This operator is used in the arithmetic expressions between two operands, to obtain the result of this subtraction. For instance, 2 - 6 will return -4, the result of subtracting 6 from 2. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the subtraction must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. This symbol is bi functional. That is to say, it has two different uses depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator ** - will be the minus sign**. Example: -7 the negative integer minus seven . A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator - will be the arithmetic operator of subtraction previously explained. ---See: Syntax - Expression","title":"-"},{"location":"help/#-_1","text":"Operator of decrement. This operator, derived from the C language, allows us to decrement the value of a variable (to subtract 1 from it) without requiring an assignment statement for that purpose. The variable can be a variable, a position of a table , or a field of a structure . This operator can be included in an expression with two forms: pre-decrement and post-decrement . Operator of pre-decrement. When the symbol -- is put just before a variable, 1 will be subtracted from it before the execution of the statement . As examples, see the following statements: ** --x; - statement that will subtract 1 from the x** variable. ** z=--x+y; - statement that will subtract 1 from the x variable and then, it will assign the addition between x (already decremented) and y to the z** variable. Operator of post-decrement. When the symbol -- is put just after a variable, 1 will be subtracted from it after the execution of the statement . As examples, see the following statements: ** x--; - statement that will subtract 1 from the x** variable. ** z=x+y--; - statement that will assign the addition between x and y to the z variable, decrementing then the y** variable. Summary: Generally, a --variable; or variable--; type statement is always equivalent to the following statement: variable=variable-1; (or variable-=1; ). The difference between the pre-decrement and the post-decrement is that, in the first case, the value of the variable already decremented is taken to evaluate the rest of the expression, while in the second case, the expression is evaluated with the value that the variable had before being decremented. ---See: Syntax - Expression - Increment(++)","title":"--"},{"location":"help/#-_2","text":"Operative assignment. Arithmetic operation of subtraction . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol -= is used instead of = to perform the assignment, the result of the following subtraction will be assigned to the variable: [ previous_value_of_the_variable ] + [ result_of_the_expression ] Example: x=4; x-=2; -> (x=2) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n -= m; type statement will be equivalent to this other n = n - m; statement. See the operator - for further information about the subtraction . ---See: Syntax - Assignment","title":"-="},{"location":"help/#-_3","text":"Operator of access to structures or to alien local data. The symbols . and -> are synonymous. Therefore, they can indistinctly be used. Access to structures. To access a field of a structure, this operator must be used in the following way: [ ] . (or, using the other symbol) [ ] -> Examples: scroll[0].camera m7[1]->z Note: Keep in mind that the record number in square brackets can be omitted when record number 0 is accessed. For instance, scroll[0].camera will always be equivalent to scroll.camera . Access to alien local data (belonging to another process). To access a LOCAL variable of a process from another one, the identifying code of the process whose variable is going to be read or modified must be known. Then, it will be possible to access it in the following way: . (or using the other symbol) -> Examples: father.x son->graph ---See: Declaration of a structure - Identifying codes - Syntax","title":". -&gt;"},{"location":"help/#_13","text":"Range of values of a section CASE --- The symbol .. (double period) is used to define a range of values. That is to say, to express the numbers ranging between two values (inclusive). This symbol is only used in the SWITCH statements , inside the sections CASE , to specify a range of values. It doesn't matter to express a range either as minimum..maximum or as maximum..minimum . For instance, the range defined as -2 .. 1 would be made up of the numbers -2 , -1 , 0 & 1 . ---See: Syntax - SWITCH statement","title":".."},{"location":"help/#_14","text":"Arithmetical operator of whole division . This operator is used in the arithmetic expressions between two operands, to obtain the quotient of the first one divided by the second one. For instance 7 / 3 will return 2 as, on doing the whole division of 7 by 3, the quotient will equal 2 (and the remainder will be 1). That is to say, n / m will always return the result of the division of n by m , but with no decimals (as all the variables are 32 bit integers with sign in the language). The remainder of a whole division is obtained through the operator MOD (module). ---See: Syntax - Expression","title":"/"},{"location":"help/#_15","text":"Operative assignment. Operation of whole division . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol /= is used instead of = to perform the assignment, the whole result (quotient) of the following division will be assigned to the variable: [ previous_value_of_the_variable ] / [ result_of_the_expression ] Example: x=8; x/=2; -> (x=4) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n/-= m; type statement will be equivalent to this other n = n / m; statement. See the operator / for further information about the whole division . ---See: syntax - Assignation","title":"/="},{"location":"help/#_16","text":"The symbol : (colon) is used to finish a CASE or DEFAULT declaration of a SWITCH statement . Actually, the symbols : (colon) and ; (semicolon) are synonymous in this language. That is to say, they can be used indistinctly. However, similarly to what happens in other programming languages, the symbol semicolon is normally used to finish statements and the symbol colon is normally used inside the syntax of the SWITCH statement . ---See: Syntax - CASE - DEFAULT - SWITCH statement","title":":"},{"location":"help/#_17","text":"The symbol ; (semicolon) is used in many points of a program to indicate always that a statement or any kind of declaration finishes. This is called finishing symbol, whose only purpose is to indicate the end of something. In the language, the following points of the program must be indicated with semicolon: The end of the PROGRAM declaration . The end of a declaration of a variable . The end of an IMPORT declaration . The end of the following statements: Assignments or increments of data . Calls to processes . Calls to functions . FRAME , RETURN , DEBUG , BREAK and CONTINUE . The end of the beginning of a loop FROM . And separating the different parts of a FOR statement. The compiler will indicate the lacking of the symbol ; in any of these points. It is also possible to put this symbol in other specific points of the programs, such as after any other kind of statement, even if it will be optional in this case and, therefore, the compiler won't report its lacking. Actually, the symbols ; (semicolon) and : (colon) are synonymous in this language. That is to say, they can be used indistinctly. However, similarly to what happens in other programming languages, the symbol semicolon is normally used to finish statements and the symbol colon is normally used inside the syntax of the SWITCH statement . ---See: Syntax","title":";"},{"location":"help/#_18","text":"Logical operator [ less than ] used in conditions. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T less than the second one. True - If the first expression IS less than the second one. Examples: 2+2 < 4 will return false . 1 < 2 will return true . ---See: Syntax - Condition","title":"&lt;"},{"location":"help/#_19","text":"Binary operator of rotation to the left . This operator is used in the arithmetic expressions , between two operands, to obtain the result of rotating the first operand to the left as many times as indicated by the second. For instance, the following rotation: n << m Will return n rotated to the left m times. Every rotation to the left is equivalent to multiplying the number by 2. That is to say, rotating to the left once, is equivalent to multiplying by 2; rotating to the left twice is equivalent to multiplying by 4; 3 times is equivalent to multiplying by 8, and so on. Or, what is the same, (the POW function (2, m) returns 2 raised to m ): n * POW(2, m ) For instance, 2<<3 will return 16, 4<<1 will return 8, 100<<0 will return 100, etc. All the variables are 32 bit integers with sign in the language. Therefore, only integers within the range ( min_int ... max_int )} can be used. Then, when the result of the rotation must exceed that range, incorrect results will be shown . In this case, the system won't report any error. Hence, much care must be taken. The operator of rotation to the right (the contrary operation) is the symbol >> . ---See: Syntax - Expression","title":"&lt;&lt;"},{"location":"help/#_20","text":"Operative assignment. Binary operation of rotation to the left . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol <<= is used instead of = to perform the assignment, the result of the following rotation will be assigned to the variable: [ previous_value_of_the_variable ] << [ result_of_the_expression ] Or, what is the same, (the POW function (2, n) returns 2 raised to n ): [ previous_value_of_the_variable ] * POW(2, [ result_of_the_expression ] That is to say, if the result of the expression is: 0 -> the variable will maintain its value. 1 -> the variable will be multiplied by 2. 2 -> the variable will be multiplied by 4. 3 -> the variable will be multiplied by 8. ... Example: x=2; x<<=2; -> (x=8) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n <<= m; type statement will be equivalent to this other n = n << m; statement. See the operator << for further information about the rotation to the left . ---See: Syntax - Assignment","title":"&lt;&lt;="},{"location":"help/#_21","text":"Logical operator [ less than or equal to ] used in conditions. The symbols <= and =< are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T less than or equal to the second one. True - If the first expression IS less than or equal to the second one. Examples: 2+2 <= 3 will return false . 2+2 <= 4 will return true . ---See: Syntax - Condition","title":"&lt;= =&lt;"},{"location":"help/#_22","text":"The symbol = (symbol of assignment ) is used in the language inside the data declarations to initialise them to their initial value. In the assignment statements , this symbol is used to separate the reference to the variable from the assigned expression. Inside an expression, this operator can be used as a conventional binary arithmetic operator, which is placed between two operands, returning the second operand's value as a result (besides assigning this result to the variable defined as first operand). This operator represents an imperative order according to which, on executing the statement that contained it, the first operand (before the symbol) will take the value of the second operand (or expression after the symbol). On evaluating an expression, the assignment operands are always those of less priority (the last ones that are interpreted in the expression), being possible to use brackets to force a bigger priority. If, in an expression (or statement) several assignment operands have been used, they will be evaluated (executed) from right to left. For instance, in the statement: x=y=x+y; The addition ( x+y ) will first be done. Then, the result will be assigned as the new value of the y variable ( y=x+y ) and, finally, this same value will be assigned to the x variable ( x=y ). ---See: Syntax - Data declarations - Assignment statements","title":"="},{"location":"help/#_23","text":"Logical operator [ equal to ] used in conditions. It must be used between two numeric expressions and it returns a logical result: False - If the expressions give different results, as they AREN'T equal (or equivalent). True - If both expressions give the same result (if they are equivalent expressions), as they ARE equal. Examples: 0 == -1 will return false . 2+2 == 4 will return true . Note: The symbol = can not be used to compare two expressions or numeric values, as it is the assignment symbol. ---See: Syntax - Condition","title":"=="},{"location":"help/#_24","text":"Logical operator [ bigger than or equal to ] used in conditions. The symbols >= and => are synonymous. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T bigger than or equal to the second one. True - If the first expression IS bigger than or equal to the second one. Examples: 2+2 >= 3 will return false . 2+2 >= 4 will return true . ---See: Syntax - Condition","title":"&gt;= =&gt;"},{"location":"help/#_25","text":"Logical operator [ bigger than ] used in conditions. It must be used between two numeric expressions, and it returns a logical result: False - If the first expression ISN'T bigger than the second one. True - If the first expression IS bigger than the second one. Examples: 2+2 > 4 will return false . 2 > 1 will return true . ---See: Syntax - Condition","title":"&gt;"},{"location":"help/#_26","text":"Binary operator of rotation to the right . This operator is used in the arithmetic expressions , between two operands, to obtain the result of rotating the first operand to the right as many times as indicated by the second one. For instance, the following rotation: n >> m Will return n rotated to the right m times. Every rotation to the right is equivalent to dividing the number by 2. That is to say, rotating to the right once, is equivalent to dividing by 2; rotating to the right twice is equivalent to dividing by 4; 3 times is equivalent to dividing by 8, and so on. Keep in mind that all the numbers used in this language are integers (with no decimals). Therefore, an integer will always be returned as a result of the division (for instance, 7 divided by 2 will return 3). Or, what is the same, (the POW function (2, m) returns 2 raised to m ): n / POW(2, m ) For instance, 16>>3 will return 2, 2>>1 will return 1, 100>>0 will return 100, etc. The operator of rotation to the left (the contrary operation) is the symbol << . ---See: Syntax - Expression","title":"&gt;&gt;"},{"location":"help/#_27","text":"Operative assignment. Binary operation of rotation to the right . The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol >>= is used instead of = to perform the assignment, the result of the following rotation will be assigned to the variable: [ previous_value_of_the_variable ] >> [ result_of_the_expression ] Or, what is the same, (the POW function (2, n) returns 2 raised to n ): [ previous_value_of_the_variable ] / POW(2, [ result_of_the_expression ] That is to say, if the result of the expression is: 0 -> the variable will maintain its value. 1 -> the variable will be divided by 2. 2 -> the variable will be divided by 4. 3 -> the variable will be divided by 8. ... Example: x=8; x>>=2; -> (x=2) The result of a rotation to the right will always be an integer, with no decimals or, what is the same, the quotient of the previous whole division. Example: x=9; x>>=2; -> (x=2) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n >>= m; type statement will be equivalent to this other n = n >> m; statement. See the operator >> for further information about the rotation to the right . ---See: Syntax - Assignment","title":"&gt;&gt;="},{"location":"help/#pointer","text":"Addressing operator. This operator requires a slightly advanced level in programming techniques. The use of pointers is a characteristic of other languages that, even if it may be very useful, is not indispensable to make programs, no matter how difficult they are. The reserved word POINTER is used to make reference to a specific position of the computer's memory. Practical case. --- For instance, having a variable named my_variable with value 3 , which will be stored in an offset of the memory (all the variables have an offset), the operator OFFSET is used to obtain this offset. Supposing that there is another variable named offset_of_my_variable used to store the offset of the previous variable, which would be done with the following statement: offset_of_my_variable = OFFSET my_variable; This offset will be an integer, for instance 12345 . In order to obtain or modify the value of the variable ( 3 ), having only the offset (position) of the variable (and not its name) in the memory, the operator POINTER must be used. The statement to obtain the value of the variable from its offset would be as follows: my_variable = POINTER offset_of_my_variable; A series of expressions and their numeric equivalents are now shown in order to clarify the concepts of name of the variable , offset of the variable and value of the variable . my_variable = 3 OFFSET my_variable = 12345 offset_of_my_variable = 12345 POINTER offset_of_my_variable = 3 The offset of a variable may vary as a program is expanded (by adding new data and statements to it). In short, {the operator POINTER accesses the value that is in the position of the computer's memory indicated after it}. That is to say: POINTER 12345 = 3 It means that value 3 is in the offset 12345 of the computer's memory, as it is in this offset where the value of the my_variable variable is stored , and it is its value. The symbol * and the symbol ^ may be used as synonyms of the reserved word POINTER (in the previous example 12345 * = 3 or ^12345 = 3**). The square brackets (symbols [ ] ) work in a similar way to the operator POINTER , with the proviso that they access the variable whose offset is indicated in them (in the previous example [12345] = 3 ). The square brackets are also used to specify the index in the tables and structures. ---See: Syntax - OFFSET","title":"POINTER [ ]"},{"location":"help/#_28","text":"This symbol is bi functional; it has two different uses, depending on whether it is used as an unary or binary operator. A UNARY operator appears inside an expression, simply preceding an operand (as if it was its sign). In this case, the operator ^ will be a synonymous of POINTER . Example: ^x is equivalent to a POINTER x A BINARY operator appears inside an expression, concatenating two operands (showing an operation between both). In this case, the operator ^ will be a synonymous of XOR . Example: x^2 is equivalent to x XOR 2 ---See: Syntax - POINTER - XOR","title":"^"},{"location":"help/#_29","text":"Operative assignment. Logical and binary operation of exclusive OR ( XOR ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol ^= is used instead of = to perform the assignment, the following exclusive OR will be assigned to the variable: [ previous_value_of_the_variable ] XOR [ result_of_the_expression ] Example: x=5; x^=3; -> (x=3) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n ^= m; type statement will be equivalent to this other n = n XOR m; statement. See the operator XOR for further information about the exclusive OR . ---See: Syntax - Assignment","title":"^="},{"location":"help/#xor","text":"Logical and binary operator of exclusive OR used in expressions and conditions. The reserved word XOR and the symbol ^^ are synonymous. XOR logical: The conditions on the right and left of the operator are first evaluated and, if (only one) is true , this operator will return true . Otherwise, the operator will always return false . FALSE XOR FALSE = FALSE FALSE XOR TRUE = TRUE TRUE XOR FALSE = TRUE TRUE XOR TRUE = FALSE It is used to verify that one (and only one) of the two specified conditions is complied; for instance: (y>0 XOR x>0) To verify either that the first variable is bigger than 0, or (exclusive\"or\") that the second variable (but not the first one) is bigger than 0. XOR binary: Evaluates the bits of the results of the expressions appearing before and after the operator, giving as a result a value of 1 only for those bits that had at 1 one (and only one) of the expressions. 0 XOR 0 = 0 0 XOR 1 = 1 1 XOR 0 = 1 1 XOR 1 = 0 This rule will be applied to all the bits of the operands (in the language, they are integers of 32 bits). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator XOR will only leave the last bit at 1 (it will only return true as a result} when one (and only one) of both operands have this bit at 1 (when only one of the two expressions is true ). Note: The symbol ^ can also be used as another synonymous of XOR ** and ^^**. ---See: Syntax - Expression - Condition - OR","title":"XOR ^^"},{"location":"help/#or","text":"Binary operator of logical addition used in expressions and conditions. The reserved word OR and the symbols || and | are synonymous. OR logical: The conditions to the right and left of the operator are first evaluated and if, at least, one of them is true , this operator will return true . Otherwise, the operator will always return false (when both conditions are false ). FALSE OR FALSE = FALSE FALSE OR TRUE = TRUE TRUE OR FALSE = TRUE TRUE OR TRUE = TRUE It is used to verify that one of the specified conditions is complied; for instance: (x>0 OR y>0) To verify that, at least, one of both variables is bigger than 0. That is to say, it is verified that the first OR the second conditions are complied. OR binary: Evaluates the bits of the results of the expressions appearing before and after the operator, giving as a result a value that will have at 1 the bits that any of the expressions would have at 1. 0 OR 0 = 0 0 OR 1 = 1 1 OR 0 = 1 1 OR 1 = 1 This rule will be applied to all the bits of the operands (in the language, they are 32 bit integers). Note: This operator indistinctly works as logical and binary as, in the language, the true logical expressions are interpreted as those that have their last bit at 1 (bit 0, weight 1) or, in other words, the odd numbers (1, -1, 3, -3, ...). And the false logical expressions are interpreted as those having their last bit at 0 (the even numbers: 0, 2, -2, 4, -4, ...). The operator OR will leave the last bit at 1 (it will return true as a result) when one of any of the operands have this bit at 1 (when, at least, one of the two expressions is true ). ---See: Syntax - Expression - Condition - XOR","title":"OR || |"},{"location":"help/#_30","text":"Operative assignment. Binary operation of logical addition ( OR ). The assignment statements are used to calculate expressions and assign them to a variable. = ; If the symbol |= is used instead of = to perform the assignment, the following logical addition will be assigned to the variable: [ previous_value_of_the_variable ] OR [ result_of_the_expression ] Example: x=5; x|=6; -> (x=7) Note: This symbol is a simple abbreviation derived from the C language . Anyhow, the n |= m; type statement will be equivalent to this other n = n OR m; statement. See the operator OR for further information about the logical addition . Note: don't confuse this symbol with that of [ different from ] expressed as != , that is used to compare whether two expressions have different results. ---See: Syntax - Assignment","title":"|="},{"location":"help/#offset","text":"The reserved word OFFSET allows us to obtain the offset of a variable inside the computer's memory. All the data of a program correspond with any specific position of the memory in which its value is stored. The operator OFFSET allows us to obtain this position as a numeric value. This operator is mainly used in the parameters of any of the language's functions. Thus, these functions are able to modify these parameters. If you have a variable (called, for instance, my_variable ) with value 321 and this variable is passed, as a parameter, to a parameter function, the number 321 is being passed to the function. Then, the function won't be able to modify the variable, as it knows its value but not where the variable is (because many 321 values may exist in the whole computer's memory, and it won't know which of them is the variable). If OFFSET my_variable is passed to this function as a parameter, it is receiving information about the place in which the variable value is stored. Then, the function will be able to access this value in order to consult it or modified it. For further information about this operator, it is possible to access the operator POINTER that does the operation opposite to that of the operator OFFSET (it obtains the value stored in a specific position of the memory). The symbol & can be used as synonymous of the reserved word OFFSET . ---See: Syntax - POINTER","title":"OFFSET"},{"location":"help/#begin","text":"This reserved word shows the beginning of the program or process. That is to say, the word BEGIN is used to separate the area of data declaration of the main program or of a process, from the area of statements. The BEGIN declaration is obligatory in the main program and in all the processes. When a program or process are executed, they will always start with the statement coming after BEGIN . The BEGIN statement does nothing . It is only used as a delimiting element inside the structure of the programs. Every BEGIN is directly linked to an END that will mark the end of the area of statements of the program or process. ---See: Syntax - Main Code - Declaration of processes - FUNCTION","title":"BEGIN"},{"location":"help/#case","text":"This reserved word is a part of the SWITCH statement. It is used as the beginning of the different sections of statements that can or can not be executed, depending of the result of the evaluated expression. Every CASE must have a word END indicating the end of the section. The SWITCH statement evaluates an expression, and the word CASE means \" in case that the result of the expression is ..., then the following statements must be executed ... \". ---See: Syntax - SWITCH statement","title":"CASE"},{"location":"help/#default","text":"This reserved word is a part of the SWITCH statement, that is used to begin a section of statements that must be executed when the result of the evaluated expression is not contemplated in any of the sections CASE of the statement. Every DEFAULT must have a word END indicating the end of the section. The SWITCH statement evaluates an expression. Every section CASE of the statement will contemplate one of several results in which that section must be executed. Finally, a section DEFAULT appears to express \" in case that the result of the expression is none of the previous ones, then the following statements must be executed ... \". ---See: Syntax - SWITCH statement","title":"DEFAULT"},{"location":"help/#dup","text":"This word is used to define lists of constants (numeric values), by repeating a simple pattern. It is used to initialise the initial values of tables and structures. Its syntax is as follows: DUP ( ) It is equivalent of putting the the indicated . For instance, the sequence 1, 2, 3, 1, 2, 3, 1, 2, 3 would be equivalent to the sequence 3 DUP (1, 2, 3) . ---See: Syntax - Definition of a list of constants","title":"DUP"},{"location":"help/#else","text":"This word is a part of the IF statement, and is used to specify where the block of statements that must be executed starts when the condition specified in the IF is not complied. The format of the IF statement is the following one: IF (< condition >) // Code to execute when the condition is complied ELSE // Code to execute when the condition isn't complied END The meaning of ELSE is \" otherwise ... \". The section ELSE is optional. The IF statement can be formulated in the following way: IF (< condition >) // Code to execute when the condition is complied END When no statement is required to be executed in the opposite case . ---See: Syntax - IF statement","title":"ELSE"},{"location":"help/#end","text":"This reserved word marks the end of one of the following statements: BEGIN IF WHILE SWITCH CASE DEFAULT FOR FROM LOOP CLONE That is to say, the function of the word END is to delimit where a statement finishes . Keep in mind that the statements may be nested (they may be included one inside another). Therefore, if a program is not well structured (tabulating the code), it can be difficult to find out to which statement each END corresponds. For instance, in the following code it is possible to see clearly to which statement each END belongs. BEGIN IF (x>0) x=x-1; END END But this same code could have been expressed as follows: BEGIN IF (x>0) x=x-1; END END being much more complicated the reading of the program, even if for the compiler of the language both code blocks are exactly the same (the compiler will continue to interpret that the first END is that of the IF statement and the second one that of the BEGIN statement, even if they are incorrectly tabulated). ---See: Syntax","title":"END"},{"location":"help/#id","text":"The reserved word ID is used to obtain the identifying code of a process while executing. An identifying code is a numeric value that identifies each of the active processes at any moment (each of the game's objects). That is to say, ID is like a numeric constant, with the only difference that its value will be different for each consulted process. It is not possible to change the value of ID , as it is a simple object of reading. Normally, a process accesses this value when it intends to report to other processes its identifying code . ---See: Syntax - Identifying codes","title":"ID"},{"location":"help/#setup_program","text":"This reserved word is used to designate special kinds of programs, related to the sound hardware setup . The special characteristic of these programs is that they start with the reserved word SETUP_PROGRAM instead of PROGRAM . This topic is very advanced, for expert users only. A program of this type can be observed in the SETUP directory of DIV Games Studio. These programs, once they have been compiled, will automatically be included in the installations of the rest of the programs, when the box \" Include sound setup \" is activated during the installation process. Note: In the installations, the last setup program compiled in DIV Games Studio will always be included. However, keep in mind that it is not indispensable to create sound setup programs, as the games created with DIV Games Studio will automatically detect whether the computer in which they are executed is provided with a sound card compatible with Sound Blaster or Gravis Ultrasound , providing that it is correctly configured. This kind of programs normally modify the setup global structure , that controls the parameters of the sound system. ---See: Syntax - Setup structure","title":"SETUP_PROGRAM"},{"location":"help/#sizeof","text":"SIZEOF( ) Returns: The numbers of elements contained in the variable. Description: The reserved word SIZEOF is used to calculate the number of elements that a table or a structure have. This reserved word is used as if it was a function of the language, indicating in brackets, the name of the variable and returning the number of elements (positions) of the latter. It can be used to obtain the number of elements of a variable but, in this case, SIZEOF will always return 1 as the number of elements (as a variable is a single element). Example program: PROGRAM example_sizeof; PRIVATE table1[]=0, 1, 2, 3; table2[]=4, 5, 6, 7, 8; variable=9; BEGIN // ... save(\"help.dat\", OFFSET table1, SIZEOF(table1)+SIZEOF(table2)+SIZEOF(variable)); // ... END - In this example, SIZEOF is used to obtain the number of elements of the following three data: table1 of 4 elements. table2 of 5 elements. variable ( 1 element). In this case, it is used to save in the help.dat file the contents of these three data with the save() function that requires the number of elements intended to be stored in the file, as a third parameter. In this case, 10 elements will be stored in the help.dat file, numbers from 0 to 9 , according to the initialisation of the data in the example. The save() statement of the previous example could have also been expressed without using SIZEOF , in the following way: save(\"help.dat\", OFFSET table1, 10); There is only one difference: if, in the program of the example, some elements were added to any of the two tables, it would be not necessary to modify the call to the save() function, as SIZEOF will always return the current size of the tables. ---See: Syntax - Declaration of a table - Declaration of a structure","title":"SIZEOF()"},{"location":"help/#step","text":"The reserved word STEP is a part of the FROM statement and it is used to indicate the increment (step) that has to be made in every loop iteration. The FROM statement implements a loop, a group of statements that are going to be repeated a specific number of times. For that, it uses a variable as a counter of the number of repetitions. Both the initial and final values of the variable are defined. The loop will be repeated until the variable reaches the final value, starting from the initial value. By default, the variable will pass through all the whole numeric values ranging between the initial and final values. But it is possible to indicate a STEP declaration to establish a different variable increment. For instance, if a loop in which the x variable is going to have the values ranged from 1 to 10 is defined, this loop will be executed a total of 10 times. But if STEP is established as 2 , then the loop will only be executed 5 times, in which the x variable will take the 1 , 3 , 5 , 7 and 9 values, as it has been established that the variable must be incremented 2 by 2 . This loop would be implemented in the following way: FROM x=1 TO 10 STEP 2 // Statements that are going to be repeated five times END If the STEP declaration is omitted from the FROM statement, then the increment will always be 1 by 1, adding 1 to the variable after every loop iteration (or subtracting 1, in case that the final value is less than the initial value). Note: Only whole increments can be established. ---See: Syntax - FROM statement","title":"STEP"},{"location":"help/#to","text":"The reserved word TO is a part of the FROM statement and it is used to separate the constants that indicate the initial and final values that the variable used as a loop counter must take. The FROM statement implements a loop, a set of statements that are going to be repeated a specific number of times. For that, it uses a variable as a counter of the number of repetitions. Both the initial and final values of the variable are defined. The loop will be repeated until the variable reaches the final value, starting from the initial value. Example: FROM x=1 TO 10 // Statements that will be repeated 10 times END By default, the variable will take all the whole numeric values ranging between the initial and final values. But it is possible to indicate a STEP declaration to establish a different increment of the variable. ---See: Syntax - FROM statement - STEP","title":"TO"},{"location":"help/#until","text":"The reserved word UNTIL is a part of the REPEAT statement, whose syntax is, broadly speaking, the following one: REPEAT ; ... UNTIL (< condition>} ) The REPEAT statement implements a loop, it is capable of repeating a set of statements a specific number of times. The end of the statement is determined by putting the reserved word UNTIL followed by the condition that must be complied so that the statement finishes . ---See: Syntax - REPEAT statement","title":"UNTIL"},{"location":"help/#global-struct-mouse","text":"STRUCT mouse; x, y; // Coordinates graph; // Graphic code file; // File code z; // Depth plane angle; // angle size; // Size (%) flags; // Mirrors indicator region; // Clipping region left, middle, right; // State of buttons cursor; // Emulation with cursors speed; // Speed of mouse END This global structure is used to control the mouse. It contains a series of fields related to the programming of this driver, such as the screen position, the pointer graphic, the state of the buttons, etc. In order to access these fields, the name of the field must be preceded by the word mouse and by the symbol . (period) . For instance, in order to access the field x (horizontal coordinate of the mouse pointer), it is necessary to use mouse.x . x , y - Horizontal and vertical coordinates of the mouse. It will be necessary to read only these two fields ( mouse.x and mouse.y ) to know the position of the mouse cursor on screen. To locate the mouse at other coordinates (to force its position), suffice will be to assign the new coordinates to these two fields. graph - Graphic code assigned as a mouse pointer. By default the mouse won't be visible . To make it visible, it is necessary to create the graphic that is going to be used as a pointer in the graphic editor , to load it in the program (with the load_fpg() or load_map() or load_pcx() functions, depending on whether this graphic has been stored in a file FPG or in an file MAP/PCX ) and finally, to assign its graphic code to this variable ( mouse.graph ). Then, the mouse pointer will be seen on screen. The centre of the graphic will appear at the mouse.x , mouse.y coordinates, unless its control point number 0 has been defined in the graphic editor . If this point (usually called hot spot ) is defined, then it will appear at the coordinates indicated in the fields mouse.x and mouse.y . For instance, if an arrow is created to depict the mouse pointer (as it happens dealing with the mouse pointer of DIV Games Studio), the hot spot (control point number 0 ) will be defined in the upper left corner of the graphic, as it is the active point inside the graphic. Then, when the mouse was located at the (0, 0) coordinates, for instance, the \" tip of this arrow \" would precisely be located at those coordinates file - File code containing the graphic. The file code containing the graphic of the mouse pointer is defined in this field. It is not necessary to indicate a value here if the graphic was loaded from an file MAP or PCX , or if it is stored in the first file FPG loaded in the program. Otherwise, mouse.file will have to be assigned the file code that returned the load_fpg() function on loading the file that contains the graphic of the mouse pointer. z - Priority of the graphic display. Indicates the depth plane in which the graphic of the mouse pointer must be displayed. By default this field will be equal to -512 , which implies that the pointer will be seen above the rest of graphics and texts . The bigger this field is, the deeper the mouse pointer will be located. If the aim was to make a graphic of a process appear above the mouse pointer, suffice would be to assign an integer lesser than -512 (for instance, -600 ) to the local z variable of that process. angle - angle with which the graphic of the mouse pointer will be seen. The value of mouse.angle by default is 0 , which implies that this graphic won't be seen rotated, unless a new angle is assigned to this field. Keep in mind that the angles must be specified in degree thousandths. For instance, the mouse.angle=90000; statement will make the pointer appear rotated 90 degrees (see the use of angles in the language ). size - Size of the graphic in percentage. By default, this field will be equal to 100 (the graphic will be seen 100%). Then, it is not necessary to indicate another value here, unless the aim is to scale the graphic (to display it expanded or reduced). If, for instance, the aim was to double the original size of the graphic (being displayed at 200%), the mouse.size=200; statement should be used. flags - In this field, different values will be indicated when the aim is to mirror the graphic of the mouse (horizontally or vertically inverted), or to display it as a (semi) transparent graphic. The possible values that can be assigned to the mouse.flags are the following ones: 0 -Normal graphic (value by default). 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Transparent and horizontal mirror. 6 -Transparent and vertical mirror. 7 -Transparent, horizontal and vertical mirror. region - Graphic's clipping region. A value must be assigned to this field just when the aim is to make the mouse pointer visible only inside a region (a rectangular zone of the screen). In order to achieve it, it is necessary first to define this region with the define_region() function and then, to assign the number of the region that has been defined to this field ( mouse.region ). By default, this value will be equal to 0 , that is a number of region referred to the entire screen. Therefore, the graphic will be seen on the whole screen. left , middle and right - These three fields store logical values ( 0 or 1 ) depending on whether the mouse buttons are pressed or not (they correspond with the left, central and right mouse buttons). Normally, only two buttons of the mouse ( left and right ) are activated, being ignored the state of the central button. This depends on the mouse driver installed in the computer. For instance, to perform an action in a program when the mouse left button is pressed ( mouse.left ), it is necessary to include the following statement in the code: IF (mouse.left) // Action to perform (statements) END cursor - indicates if the mouse emulator is active with the Cursors and Enter keys, you can move the pointer with the mouse or with the cursors. By default, this emulation will be deactivated ( mouse.cursor=0; ). If the program doesn't detect a mouse connected to the system, the emulation automatically in this case will be activated (this means, that if mouse.cursor values are 1 at the beginning of the program, then there is no mouse connected to the pc). speed - it is now possible to regulate the speed at which the mouse pointer functions in the programs. This is a value between 0 (maximum speed) and 9 (minimum), by default mouse.speed will have the value 2 . ---See: Global data","title":"GLOBAL STRUCT mouse"},{"location":"help/#global-struct-scroll","text":"STRUCT scroll[9]; x0, y0; // Foreground's coordinates x1, y1; // Background's coordinates z; // Depth plane camera; // Identifying code of the camera ratio; // Relative speed of the background speed; // Maximum speed of the foreground region1; // First screen region region2; // Second screen region END This 10 record structure contains certain fields related to changeable parameters of the scroll windows . These ten records have the same field names, but each of them modifies the parameters of a different scroll window (as up to 10 windows of this type can be activated). A scroll window could be defined as a screen region that only shows a part of a graphic bigger than that window (this graphic is normally the decor or background of the game). The scroll is the movement of that window through the graphic in any direction, being displayed the entire graphic little by little, section by section. For a record (from 0 to 9 ) of the scroll structure to make sense, that scroll window (from 0 to 9 ) must first be activated with the start_scroll function (for further information about the scroll windows, see this function}. It is understood that the fields of this structure are complementary to those of the call parameters of this last function. How to use the scroll structure: To access these fields, the field name must be preceded by the word scroll , the record's number in square brackets and the symbol . (period). For instance, if two scroll windows, number 0 and number 1, are initialised, it could be possible to access the camera field of both windows as scroll[0].camera and scroll[1].camera , respectively. Moreover, when the scroll window number 0 is accessed, it is possible to omit the window's number in square brackets. That is to say, the scroll.camera and the scroll[0].camera variables are, to all intents and purposes, the same for the language. A detailed description of every field is now shown. x0, y0 - Coordinates of the scroll's foreground, when the scroll ISN'T automatic (the camera field has not been defined), These are the fields that will have to be modified in order to move the scroll window's foreground . These two fields store the horizontal and vertical coordinates of the upper left corner of the scroll window (the point of the foreground's graphic that will be seen in the window's upper left corner). When the camera field of this structure has been defined, the movement of the scroll window will be automatic; thus, they are read-only fields. In order to check where the scroll is at every moment (see the move_scroll() function). x1, y1 - Background's coordinates, when a graphic for the background has been defined. When the scroll ISN'T automatic (the camera field has not been defined), these are the fields to modify in order to move the background of the scroll window . When the camera field of this structure has been defined, the movement of the scroll window will be automatic; thus, they will be read-only fields, and the definition of the background's movement speed will depend on the ratio field of the same structure. z - Scroll display priority, to indicate the depth plane in which this window must be painted, with respect to the rest of processes. By default, this variable will equal 512 , which implies that, as the processes have their local z variable at 0 by default, the scroll window will be painted in a greater (deeper) depth plane, being the graphics of the processes displayed above the window. In order to vary this situation, it is possible to modify either the z window's variable (for instance, putting it at -1 ) or the z processes' variable (for instance, putting it at 600 ). camera - It is not necessary to initialise this field, as it will be initialised when the aim is that the scroll is automatic , that the system deals with it to always follow a process (a game's graphic). For that, it is necessary to put the process' identifying code in this field. Thus, the shift of the scroll window will pass to be controlled automatically by the system, always trying to centre the graphic of this process in the window. This process must have the ctype local variable with the value c_scroll . By default, this field will equal 0 , which implies that the scroll won't follow any process, unless the identifying code of a process is assigned to camera . When it is done, this process will be known as the scroll's camera process . Note: A series of fields are now shown only for automatic scroll windows . It means that for those fields to make sense (and, therefore, effect), the camera field of this structure has to be defined previously with the identifying code of the process that is going to be centred in the scroll. These values will affect the way in which the process called scroll camera is going to be followed. ratio - Automatic scroll windows . When two scroll planes have been defined in the call to the start_scroll() function, in this field it is possible to define the movement speed of the background with respect to that of the foreground. By default, this value will equal 200 , which implies that the background will move half the speed of the foreground; if it is defined as 400 , it will move at the fourth part (four times slower), 100 at the same speed, 50 at double speed of the foreground, etc. speed - Automatic scroll windows . Maximum speed of the scroll foreground, which will equal 0 by default. It means that no speed limit is imposed. If a limit is imposed, specifying the maximum number of points that the foreground can be shifted for every game's frame, the camera process will be off centre in the scroll window when it is moved at a higher speed. region1 - Automatic scroll windows . Scroll lock region, whose value by default equals -1 , which means that there is no lock region. If this field is defined with a number of region (a rectangular zone of the screen previously defined with the define_region() function), then the system won't scroll as long as the camera process remained inside it. region2 - Automatic scroll windows . External region of the scroll. By default, its value is equal to -1 , which means that there is no external region. If this field is defined with a region's number and a maximum speed has been defined in the speed field, then the system will ignore that speed limit when the camera process is going to exceed from this region (it is done in order to continue to see the process (for its graphic to be visible always within the scroll window). Note: If the two regions ( region1 and region2 ) are defined, region 1 is normally lesser than region 2 (the first one is contained in the second one). It will imply that: The background won't shift (the scroll won't be performed) while the camera process' graphic is inside region 1. If a maximum speed has been defined, then a scroll will be performed to try to restore the graphic of the camera process to region 1, but without exceeding the imposed speed limit. If the graphic of the camera process tried to exceed from region 2, the imposed speed limit would be ignored in order not to allow it. ---See: Global data - start_scroll() - stop_scroll()","title":"GLOBAL STRUCT scroll"},{"location":"help/#global-struct-m7","text":"STRUCT m7[9]; camera; // Identifying code of the camera height; // Height of the camera distance; // Distance of the camera horizon; // Height of the horizon focus; // Focus z; // Depth plane colour; // colour of the exterior END This 10 record structure contains certain fields dealing with changeable parameters of the mode 7 window . The ten records have the same fields names, but each of them modifies the parameters of a different mode 7 window (as up to 10 windows of this type may be activated). A mode 7 window could be defined as a screen region that shows a graphic plane three-dimensionally folded (for instance, like a sheet of paper with a picture horizontally positioned, displayed on screen with a virtual bottom (or top). For a record (numbered from 0 to 9 ) of the m7 structure to make sense, that mode 7 window (from 0 to 9 ) must first be activated with the start_mode7() function (see this function for further information about the mode 7 windows}. It is understood that the fields of this structure are complementary to the call parameters of this function. In order to observe a practical example of a mode 7, it is possible to access the help about the start_mode7() function. How to use the m7 structure: To access these fields, the field name must be preceded by the word m7 , the number of record in square brackets and the symbol . (period) . For instance, if two mode-7 windows, number 0 and number 1, were initialised the camera variable of both windows could be accessed as m7[0].camera and m7[1].camera , respectively. When the mode-7 window number 0 is accessed, it is also possible to omit the number of windows in square brackets. The m7.camera variable and the m7[0].camera variable are, to all ends, the same for the language. A detailed description of each field is now shown. camera - Identifying code of the process followed by the camera. To move the camera that controls the mode-7 view, only a mode-7 process must be created, a process having its local variable ctype = c_m7 , and its identifying code must be put in the camera variable of this structure. After so, only the x , y and angle local variables of this process must be modified and, for instance, the advance() function must be used to move forward the camera. For the mode 7 window to be activated, it is indispensable to initialise the camera field. Without this field, the window can not determine from where the folded plane must be seen . height - Height of the camera. This variable of the structure manages the distance to which the camera is placed from the bottom. By default, its value equals 32 . Any positive number will make the camera be placed upper as the number is greater. If a negative number (less than zero) is put in the height field of this structure, then the camera will be placed below the folded plane, showing a \" top \" instead of a \" bottom \". Two mode-7 must be created within the same region: one as top and the other as bottom (one with positive height and the other with negative height). In this case, it is important to establish the z variable of the m7 structure of both, to thus determine the depth plane in which each one must be painted. distance - Distance from the camera to the followed process. The perspective of the camera will always be positioned slightly behind the process whose identifier has been put in the camera field of the structure. This is done for the graphic of the process used as a camera to be seen, just in case this process has defined it (in its graph or xgraph local variable). By default, the camera will be positioned at 64 points behind the process. \"Behind\" means a point placed at the indicated distance from the graphic in the angle opposite to that one to which the process is orientated. For instance, if the process is facing right, 64 points to its left. horizon - Horizon's height. This is the same value as that indicated as last parameter of the start_mode7() function. Its initial value will equal to the one indicated in the call to this function. The utility of this variable is to make the horizon go up or down in every frame of the game, depending on the needs of the latter. On changing the horizon's height , the \" facing up \" and \" facing down \" effects will be obtained in the mode 7 window . focus - Focus for the camera. This variable controls the perspective of the camera. By default, its value equals 256, but any value ranging from 0 and 512 may be put, obtaining different distortion effects of the three-dimensional plane. This field controls the angle got by the camera focus. The greater this value is, the closer all the objects (processes) placed in the folded plane will be seen. z - Mode-7 display priority. To indicate the depth plane in which this window must be painted, with respect to the rest of processes. By default, this variable will equal 256 , which means that, as the processes have their local z variable at 0 by default, the mode-7 window will be painted in a greater (deeper) depth plane, being the graphics of the processes painted above the window. This situation may change by modifying the z variable of the window (for instance, putting it at -1 ) or the z variable of the processes (for instance, putting it at 257 ). colour - colour for the mode-7 exterior. When, in the call to the start_mode7() function, any external graphic is not specified (the fourth call parameter is put at 0 ), this variable will control the colour in which it is aim to paint the exterior. In other words, the colour that the screen must be painted in beyond the graphic that is being folded (beyond its limits). By default, this field is initialised at 0 , which is normally the black colour in the colour palette, Therefore, if this field is not assigned another value (and an external graphic is not defined) the screen will be seen in black beyond the foreground. ---See: Global data - start_mode7() - stop_mode7()","title":"GLOBAL STRUCT m7"},{"location":"help/#global-struct-joy","text":"STRUCT joy; left; // Left control right; // Right control up; // Up control down; // Down control button1; // First button button2; // Second button button3; // Third button button4; // Fourth button END This global structure is used to control the joystick . It contains a series of logical fields related to the programming of this device: the state of the buttons (whether they are pressed or not) and the state of the main four control directions. To access these fields, the name of the field must be preceded by the word joy and the symbol . (period) . For instance, to access the left field (which indicates whether the left control is pressed), it is necessary to use joy.left . left - This field will be at 1 when the joystick is orientated to the left , and at 0 in the opposite case. right - This field will be at 1 when the joystick is orientated to the right , and at 0 in the opposite case. up - This field will be at 1 when the joystick is orientated up , and at 0 in the opposite case. down - This field will be at 1 when the joystick is orientated down , and at 0 in the opposite case. For instance, to perform an action in a program when the joystick is moved to the right ( joy.right ), a statement like the following one must be included in the code: IF (joy.right) // Action to perform (statements) END For diagonal positions, the two fields comprising this diagonal must be verified. For instance, to perform an action when the joystick is in the upper right diagonal, the following statement will be used: IF (joy.up AND joy.right) // Action to perform (statements) END button1 , button2 , button3 and button4 - These fields indicate the state of up to four joystick's buttons, being at 1 when the respective button is pressed, and at 0 , when it is not. Some joysticks only have 2 buttons. In this case, they will be buttons number 0 and 1. In computers with two connected joysticks, the second joystick will have the buttons number 2 and 3. Note: When an analogical reading of the joystick is required (to know the exact coordinates at which the joystick is located), it will be necessary to use the get_joy_position() function. Obviously, this function will only be useful in an analogical joystick , and it won't work in the digital ones. ---See: Global data - get_joy_position() - get_joy_button()","title":"GLOBAL STRUCT joy"},{"location":"help/#global-struct-setup","text":"STRUCT setup; card; // Type of card port; // Access port irq; // Interruption request dma; // Direct memory access channel dma2; // 16 bit channel of access mixer; // Type of mixer rate; // Max frequency master; // Master (general) volume sound_fx; // Effects volume cd_audio; // CD audio volume END This is a very advanced data structure, which is not at all necessary to create a game, no matter how difficult it is, as DIV Games Studio's process manager will normally take charge of the sound hardware automatically. All the fields referred to the sound hardware are automatically updated by the program if you have a sound card, provided that the BLASTER or GRAVIS environment variable is properly initialised. This one record structure contains a series of fields divided into two groups: the first one, to activate new parameters of the sound hardware installed in the computer, and the second one to adjust the different volume controls managed by the sound system's mixer . Important: The reset_sound() function must be called to activate the new parameters of the sound hardware inserted in this structure (in the card , port , irq , dma and dma2 fields). The set_volume() function must be called to activate the new volume levels inserted in the structure (in the master , sound_fx and cd_audio fields). This structure is normally used inside the sound system setup programs (see setup_program ). Note: To access these fields, the field name must be preceded by the word setup and by the symbol . (period) . For instance, setup.master must be used to access the master field (which indicates the mixer's general volume level). A more detailed description of every field of this structure is now shown. card - Indicates the type of sound card installed in the computer. The program accepts cards of the Sound Blaster (tm) and Gravis Ultra Sound (tm) families, as well as all those 100% compatible with them. The values that this field can take are the following ones, depending on the sound card type: Without card or sound = 0 Sound Blaster 1.5 = 1 Sound Blaster 2.0 = 2 Sound Blaster Pro = 3 Sound Blaster 16 = 4 Sound Blaster AWE = 5 Gravis Ultra Sound = 6 Gravis Ultra Sound MAX = 7 port - Indicates the computer's communications port in which the data of the sound card must be written and read. The values that this field can take are the following ones, depending on the port assigned to the sound hardware: 0x210 = 0 0x220 = 1 0x230 = 2 0x240 = 3 0x250 = 4 0x260 = 5 irq - This field indicates the number of IRQ (Interrupt request) assigned to the active sound card. The values that this field can take are the following ones, depending on the IRQ used by the card: IRQ 2 = 0 IRQ 3 = 1 IRQ 5 = 2 IRQ 7 = 3 IRQ 10 = 4 IRQ 11 = 5 IRQ 12 = 6 IRQ 13 = 7 IRQ 14 = 8 IRQ 15 = 9 dma - The direct memory access (DMA) channel's number used by the sound card must be indicated in this field. This field can take values from 0 to 10, directly depending on the channel's number. dma2 - Some sound cards have a second direct memory access channel faster than the previous one, of 16 bits, commonly named HDMA, DMA2 or DMA16. Like in the previous field of this structure, this second channel can take values from 0 to 10 depending on the 16 bit channel's number used by the card. mixer - Type of mixer used by the sound system, can be one of these two constants: fast_mixer - Fast mixer with two sound channels (1). quality_mixer - Max quality mixer (2). By default, all programs will be initialised with the fast mixer setting activated ( setup.mixer=fast_mixer; ) because this is the faster mode. rate - Max permitted frequency (bit rate), a value between 11025 Hz (the min permitted quality of sound) and 44100 Hz (quality CD). By default, all programs are configured as 44100 ( setup.rate=44100; ), but it can be changed, because with the best quality, the sound system will be slower and will consume more processor time. The value specified in setup.rate is the max quality of sound, this means all loaded effects of sound will reconfigure to this quality if they have a better quality. This means, all effects saved to a frequency of 11025 will play with poor quality, although the max permitted frequency may be bigger. bits - Resolution of the digital effects samples and musical modules, this field can have one of these constants as its value : sound_bits_8 - 8 bit samples. sound_bits_16 - 16 bit samples. The effect is similar to the value specified in the field rate , the 8 bit sounds will sound worse (and occupy less space) than those of 16 bit quality. The value indicated in setup.bits indicates the max depth of the sample. By default, all programs activate 16 bit samples ({setup.bits=sound_bits_16;)), because the difference in quality is considerable. master - This field contains the output general or master volume of the card. A number ranging from 0 (minimum volume) and 15 (maximum volume) must be here indicated. By default, the value equals 15 , the maximum volume. Turning the master volume down will affect the sound effects' volume as well as the CD audio music reproduction's volume. sound_fx - This field controls the volume to which the sound effects executed with the sound() functions are reproduced. This volume is independent from that used with the sound functions. The former is general for all the sound effects. On the contrary, the latter (volume indicated in the functions) is specific for every sound. The values of this field also range from 0 (minimum volume) and 15 (maximum volume). By default, the value will be equal to the maximum volume. cd_audio - This field controls the volume of the music that will be reproduced from the audio tracks of a CD ROM or Compact Disc. Similar to the two previous fields, the values of this field can also rage from 0 (minimum volume) and 15 (maximum volume). By default, the value will be equal to the maximum volume. ---See: Global data - reset_sound() - set_volume()","title":"GLOBAL STRUCT setup"},{"location":"help/#global-timer","text":"timer[9]; // Counters of time---. This is a 10 position global table, from timer[0] to timer[9] , and each of these 10 positions is a counter of second hundredth that is automatically incremented. At the beginning of the program, these 10 counters will be put at zero. They are use to time within a program. For that purpose, they can be put at zero at any time. There are 10 counters so that the user can dedicate each of them to perform a different action inside the game, no matter which ones of the 10 counters are used. Normally, if the program only needs one counter (most of the times), that numbered 0 ( timer[0] ) is used, as the language allows us to omit the zero in square brackets in this case. If only one counter is needed, it is possible to use timer simply. For instance, to implement a process that 5 seconds after the beginning of its execution (if it had been called) performed a specific action, it would be constructed in a way similar to the following one (by using, for instance, the counter timer[9]): PROCESS process_example(); BEGIN timer[9]=0; // ... LOOP IF (timer[9]>=500) // Action to perform ... END // ... FRAME; END END Note 1: As timing is performed in second hundredths, these counters can be incremented in 1 hundredth, 2 , 3 , 4 , etc. in every frame of the game In an example like the previous one, the user can not wait for timer[9] to equal 500 exactly, as a frame could indicate 497 hundredths passed (since it was put at zero with timer[9]=0; ) and the following frame 502 hundredths, without having passed through value 500 . Note 2: It is also important to underline that much care must be taken to prevent several processes of the program from using the same counter for different purposes. If, for instance, a process_example() (like the previous one) was created, in every frame of the game these processes would never manage to execute the action of the five seconds, as each of them would put the counter timer[9] at 0 at the beginning of their execution, thus invalidating the timing of the previous processes. Keeping in mind that the counter timer[9] is GLOBAL , it is the same for all the game's processes, if a process puts it at 0 , it will be put at 0 for the rest of the processes. Note 3: Finally, much care must be taken regarding the conditions similar to those of the previous example ( IF (timer[9]>=500) ... ), as these conditions won't only be activated once every 5 seconds , but they will be activated always after the first 5 seconds . To understand the problem better, a process performing one action, only once , five seconds after the beginning of its execution, is now shown. PROCESS process_example(); PRIVATE action_performed=FALSE; BEGIN timer[9]=0; // ... LOOP IF (timer[9]>=500) AND NOT action_performed) // Action to perform ... action_performed=TRUE; END // ... FRAME; END END A private variable called action_performed which, at first, will be false is used. To perform an action now, it will be necessary that more than five seconds have passed and that the action has not been performed yet . Therefore, after its performance the action_performed variable will become true . For the previous example to execute the action every five seconds (indefinitely), suffice will be to put the statement timer[9]=0; again after the action to perform , not being necessary, in this case, the action_performed private variable, as other 5 seconds would be necessary for timer[9] to be again bigger than or equal to 500 . ---See: Global data","title":"GLOBAL timer[]"},{"location":"help/#global-text_z","text":"text_z=-256; // Texts' depth planes---. The depth plane in which the texts must appear on screen is indicated in this global variable. It indicates what must appear above and below the text. The depth planes can be any integer within the range ( min_int ... max_int ) and, the greater the number is, the deeper the text or graphic will be placed. By default, the processes' graphics have their local z variable at 0 , the texts text_z at -256 and the mouse pointer has mouse.z at -512 by default. That means that, by default, if these values are not modified, the texts will appear above the processes' graphics and the mouse pointer above the texts. If, for instance, the aim was that the texts appeared above the mouse pointer (opposite to which has been established by default), two things could have been done: a) To place the pointer's plane lower than the texts' plane (a greater number), such as, for instance: mouse.z=-200; (as -200 is a number bigger than -256 ). b) To place the texts' plane upper that the pointer's plane such as, for instance, text_z=-600; as -600 is a number lesser than -512 and, thus, a less depth plane (less deep). Note 1: The text_z variable is GLOBAL for all the texts. It is not possible to define texts in different depth planes. Note 2: The texts can only be displayed with the write() (alphanumeric texts) function or with the write_int() (variables' numeric values) function. ---See: Global data - write() - write_int()","title":"GLOBAL text_z"},{"location":"help/#global-fading","text":"fading=FALSE; // Indicator of screen fading---. This global variable indicates if a screen fading (a gradual change of the game's palette colours) is being performed at a specific moment. Its value will be: false (0) - If a fading is not being performed. true (1) - If a fading is being performed. The purpose of this variable is to be able to determine the end of a screen fading started with the fade() or fade_on() functions. On using these functions, a fading of the palette's colours will start, gradually coming closer to the definitive colours in the next frames of the game. In every FRAME statement a part of the fading will be performed. When a fading is started, the fading variable will automatically become equal to true (1) and when it is finished, it will recover its original value, false (0). Note 1: Generally, this variable is used to control the fade() function, and verify whether the fading has already been executed (performed). For instance, to stop the program's execution until the fading is finished, which can be done with a statement as follows (just after the call to the fade() function): WHILE (fading) FRAME; END Literally this statement defines: \" while the fading continues to be performed, a new frame must be displayed \". Note 2: All the programs perform a fading ( fade_on() ) at the beginning of their execution (automatically). Therefore, this variable will be put at true (1) at the beginning of all the programs until this initial fading doesn't finish (while the screen \" fading on \" is being performed). ---See: Global data - fade() - fade_on()","title":"GLOBAL fading"},{"location":"help/#global-shift_status","text":"shift_status=0; // State of the special keys---. The state of different special keys, such as [ ALT ], [ CONTROL ], etc. is indicated in this predefined global variable. Each of these keys have the following code assigned: Right SHIFT key = 1 Left SHIFT key = 2 CONTROL keys = 4 ALT and/or ALT GR keys = 8 SCROLL LOCK key = 16 NUM LOCK key = 32 CAPS LOCK key = 64 INSERT key = 128 The shift_status variable will contain the addition of all the codes of the pressed or activated keys . For instance, if the [ ALT ] key was pressed ant the [ CAPS LOCK ] was activated, the shift_status variable's value would equal 72 (8+64). In order to verify whether a key like [ ALT ] is pressed, it is not possible to check that shift_status is equal to 8 , as it would imply that [ ALT ] is the only pressed or activated special key. A correct verification would be carried out as follows: IF (shift_status AND 8 == 8) // The [ALT] key is pressed ... END Note: The key() function is normally used to verify whether a key is pressed. But it is not possible to determine with this same function whether keys such as CAPS LOCK are activated, but only if they are pressed or not. There are two variables containing the code of the last pressed key; scan_code ( scan code of the last pressed key) and ascii ( ascii code of the last pressed key). ---See: Global data - key() - ascii - scan_code","title":"GLOBAL shift_status"},{"location":"help/#global-ascii","text":"ascii=0; // ASCII code of the last pressed key---. This global variable always indicates the ASCII code of the last pressed key in the last game's frame. The ascii variable will be at 0 if no key has been pressed in the previous frame of the game. The ASCII codes are a list of characters (letters, numbers and symbols) numbered from 0 to 255 that have been standardised. The codes less than 32 are called control characters; from 32 to 127 appears the international set of characters; and from number 128, appears the expanded set of characters (according to the PC standard). The international and expanded ASCII characters are shown below. Summary of the standard PC ASCII codes. ---033 21 ! \u2502097 61 a \u2502161 A1 \u00ed \u2502225 E1 \u00df 034 22 \" \u2502098 62 b \u2502162 A2 \u00f3 \u2502226 E2 \u0393 035 23 # \u2502099 63 c \u2502163 A3 \u00fa \u2502227 E3 \u03c0 036 24 $ \u2502100 64 d \u2502164 A4 \u00f1 \u2502228 E4 \u03a3 037 25 % \u2502101 65 e \u2502165 A5 \u00d1 \u2502229 E5 \u03c3 038 26 & \u2502102 66 f \u2502166 A6 \u00aa \u2502230 E6 \u00b5 039 27 ' \u2502103 67 g \u2502167 A7 \u00ba \u2502231 E7 \u03c4 040 28 ( \u2502104 68 h \u2502168 A8 \u00bf \u2502232 E8 \u03a6 041 29 ) \u2502105 69 i \u2502169 A9 \u2310 \u2502233 E9 \u0398 042 2A \u2502106 6A j \u2502170 AA \u00ac \u2502234 EA \u03a9 * 043 2B + \u2502107 6B k \u2502171 AB \u00bd \u2502235 EB \u03b4 044 2C , \u2502108 6C l \u2502172 AC \u00bc \u2502236 EC \u221e 045 2D - \u2502109 6D m \u2502173 AD \u00a1 \u2502237 ED \u03c6 046 2E . \u2502110 6E n \u2502174 AE \u00ab \u2502238 EE \u03b5 047 2F / \u2502111 6F o \u2502175 AF \u00bb \u2502239 EF \u2229 048 30 0 \u2502112 70 p \u2502176 B0 \u2591 \u2502240 F0 \u2261 049 31 1 \u2502113 71 q \u2502177 B1 \u2592 \u2502241 F1 \u00b1 050 32 2 \u2502114 72 r \u2502178 B2 \u2593 \u2502242 F2 \u2265 051 33 3 \u2502115 73 s \u2502179 B3 \u2502 \u2502243 F3 \u2264 052 34 4 \u2502116 74 t \u2502180 B4 \u2524 \u2502244 F4 \u2320 053 35 5 \u2502117 75 u \u2502181 B5 \u2561 \u2502245 F5 \u2321 054 36 6 \u2502118 76 v \u2502182 B6 \u2562 \u2502246 F6 \u00f7 055 37 7 \u2502119 77 w \u2502183 B7 \u2556 \u2502247 F7 \u2248 056 38 8 \u2502120 78 x \u2502184 B8 \u2555 \u2502248 F8 \u00b0 057 39 9 \u2502121 79 y \u2502185 B9 \u2563 \u2502249 F9 \u2219 058 3A : \u2502122 7A z \u2502186 BA \u2551 \u2502250 FA \u2219 059 3B ; \u2502123 7B {{ }\u2502187 BB \u2557 \u2502251 FB \u221a 060 3C < \u2502124 7C | \u2502188 BC \u255d \u2502252 FC \u207f 061 3D = \u2502125 7D { }}\u2502189 BD \u255c \u2502253 FD \u00b2 062 3E > \u2502126 7E ~ \u2502190 BE \u255b \u2502254 FE \u25a0 063 3F ? \u2502127 7F \u007f \u2502191 BF \u2510 \u2502255 FF** ** 064 40 @ \u2502128 80 \u00c7 \u2502192 C0 \u2514 065 41 A \u2502129 81 \u00fc \u2502193 C1 \u2534 066 42 B \u2502130 82 \u00e9 \u2502194 C2 \u252c 067 43 C \u2502131 83 \u00e2 \u2502195 C3 \u251c 068 44 D \u2502132 84 \u00e4 \u2502196 C4 \u2500 069 45 E \u2502133 85 \u00e0 \u2502197 C5 \u253c 070 46 F \u2502134 86 \u00e5 \u2502198 C6 \u255e 071 47 G \u2502135 87 \u00e7 \u2502199 C7 \u255f 072 48 H \u2502136 88 \u00ea \u2502200 C8 \u255a 073 49 I \u2502137 89 \u00eb \u2502201 C9 \u2554 074 4A J \u2502138 8A \u00e8 \u2502202 CA \u2569 075 4B K \u2502139 8B \u00ef \u2502203 CB \u2566 076 4C L \u2502140 8C \u00ee \u2502204 CC \u2560 077 4D M \u2502141 8D \u00ec \u2502205 CD \u2550 078 4E N \u2502142 8E \u00c4 \u2502206 CE \u256c 079 4F O \u2502143 8F \u00c5 \u2502207 CF \u2567 080 50 P \u2502144 90 \u00c9 \u2502208 D0 \u2568 081 51 Q \u2502145 91 \u00e6 \u2502209 D1 \u2564 082 52 R \u2502146 92 \u00c6 \u2502210 D2 \u2565 083 53 S \u2502147 93 \u00f4 \u2502211 D3 \u2559 084 54 T \u2502148 94 \u00f6 \u2502212 D4 \u2558 085 55 U \u2502149 95 \u00f2 \u2502213 D5 \u2552 086 56 V \u2502150 96 \u00fb \u2502214 D6 \u2553 087 57 W \u2502151 97 \u00f9 \u2502215 D7 \u256b 088 58 X \u2502152 98 \u00ff \u2502216 D8 \u256a 089 59 Y \u2502153 99 \u00d6 \u2502217 D9 \u2518 090 5A Z \u2502154 9A \u00dc \u2502218 DA \u250c 091 5B [ \u2502155 9B \u00a2 \u2502219 DB \u2588 092 5C **\u2502156 9C \u00a3 \u2502220 DC \u2584** 093 5D ] \u2502157 9D \u00a5 \u2502221 DD \u258c 094 5E ^ \u2502158 9E \u20a7 \u2502222 DE \u2590 095 5F _ \u2502159 9F \u0192 \u2502223 DF \u2580 096 60 ' \u2502160 A0 \u00e1 \u2502224 E0 \u03b1 --- Therefore, an ASCII code is referred to the character that has been created with the last keystroke (or keystroke combinations, in those cases such as letters bearing a stress mark). Important: There is another predefined global variable, called scan_code , which also contains the code of the last pressed key. But, unlike ascii , this new variable stores the scan code of the key. This indicates which key has been pressed and not which character has been generated by it (like ascii ). There is a series of constants designating these keys codes (keytable scan codes). Access the help about these keys codes to observe, moreover, a sample program with the ascii and scan_code variables. The key() function of the language is normally used in order to verify whether a key is being pressed or not. This function receives one of these keys codes as a parameter, and returns 0 if the key is not pressed or 1 if it is pressed. ---See: Global data - scan_code - key()","title":"GLOBAL ascii"},{"location":"help/#global-scan_code","text":"scan_code=0; // Scan code of the last pressed key---. This global variable always indicates the scan code of the last pressed key in the last frame of the game. The scan_code variable will be at 0 if no key has been pressed in the previous frame of the game. This variable is often used to wait in a program for the user to press any key with a statement similar to the following one: WHILE (scan_code == 0) FRAME; END This statement indicates that, while no key has been pressed in the previous frame (while scan_code equals 0 ), the frames of the game must continue to be displayed. The scan codes are simply a numeric list of the PC's keys. These codes can slightly vary (in any key) regarding different keytables, as there are keytables of different languages, with a varied number of keys, etc. However, almost all the codes of the main keys remain constant. There is a predefined list of constants (synonymous for these codes) in the language that can be seen by accessing the help about keys codes (or keytable scan codes). These numeric values will precisely be assigned to the scan_code variable when the respective keys are pressed in the program. Important: There is another predefined global variable, called ascii , which also contains the code of the last pressed key. But, unlike scan_code , this new variable stores the ASCII code (character) generated by the key. This indicates which character has been generated by the last pressed key and not which key has been pressed (like scan_code ). Access the help about the keys codes to observe a sample program with the ascii and scan_code variables. The key() function of the language is normally used in order to verify whether a key is being pressed or not. This function receives one of these keys codes as a parameter, and returns 0 if the key is not pressed or 1 if it is pressed. ---See: Global data - ascii - key()","title":"GLOBAL scan_code"},{"location":"help/#global-joy_filter","text":"joy_filter=10; // Filter applied to the joystick---. This global variable is used to define the filter applied to the read joystick's coordinates. It is defined as a percentage from 0 % to 99 % . By default, joy_filter will equal 10 (a 10% filter will be applied). The purpose of applying this filter to the joystick's coordinates is to make its movements gentler and to avoid possible \" irregularities \" in the coordinates' reading. Those joystick's coordinates must be obtained with the get_joy_position() function. The joy_filter variable will only be useful when the latter function is being used. The bigger the filter applied to the joystick is, the gentler the movements of the latter will be. But, at the same time, its answer will take longer. As the task performed by this \" filter \" is somewhat difficult to understand, an example is now shown. Example program: PROGRAM example_joy_filter; BEGIN write(0, 0, 0, 0, \"joy_filter=\"); write_int(0, 70, 0, 0, offset joy_filter); write(0, 160, 180, 1, \"The graphic is shown at the joystick's coordinates\"); write(0, 160, 190, 1, \"Use the up/down keys to vary the filter\"); load_fpg(\"help/help.fpg\"); put_screen(0, 1); graph=100; LOOP IF (scan_code==_up AND joy_filter<99) joy_filter++; END IF (scan_code==_down AND joy_filter>0) joy_filter--; END x=get_joy_position(0); y=get_joy_position(1); FRAME; END END - This program displays the graphic of a ball at the coordinates returned by the main joystick with the get_joy_position() function. It can be notice how, for small values of joy_filter , many \" irregularities \" appear in the reading, and for very big values (like 95%) the coordinates' read is much gentler and regular, but slightly slower. Note: It is indispensable to have a joystick (or gamepad) connected to the computer for this variable to be useful. If the joystick is connected during the program's execution, the system won't detect it (it must be connected from the beginning). See the joy_status global variable. ---See: Global data - get_joy_position() - joy_status","title":"GLOBAL joy_filter"},{"location":"help/#global-joy_status","text":"joy_status=0; // State of the joystick--- The state of the joystick (or gamepad) connected to the computer is indicated in this global variable. These are the values that this variable takes by default: 0 - If the joystick reading system is disabled. This value means that a joystick connected to the computer either has not been found at the beginning of the program's execution, or has been disconnected. 1 - If the joystick reading system is active. This is the initial value by default, but if the joystick is disconnected (or there is no joystick connected), the reading system will be disabled (indicating 0 in the joy_status variable). If the system is disabled, it can be reactivated by simply assigning 1 to joy_status (with the joy_status=1; statement). But if, after a limited time, no joystick is detected, the system will be disabled again. There is a special mode in which the joystick reading system won't be ever disabled . This mode is simply defined by {assigning 2 to joy_status}. joy_status=2; // Activates special mode Nevertheless, much care must be taken as, if the joystick reading system is activated in this way, and there is no joystick connected to the computer, the game's execution may be slowed down . Note: To read the joystick in the programs, the global joy structure is normally accessed. This structure always indicates its offset and the state of its buttons (whether they are pressed or not). ---See: Global data - Joy structure - joy_filter","title":"GLOBAL joy_status"},{"location":"help/#global-restore_type","text":"restore_type=complete_restore; // Restoring type---. This global variable indicates the restoring type that must be performed after each frame on screen. The term background restoring means to recover the screen zones in which graphics have been painted or texts have been written in the previous frame. There are three applicable restoring types which directly correspond to three constants that can be assigned to the restore_type variable. no_restore - The fastest one, the background is not restored (-1) partial_restore - Average, partial restoring (0) complete_restore - The slowest one, complete restoring (1) By default, the value of restore_type equals complete_restore . If a different value is not indicated in this variable, a complete screen restoring will take place after each frame of the game. This restoring mode (complete) is the slowest one out of these three modes. Thus, it will surely be possible to gain speed in the game's execution (for it to be faster in slow computers), if a different value is assigned to this variable. For instance, the following statement must be used to indicate a partial restoring: restore_type=partial_restore; This statements orders the process' manager of DIV Games Studio to partially restore the screen background (only those screen zones where graphics or texts have been put) after the following frames of the game. The no_restore type (not restoring the screen background) is the fastest mode. However, it is only applicable when the game develops inside a scroll or mode 7 window occupying the entire screen. Otherwise, the graphics will leave signs (of the previous frames) on moving through the screen. The restoring mode can be changed under a program's execution as often as necessary, according to the requirements of the stages (or sections) under execution at each moment. Note: There is another global variable also related to DIV Games Studio's management on screen. This is called dump_type and it defines the type of frames dump that must be performed (what information must be sent to the monitor after every frame of the game). ---See: Global data - dump_type","title":"GLOBAL restore_type"},{"location":"help/#global-dump_type","text":"dump_type=complete_dump; // Type of dump--- This global variable indicates the frame dump on screen types that must be performed in every frame of the game. The term dump means that the game's frames are sent to the monitor (to the video memory of the graphic card). There are two applicable types of dump which directly correspond with two constants that can be assigned to the dump_type variable. partial_dump - When indicated with the following statement, partial dumps will be performed: dump_type=partial_dump; Only the graphics that are updated, that have changed with respect to the previous frame, will be dumped on screen in this mode. It is advisable to activate this dump in order to gain speed when a game (or one section of it) is programmed without a scroll or mode 7 window occupying the entire screen. complete_dump - When indicated with the following statement, complete dumps will be performed: dump_type=complete_dump; In this mode, the entire screen will be dumped no matter whether the graphics have changed or not. This mode is slower than the partial dump . Nevertheless, it must be used when the game has a scroll or mode 7 window occupying all the screen. By default, the value of dump_type is complete_dump . If no other value is indicated in this variable, complete dumps on the screen will be performed after each game's frame (which is normally slower than performing partial dump). The dump type can be changed during a program's execution as often as necessary, according to the requirements of the stages (or sections) under execution at each moment. Note: There is another global variable also related to DIV Games Studio's management on screen. This is called restore_type and it defines the type of restoring that must be performed on screen after every game's frame (which graphics or texts must be deleted). ---See: Global data - restore_type","title":"GLOBAL dump_type"},{"location":"help/#global-max_process_time","text":"max_process_time=500; // Maximum execution time---. Programs are provided with an anti-blocking system that will make the manager of processes of DIV Games Studio interrupts its execution when a process exceeds the maximum execution time in a game's frame. This maximum time is indicated in the max_process_time global variable in hundredths of second . By default, its value is 500 hundredths ( 5 seconds ). When a process takes longer than the indicated time in executing a FRAME statement (which indicates that the process is ready for the following frame of the game), an execution error will arise. Note: The utility of the possibility of changing this variable, assigning a new value to it, is to avoid this error in the programs in which there is a process that must be doing calculations for a long time. The following statement must be used to order the process' manager, for instance, not to interrupt a process, unless its execution in a frame is longer that 30 seconds: max_process_time=3000; As 30 seconds are 3000 hundredths of second. Important: Keep in mind that the time used by every computer to do the program's calculations is different. Therefore, this value must be defined with a certain margin, in order to avoid to exceed the maximum execution time when the game is executed in slower computers. ---See: Global data - FRAME statement","title":"GLOBAL max_process_time"},{"location":"help/#local-struct-reserved","text":"STRUCT reserved; process_id; // Identifier of the process id_scan; // Index of processes process_type; // Type of process type_scan; // Index of types status; // State of the process param_offset; // Offset of the parameters program_index; // Program counter is_executed; // executed process is_painted; // painted process distance_1; // Mode 7 reserved distance_2; // Mode 7 reserved frame_percent; // Percentage of frame box_x0, box_y0; // Beginning of the process' graphic box_x1, box_y1; // End of the process' graphic m8_object; // Object inside the world m8 old_ctype; // Old Ctype f_count; // Accumulating function counter caller_id; // Process or function caller stack_pointer; // Stack pointer for the process END In this structure, different variables of internal use (used by the manager of processes of DIV Games Studio ) are stored. They are local variables reserved for the system. It is not necessary to know these variables, as most of them are not useful to create programs. Important: The modification of the values of these variables will probably provoke crashing the computer, an incorrect working of the manager of processes or problems on using many of the internal functions. Therefore, no responsibility is assumed for the problems derived from an incorrect use of the reserved structure. A brief description of each of these fields is now shown, just for information. process_id - Identifying code of the process. This value is normally obtained with the reserved word ID and the value of this field must not be modified. id_scan - It is internally used for detecting collisions in order to save the identifying code of the last process that has collided with the current process. process_type - Type of the current process, normally obtained with the operator TYPE , later indicating the process name (see Types of processes ). type_scan - It is internally used to detect collisions or obtain identifying codes of processes of a specific type. status - Present state of the process. The values that this field can adopt are the following ones: 0 - non-existent process. 1 - process that has received a signal s_kill . 2 - alive or awake process (s_wakeup). 3 - asleep process (s_sleep). 4 - frozen process (s_freeze). param_offset - Offset of the computer's memory in which the parameters received by the process are located. program_index - Program's counter. Offset of the computer's memory in which the first statement that must execute the process in the next frame is located. is_executed - It indicates whether this process has already been executed in the current frame. is_painted - It indicates whether the graphic of the process has already been painted in the current frame of the game. distance_1 - Vertical distance of the process (reserved for processes displayed in a mode 7 window). distance_2 - Horizontal distance of the process (reserved for processes displayed in a mode 7 window). frame_percent - Percentage of the following frame completed by the process. This value will be useful when the FRAME statement is used indicating a percentage. Otherwise, it will simply be equal to 0 (0%) when the process has not been executed and 100 (100%) when it has already been executed. box_x0, box_y0 - Upper left coordinate of the graphic in the previous frame of the game (where the graphic was placed at screen coordinates). box_x1, box_y1 - Lower right coordinate of the graphic in the previous frame of the game. m8_object - number of object inside the mode 8, indicates an ordinal relative to the map of sectors. old_ctype - old value of the local variable ctype, is used to control changes in the coordinates of the process. f_count - accumulation counter of the function, to control the number of returns and level the battery for each process. caller_id - identification code of the process or function which invoked this. stack_pointer - pointer of local stack of each process, maintains the direction of the stack at the start of the process, with the stacked parameters ---See: Local data - Syntax","title":"LOCAL STRUCT reserved"},{"location":"help/#local-father","text":"father; // Identifying code of the father--- process. This is a predefined LOCAL variable, which means that each process will have its own value in its father variable. This variable always contains the identifying code of the process that created (called) the current process (the one that has this variable). Inside the language, father process is the name given to the process that calls another one. The process that has been called receives the name of son process. For further information, see the hierarchies of processes in the language. The DIV's manager of processes is the process named div_main . Its function is to create the main process of the program ( PROGRAM ) at the beginning of the game's execution. Therefore, it will be the father of the main program, as well as the father of all the processes that become orphan (processes whose father has been killed or finished before them, see states of a process ). Note: The identifying code of the son process is indicated in the predefined son local variable. ---See: Local data - Identifying code - Hierarchies of processes","title":"LOCAL father"},{"location":"help/#local-son","text":"son=0; // Identifying code of the son--- process. This is a predefined LOCAL variable, which means that each process will have its own value in its son variable. This variable always contains the identifying code of the last process created (called) by the current process. Inside the language, father process is the name given to the process that calls another one. On the other hand, son process is the name given to the process that has been called. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 until the process makes a call to another process. At this moment, the new process will be created indicating its identifying code in son . Note: The identifying code of the father process is indicated in the predefined father local variable. ---See: Local data - Identifying code - Hierarchies of processes","title":"LOCAL son"},{"location":"help/#local-smallbro","text":"smallbro=0; // Identifying code of the younger brother---. This is a predefined LOCAL variable, which means that each process will have its own value in its smallbro variable. This variable always contains the identifying code of the following process created by the father of the current process after it. Inside the language, younger brother is the name given to this process. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 until the father process makes a call to another process. At this moment, the new process (the younger brother of this one) will be created, indicating its identifying code in smallbro . Note: The identifying code of the elder brother is indicated in the predefined bigbro local variable. ---See: Local data - Identifying code - Hierarchies of processes","title":"LOCAL smallbro"},{"location":"help/#local-bigbro","text":"bigbro=0; // Identifying code of the elder brother---. This is a predefined LOCAL variable, which means that each process will have its own value in its bigbro variable. This variable always contains the identifying code of the process created by the father just before creating the current process after it. Inside the language, elder brother is the name given to this process. For further information, see the hierarchies of processes in the language. By default, this variable will be equal to 0 if the father process (the one that called the current one) has not created any other process before. If it has created one, or more than one, bigbro will indicate the identifying code of the last one. Note: The identifying code of the younger brother is indicated in the predefined smallbro local variable. ---See: Local data - Identifying code - Hierarchies of processes","title":"LOCAL bigbro"},{"location":"help/#local-priority","text":"priority=0; // Level of priority of the process---. This is a predefined LOCAL variable, which means that each process will have its own value in its priority variable. In the preparation of each frame, all the processes will be executed in the priority order established by the priority local variable. The higher the value of priority in a process is, the sooner it will be processed in each frame. The priority value may be established as any integer within the ( min_int ... max_int ) range. For instance, to establish the priority level of a process at 10 , the following statement must be used: priority=10; All the processes active in the program having the same level of priority will be executed in a undetermined order that, moreover, may vary from some executions of the game to others. By default, the priority local variable will be initialised at 0 in all the processes created in the program. Thus, it will be possible to execute them in any order, if the value of this variable is not defined. If the priority of a single process is fixed at a positive number, such as 1, it will be executed before the rest of the of the processes. On the other hand, if it is fixed at a negative number, such as -1, then it will be executed after the rest (supposing that the priority variable of the rest has not been modified, so its value is still equal to 0 ). When the processes priority must be established? --- When a process needs to use data of another process for its calculations, it is normally advisable to execute it after the latter, defining its lowest priority for the data of the second process to be updated when they are read. For instance, if process B must place its graphic 8 pixels lower than the graphic of process A , the priority of A must be greater than that of B , for the latter to be executed first. Thus, when process B obtains its y coordinate by adding 8 to the one of process A , this calculation is done with the y coordinate of process A already updated for the following frame (to ensure that in each frame, the y coordinate of process A first, and then that of process B will be established). For that purpose, suffice would be to define either the priority of A as 1 or the priority of B as -1 , since by default both priorities are at 0 . Note: The priority level of the process has nothing to do with the depth plane in which its graphic appears on screen, as this plane is indicated in the local z variable. ---See: Local data","title":"LOCAL priority"},{"location":"help/#local-ctype","text":"ctype=c_screen; // System of coordinates---. This is a predefined LOCAL variable, which means that each process will have its own value in its ctype variable. The system of coordinates used by the process is indicated in this variable. It is possible to use three different systems of coordinates, directly corresponding with three constants that can be assigned to the ctype variable. c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - Mode 8 coordinates By default, the ctype value is c_screen , used for the process' graphic coordinates to be interpreted as referred to the screen, where the upper left corner is (0, 0). With the following statement, c_scroll will be assigned to ctype : ctype=c_scroll; For the process' graphic coordinates to be interpreted as referred to a scroll window, with coordinates located above the foreground's graphic. With the following statement, c_m7 will be assigned to ctype : ctype=c_m7; For the process graphic coordinates to be interpreted as referred to a mode 7 window, with coordinates located above the main graphic, three-dimensionally folded in that window. c_m8 will be assigned to ctype with the following statement: ctype=c_m8; For the coordinates of the process graphic to be interpreted as referred a mode 8 window, with coordinates located above the main graphic, three-dimensionally folded in that window. Note: There is another local variable that also affects the way in which the process coordinates must be interpreted, This variable is resolution , which establishes the resolution (scale) in which the coordinates are defined. ---See: Local data - c_screen - c_scroll - c_m7 - c_m8","title":"LOCAL ctype"},{"location":"help/#local-x","text":"x=0; // Horizontal coordinate of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its x variable. The x and y local variables of the processes define where their graphic (defined in the graph local variable) must be placed. The x local variable defines the process' horizontal coordinate , which may be defined as an integer within the range ( min_int ... max_int ), putting the positive coordinates to the right and the negative ones, to the left. By default, these coordinates will be specified in pixels , referred to screen coordinates, where the upper left corner is the point placed at ( 0 , 0 ). Type of coordinates. --- There are several systems of coordinates that may be used by the processes and that are defined with the ctype local variable. The coordinates related to the screen are the system by default. Resolution of the coordinates. --- The resolution local variable indicates the precision of the process coordinates. By default, this variable will be equal to 0 and the ( x , y ) coordinates will be specified in pixels. The higher the value of resolution is, the smaller (and more precise) the drive in which the coordinates are interpreted will be. Some examples are now shown: resolution=1; - The coordinates are specified in pixels. resolution=10; - They are specified in tenths of pixels. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixel. ... Note: A different type and resolution of coordinates may be either defined for each process or changed while executing if necessary. Important: When a graphic is placed at some specific coordinates, it is the graphic centre that will normally be placed at these coordinates. This can be changed by defining in the graphic editor the control point number 0 of the graphic of the process (whose graphic code is indicated in the graph variable). If the control point has been defined, it will be placed at the specified coordinates. For instance, if control point number 0 is placed in the upper left corner of the graphic, and then, the graphic is put at the (100, 100) coordinates, the upper left corner of the graphic will be placed at these coordinates. ---See: Local data - ctype - resolution","title":"LOCAL x"},{"location":"help/#local-y","text":"y=0; // Vertical coordinate of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its y variable. The x and y local variables of the processes define where their graphic (defined in the graph local variable) must be placed. The y local variable defines the process' vertical coordinate , which may be defined as an integer within the range ( min_int ... max_int ), placing the positive coordinates downwards and the negative ones, upwards. By default, these coordinates will be specified in pixels , referred to screen coordinates, where the upper left corner is the point placed at ( 0 , 0 ). Type of coordinates. --- There are several systems of coordinates that may be used by the processes and that are defined with the ctype local variable. The system by default defines the coordinates related to the screen. Resolution of the coordinates. --- The resolution local variable indicates the precision of the process coordinates. By default, this variable will be equal to 0 and the ( x , y ) coordinates will be specified in pixels. The higher the value of resolution is, the smaller (and more precise) the drive in which the coordinates are interpreted will be. Some examples are now shown: resolution=1; - The coordinates are specified in pixels. resolution=10; - They are specified in tenths of pixels. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixels. ... Note: A different type and resolution of coordinates may be either defined for each process or changed while executing if necessary. Important: When a graphic is placed at some specific coordinates, it is the graphic centre that will normally be placed at these coordinates. This can be changed by defining in the graphic editor the control point number 0 of the graphic of the process (whose graphic code is indicated in the graph variable). If the control point has been defined, it will be placed at the specified coordinates. For instance, if control point number 0 is placed in the upper left corner of the graphic, and then, the graphic is put at the (100, 100) coordinates, the upper left corner of the graphic will be placed at these coordinates. ---See: Local data - ctype - resolution","title":"LOCAL y"},{"location":"help/#local-z","text":"z=0; // Depth plane of the process graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its z variable. The z local variable defines the depth plane in which the process graphic must be placed on screen (the graphic is defined in the graph local variable). Any integer within the range ( min_int ... max_int ) may be used as a depth plane. The greater the number is, the deeper the graphic will be placed. By default, the depth planes are arranged in the following way: ** (+) Greater depth** ** +512** - Scroll windows (see scroll[].z ) ** +256** - Mode 7 windows (see m7[].z ) ** 0 - Graphics of the processes (local z**) ** -256** - Texts (see text_z ) ** -512** - Mouse pointer (see mouse.z ) ** (-) Less depth** The z local variable that defines the depth plane of the processes' graphics will be initialised at 0 . The processes' graphics will be placed below the mouse pointer and texts, and above the scroll and mode 7 windows (if the values are not modified by default). All the objects (texts, graphics, windows, ...) placed in the same depth plane will appear on screen (on being superimposed) in an undetermined order , that may vary from some program's executions to some others. If the aim was, for instance, that the graphic of a process appeared above all the objects of the program, a depth plane could be fixed for it above the rest (as -1000}, with the following statement: z=-1000; At the beginning, all the processes have their z variable at 0 , then the graphic of the processes will appear in any order if the plane in which each of them must be placed is not defined. The depth plane of a process may be modified (by assigning a new value to its z variable) as often as necessary inside a program. The depth planes of the rest of the objects (windows, texts and mouse pointer) may also be modified at any stage of the program. Note 1: The processes that belong to a scroll window (having its variable ctype = c_scroll ) will be painted in the depth plane of the scroll window . Nevertheless, inside that window, all the graphics of the processes will appear in order, according to their depth plane . The process' depth plane (indicated as usual in the z variable) will be referred to the scroll window in which the process appears (see start_scroll() ). Note 2: The processes that belong to a mode 7 window (having its variable ctype = c_m7 ) will appear in that window in order, according to the depth order in the three-dimensional plane ignoring the value of their z local variable. The only sense of the z local variable in mode 7 processes is to define the order in which the processes exactly placed at the same coordinates of the folded plane must be superposed. If two processes are placed in the three-dimensional plane at the same coordinates, then it will be possible to define, through the z variable, which one must appear above the other (see start_mode7() ). ---See: Local data - mouse.z - scroll[].z - m7[].z - text_z","title":"LOCAL z"},{"location":"help/#local-graph","text":"graph=0; // Code of the process graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its graph variable. Normally, most of the processes correspond with a graphic object displayed on screen that will be placed at the indicated coordinates in the x and y local variables. It is necessary to define which graphic corresponds with this process by assigning a graphic code to the graph local variable. By default, this variable will be equal to 0 , which implies that no graphic will be displayed for this process. The graphics must first be created in the graphic editor of DIV Games Studio (with the option \" New... \" of the maps menu) and then, they can be saved in an file MAP (containing this graphic), or in a file FPG together with other graphics (it is possible to create a new file with the option \" New... \" of the files menu). The graphics used in a program may come from an file MAP (that contain just one graphic) or from a file FPG (that may contain many graphics). Note: The same graphic may be used in a program by many processes at the same time. files MAP or PCX --- In order to use a graphic from an file MAP in the program, it must be loaded by calling the load_map() or load_pcx() function, which will return the graphic code that must be assigned to the graph variable. A GLOBAL variable is normally used to save this graphic code and then, it is assigned to the graph variable. Example program: PROGRAM example_graph; GLOBAL graphic1; BEGIN graphic1=load_map(\"help/help.map\"); graph=graphic1; // The graphic of the process is defined. LOOP x=mouse.x; y=mouse.y; FRAME; END END - Even if in the previous example, the graphic1 global variable could have been omitted, having directly assigned the code returned by the load_map() function to the graph variable with the following statement: graph=load_map(\"help/help.map\"); the graphic code returned by this function are simply integers from 1000 . Files FPG --- In order to include a graphic that has been done in the graphic editor in a file FPG , it is necessary to drag the graphic window to the file window (click on the graphic, move to the file and release). Then, the program will ask for the graphic code , so an integer ranging from 1 and 999 must be included here. Thus, to use the graphic in a program, the file FPG that contains it must first be loaded with the load_fpg() function, assigning then the graphic code to the graph variable. An example is now shown. Before, it is necessary to know that a brown ball graphic was stored in the file HELP.FPG indicating the graphic 100 code . Example program: PROGRAM example_graph; BEGIN load_fpg(\"help/help.fpg\"); graph=100; // The graphic of the process is defined. LOOP x=mouse.x; y=mouse.y; FRAME; END END - Several files FPG can be loaded in a program. In this case, it will be necessary to indicate, besides the graphic code in the graph local variable, the file code returned by the load_fpg() function in the file local variable. It won't be necessary if only one file is loaded, as the file variable equals 0 by default in all the processes and 0 will always be the first file's code loaded in the program. There are more local variables related to the graphic of a process. The most important ones are mentioned below: graph - Graphic code file - File code x , y - Graphic coordinates z - Depth plane angle - graphic angle size - graphic size flags - Mirrors and transparencies region - Display window ---See: Local data","title":"LOCAL graph"},{"location":"help/#local-flags","text":"flags=0; // Indicator of mirrors and transparency---. This is a predefined LOCAL variable, which means that every process will have its own value in its flags variable. The flags local variable indicates the mirrors and transparencies of the displayed graphic in the processes. The possible values are the following ones: 0 -Normal graphic. 1 -Horizontal mirror. 2 -Vertical mirror. 3 -Horizontal and vertical mirror (180\u00b0). 4 -Transparent graphic. 5 -Transparent and horizontal mirror. 6 -Transparent and vertical mirror. 7 -Transparent, horizontal and vertical mirror. By default, the value of the flags variable is 0 . If it is not modified, the graphic will be displayed opaque (not transparent or mirror). The terms mirror and transparency are now defined: Horizontal mirror , the graphic will be horizontally flipped. If it was facing left, it will face now right and vice versa. Vertical mirror , the graphic will be vertically flipped. If it was facing up, it will face now down and vice versa. Transparency (or ghost-layering ), the graphic will be displayed semi-transparent. It will be possible to see what is placed behind the graphic, as if it was a coloured window, unlike the opaque graphics normally displayed. For instance, the following statement must be used to display a transparent graphic of a process: flags=4; Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data","title":"LOCAL flags"},{"location":"help/#local-size","text":"size=100; // Size (percentage) of the graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its size variable. The size local variable defines the size in which the graphic of the process must be seen. This size is a percentage related to its original size. By default, the value of this variable will be equal to 100 (100%) for all the processes, and when the graphic is modified, it will scale (reducing or expanding its size) to adjust to the new size. To double the size of the graphic displayed, it will be necessary to specify 200% . The following statement will be used for this purpose: size=200; Therefore, if this value is lesser than 100 , the graphic will be seen smaller; otherwise, it will be seen bigger. At first, there is no limit for the graphic size, but if the size local variable is put at 0 (0%), then the graphic of the process won't be seen. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data","title":"LOCAL size"},{"location":"help/#local-angle","text":"angle=0; // angle of the process' graphic---. This is a predefined LOCAL variable, which means that each process will have its own value in its angle variable. The angle local variable defines the angle in which the graphic of the process must be seen, indicating an angle with regard to the original graphic in degree thousandths (see Use of angles in the language ). By default, the value of this variable will be equal to 0 (0 degrees) for all the processes, but when the graphic is modified, it will rotate to adjust to the new angle. The angle may be defined as any integer within the range ( min_int ... max_int ). Some examples of the angles that define certain values in the angle local variable are now shown (keep in mind that the angles are expressed in degree thousandths ): ... ** -180000** - Angle to the left ** -90000** - Angle downwards ** -45000** - Angle of the diagonal down/right ** 0** - Angle to the right ** +45000** - Angle of the diagonal right/up ** +90000** - Angle upwards ** +180000** - Angle to the left ** +270000** - Angle downwards ... Important: When the aim is to rotate the graphic of a process, it is advisable to paint it orientated to the right , as it will be displayed like this by default (with the angle local variable equal to 0 ). Thus, when another angle is specified, the graphic will appear exactly orientated towards it. For instance, a graphic that has been drawn to the right can be seen orientated upwards (to the angle of 90 degrees) by indicating the following statement: angle=90000; // 90 degree thousandths (90 degrees). If a graphic was painted orientated towards another angle, (for instance, downwards), it would become orientated downwards by default, in the angle 0 , which can provoke confusions when it comes to orientating the graphic towards another angle. To make the graphic of a process advance its coordinates ( x , y ) towards its angle (the one specified angle in the local variable of the process) a specific distance, the advance() function can be used. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data - Use of angles in the language","title":"LOCAL angle"},{"location":"help/#local-region","text":"region=0; // Screen region assigned to the process---. This is a predefined LOCAL variable, which means that each process will have it own value in its region variable. The region local variable defines the zone of the screen in which the graphic of the process must be visible, indicating the number of region . A region is a rectangular zone of the screen, such as a window, associated to a number. By default, this variable will be equal to 0 in all the processes, making reference to region number 0 that is the entire screen . By default the graphics of the process will be visible in the whole screen (at any point of the screen in which they are placed). At the beginning, only region number 0 is defined. To define new screen regions, it is necessary to use the define_region() function. For instance, for the graphic of a process to be visible only inside a 100 by 100 pixel box placed in the upper left corner of the screen (at the coordinates 0, 0), first the new region should be defined in the following way, supposing that region number 1 is defined: define_region(1, 0, 0, 100, 100); and then, the number of region ( 1 ) should be assigned to the region local variable of the process with the following statement: region=1; The regions may be redefined at any moment inside a program. Note: The graphic of a process must be indicated assigning a graphic code to the graph local variable. ---See: Local data - define_region()","title":"LOCAL region"},{"location":"help/#local-file","text":"file=0; // File code of the process' graphic---. This is a predefined LOCAL variable, which means that every process will have its own value in its file variable. In the case that several graphics files files FPG have been loaded in a program, the file local variable indicates which file contains the graphic that the process is using. The graphic of a process must be indicated by assigning a graphic's code to the graph local variable. If just one file has been loaded in the program, it won't be necessary to assign any value to file , as the code of the first loaded file will equal 0 and this is the value of the variable by default. If the graphic has been loaded with the load_map() or load_pcx() function, it won't be necessary to assign any value to file either, as the graphics loaded with this function are used as if they belonged to file number 0 (to the first one that is loaded in the program). When more than a file is loaded, it is necessary to indicate in each process in which one its graphic is stored. It is done by assigning the file code returned by the load_fpg() function (on loading this file FPG ) to the file local variable. Note: Normally, if several files are sequentially loaded in a program, the first one will have the code 0 , the second, the code 1 , the third, the code 2 and so on. In general, if several files are used, it is a good practice to have the same number of global variables (named, for instance, file1 , file2 , ...) containing the code of each of the files, to use them in the processes when it comes to defining its file variable (the file FPG that must be used). The variables would be defined inside the section GLOBAL in the following way: GLOBAL file1; // First file's code file2; // Second file's code ... Next, these variables would be assigned the file codes on loading them with the load_fpg() function in the following way (supposing that the names of the files is name1.fpg , name2.fpg , etc.): file1=load_fpg(\"name1.fpg\"); // Files loading file2=load_fpg(\"name2.fpg\"); ... These files are generally loaded at the beginning of the program. Later, the used file would only have to be defined inside each process with the following statement (supposing that the process uses graphics stored in the file name1.fpg ): file=file1; // The first file is used Note: Keep in mind that defining the file local variable is futile, unless a graphic's code is assigned to the graph local variable. ---See: Local data","title":"LOCAL file"},{"location":"help/#local-xgraph","text":"xgraph=0; // OFFSET of the process' graphic table---. This is a predefined LOCAL variable, which means that each process will have its own value in its xgraph variable. This is an advanced level variable. Thus, its use requires certain experience. The xgraph local variable ( extended graphic ) allows us to use multiple graphics . This variable is used to define the graphic of a process as a graphics set among which it is necessary to see the most appropriate with the process' angle (specified in the angle local variable). If the xgraph variable is defined, the graph local variable which normally defines the graphic of the process will be ignored and one graphic or another will be used depending on the angle variable. Therefore, on changing the process' angle the graphic of the process won't appear rotated , but it will use this angle to select the process' graphic (inside the defined set). By default the xgraph variable will equal 0 in all the processes, which indicates that they are not going to use multiple graphics . The utility of the multiple graphics lies on the possibility of creating games in perspective , where the change of an angle in the process doesn't implied a rotation of its graphic, but the replacement of the graphic by another one painted in a different perspective (painted with another angle inside that perspective). How to use the multiple graphics. --- 1 - First, the different pictures that are going to represent the process' graphic have to be painted with different angles in perspective. The latter will be a finite number of graphic's views, such as 4 , 8 , 12 , etc., (or any other integer bigger than 1 ). Take into account that if 4 views are defined, a different view will be defined every 90 degrees, if 8 views are defined, every 45 degrees, etc. 2 - It is necessary to put these graphics in order according to their angles. First, the graphic corresponding with angle 0 (towards the right) and then, the rest in a clockwise direction. 3 - A table, generally GLOBAL , must be created and initialised with the following values: Number of graphic's views , Graphic's code for angle 0 (first view) , Code of the following angle (second view) , ... Note: This table must contain simple data (of type INT , 32-bit whole numbers with sign). The name given to this table makes no difference. For instance, if a multiple graphic is defined with 4 views, which must be the graphics with the codes 10, 11, 12, and 13, the definition of the table could be as follows: GLOBAL table_graphic1[]=4, 10, 11, 12, 13; .... 4 - Finally, the offset of this table must be assigned inside the computer's memory to the xgraph local variable of the process, which is done with the following statement (inside the process in question): xgraph=OFFSET table_graphic1; The OFFSET operator is used to obtain the offset of a program's variable in the memory. Once the multiple graphic has been defined, in each frame of the game the system will use the graphic corresponding with the angle closest to the process' angle (the one indicated in its angle variable). The xgraph variable must be put at 0 again in order to disable the multiple graphic system in a process, Important: If any graphic's code is put with a negative sign inside the table that defines the set of graphics, then this graphic will appear horizontally flipped . If the graphic was facing right, it will appear facing left, and vice versa. Note: The multiple graphic system is normally used in mode 7 windows , as in the folded three-dimensional plane the graphics must be seen in a different way, according to the angle from which they are observed. For further information about this technique, see the start_mode7() function used to activate a mode 7 window in the program. ---See: Local data","title":"LOCAL xgraph"},{"location":"help/#local-height","text":"height=0; // Graphic's height (in mode 7)---. This is a predefined LOCAL variable, which means that each process will have its own value in its height variable. The local height variable is exclusively used in the processes that belong to mode 7 windows . That is to say, processes that have their coordinates' system inside a three-dimensional window (its local variable ctype = c_m7 ). It is used to define the height at which the graphics of the processes must be placed above the three-dimensional plane. The local z variable is not used for this purpose, as it is used to define the depth plane of the graphics (even if it is now useful only for processes placed at the same coordinates). The height of the process can be defined as any integer within the ( min_int ... max_int ) range, even if positive numbers are normally used, as the height of the bottom is 0 and processes are placed above it. By default, the value of the height variable is 0 for all the processes, which means that if another value is not specified, the graphics of the processes will appear just above the bottom of the mode 7 (above the plane three-dimensionally folded). The graphic's base will first be placed in the indicated height of the process, unless control point number 0 is defined. In this case, this point will be placed in that height. Note: For further information about the mode 7 windows and how to place graphics inside these windows, see the help about the start_mode7() function, which is used to activate them in the program. This variable can be used for any other purpose in the non mode 7 processes, as the system will completely ignore it. ---See: Local data - start_mode7()","title":"LOCAL height"},{"location":"help/#local-cnumber","text":"cnumber=0; // Number of scroll or mode 7 windows---. This is a predefined LOCAL variable, which means that each process will have its own value in its cnumber variable. The local cnumber variable is exclusively used when, in a game, several scroll windows or several mode 7 windows simultaneously appear on screen. For further information about the scroll windows , see the help about the start_scroll() function, which is used to activate them in the program. For further information about the mode 7 windows , see the help about the start_mode7() function, which is used to activate them in the program. The cnumber utility lies on indicating in which of these windows the graphic of the process must be seen . Obviously, this variable must be defined only in processes visible inside the scroll windows or the mode 7 windows . This variable is useless for the rest of the processes (screen processes or processes with no graphics). If the process must be seen in all the windows , then it won't be necessary to modify this variable, as the value of cnumber ( 0 ) by default precisely indicates so. Up to 10 windows of both types may be activated, numbered from 0 to 9 . There are ten predefined constants used to define the value of cnumber . These are c_0, c_1, c_2, ..., c_9 and directly correspond with the 10 possible windows of these types. cnumber must be assigned the addition of the constants corresponding with the windows in which the process must be visible . For instance, if there are 4 scroll windows numbered 0 , 1 , 2 and 3 in a program, and the aim is to define that a specific process must be only visible in windows 0 and 2 , the following statement must be used: cnumber=c_0+c_2; The value of cnumber can be changed during the process execution if necessary. Note: Keep in mind that for the graphic of the process to be seen in all the windows, it is not necessary to do anything, as it is the option by default. ---See: Local data - c_0...c_9","title":"LOCAL cnumber"},{"location":"help/#local-resolution","text":"resolution=0; // Resolution of the process coordinates---. This is a predefined LOCAL variable, which means that each process will have its own value in its resolution variable. Normally, the coordinates of a process (indicated in the x and y local variables) are defined in screen pixels. The resolution local variable must be used when the aim is to define the coordinates in drives smaller than the pixel. That is to say, this variable indicates the precision of the process' coordinates. By default, the variable will equal 0 and the coordinates will be specified in pixels. The greater the value of resolution is, the smaller (and more accurate) the drive in which the coordinates are interpreted will be. Some examples are show below: resolution=1; - The coordinates are specified in pixels (similar to resolution=0 , which is the value by default). resolution=10; - They are specified in tenths of a pixel. resolution=100; - They are specified in hundredths of pixels. resolution=2; - They are specified in half pixels. ... For instance, a process located at 160 , 100 with resolution equal to 0 (or 1 ), will be in the same position as a process located at 1600 , 1000 and with resolution equal to 10 . The value of resolution is normally defined as a positive integer multiple of 10 (10, 100, 1000, ...). In short, when the value of resolution is defined, the processes' manager of DIV Games Studio will divide the coordinates of the processes between resolution when it comes to painting their graphics on screen. Important: Much care must be taken when, in a program, there are several processes with different resolutions of coordinates, as some functions, such as get_dist() (used to obtain the distance between two processes), will return incorrect results when two processes using different resolution of coordinates are accessed. It is normally advisable that all the processes active in the game, at least all that interact (that are detected, modified or that can be collide) use the same resolution. ---See: Local data","title":"LOCAL resolution"},{"location":"help/#control-points","text":"The control points are defined inside the graphic editor with the bar of control points, indicated with this icon. - - --- In order to access the graphic editor , suffice will be to \" double-click \" with the left mouse button on a graphic inside the environment (on a map window). The control points are simply points that can be placed inside a graphic for different purposes. The bar of control points allows us to position up to 1000 different points inside a graphic. Each of them will be identified by its number (from 0 to 999 ). In order to position one of these points, suffice will be to select the {number of point} with the left arrow and right arrow icons and then, to click on the graphic. In order to delete (unselect) a control point, it is necessary to click on the same graphic a second time. The only control point used by the system is control point number 0 (the first one). This point defines which is the virtual centre of the graphic and has many applications inside the language. When control point number 0 is not defined, the system will work as if the graphic's virtual centre was its real centre (a point located at half the width and height of the graphic). Note: Once the control points have been defined, for them to have effect in a program, it is necessary to save the file MAP or include the graphic again in the file FPG by dragging the former to the latter (depending on which one of both is loaded in the program).","title":"Control points."},{"location":"help/#videomodes","text":"","title":"Videomodes"},{"location":"help/#constants-m320x200-m1024x768","text":"These constants are used to indicate the videomode in the set_mode() function. The whole list of constants is the following one: m320x200 m320x240 m320x400 m360x240 m360x360 m376x282 m640x400 m640x480 m800x600 m1024x768 Each constant indicates the videomode in the following way: first, the letter m and then, the horizontal and vertical resolution of the mode, separated by an x . The values defined for these constants are the following ones. m320x200 = 320200 m320x240 = 320240 m320x400 = 320400 m360x240 = 360240 m360x360 = 360360 m376x282 = 376282 m640x400 = 640400 m640x480 = 640480 m800x600 = 800600 m1024x768 = 1024768 Note: Besides these standard video modes, the global structure video_modes contains a list of all modes compatible with the VESA standard situated in the system's video adaptador. ---See: Constants - set_mode() - video_modes","title":"Constants: m320x200 ... m1024x768"},{"location":"help/#true","text":"","title":"true"},{"location":"help/#constant-true","text":"This constant is used to indicate true values, to initialise logical variables or to define logical parameters. That is to say, it must be evaluated as a condition. Its value is 1 and, as in the language all the odd numbers are interpreted as true , this constant will be evaluated as a condition that is always complied ( true ). The false constant is opposite to this one, and it is used to indicate logical false values. ---See: Constants - false","title":"Constant: true"},{"location":"help/#false","text":"","title":"false"},{"location":"help/#constant-false","text":"This constant is used to indicate false values, to initialise logical variables or to define logical parameters. That is to say, it must be evaluated as a condition. Its value is 0 and, as in the language all the even numbers are interpreted as false , this constant will be evaluated as a condition that is never complied ( false ). The true constant is opposite to this one, and it is used to indicate logical true values. ---See: Constants - true","title":"Constant: false"},{"location":"help/#s_kill","text":"","title":"s_kill"},{"location":"help/#constant-s_kill","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 0 . This signal transmits the imperative order kill to the processes. It is used to eliminate processes in the program (to make certain objects of the game disappear). That is to say, on sending a signal s_kill to a process, the latter will be eliminated and will not appear any longer in the following frames of the game. The constant s_kill_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will eliminate the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_kill_tree","title":"Constant: s_kill"},{"location":"help/#s_wakeup","text":"","title":"s_wakeup"},{"location":"help/#constant-s_wakeup","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 1 . This signal transmits the imperative order wakeup to the processes. It is used to restore the processes that have been made dormant (with the signal s_sleep ), or frozen (with the signal s_freeze ) to their normal state. That is to say, on sending a signal s_wakeup to a process, the latter will be reactivated in the following frames of the game (it will be seen and processed again). The constant s_wakeup_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will wake up the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_wakeup_tree","title":"Constant: s_wakeup"},{"location":"help/#s_sleep","text":"","title":"s_sleep"},{"location":"help/#constant-s_sleep","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 2 . This signal transmits the imperative order sleep to the processes. It is used to make a process dormant. An asleep process will not appear in the following frames of the game, but it won't be eliminated, as it happens with the signal s_kill . Indeed, this kind of process may wake up at any moment with a signal s_wakeup . That is to say, on sending a signal **s_sleep ** to a process, the latter will not appear in the following frames of the game (until it is awaken or eliminated). The constant s_sleep_tree is directly linked to this constant, with the proviso that, on sending this signal, the former will make dormant the indicated process and its sons , which are the processes created by it. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_sleep_tree","title":"Constant: s_sleep"},{"location":"help/#s_freeze","text":"","title":"s_freeze"},{"location":"help/#constant-s_freeze","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 3 . This signal transmits the imperative order freeze to the processes. It is used to freeze (immobilise) a process. A frozen process will continue to appear in the following frames of the game, but it won't be processed, so it will remain immobile. This process can be reactivated at any moment if a signal s_wakeup is sent to it. That is to say, on sending a signal s_freeze to a process, the latter will stop processing (stop interpreting its statements) in the following frames of the game (until it is activated or eliminated with s_kill ). The constant s_freeze_tree is directly linked to this constant, with the proviso that, on sending this signal, the indicated process as well as its sons (which are the processes created by it) will be frozen. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_freeze_tree","title":"Constant: s_freeze"},{"location":"help/#s_kill_tree","text":"","title":"s_kill_tree"},{"location":"help/#constant-s_kill_tree","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 100 . This signal is used to eliminate a process and all the process created by it, by sending the imperative order kill to them. This is a version of the signal s_kill , which eliminates a process, but not the processes that it had created. That is to say, the signal s_kill_tree will eliminate the process and all its descendants. Thus, none of them will appear any longer in the following frames of the game. The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_kill","title":"Constant: s_kill_tree"},{"location":"help/#s_wakeup_tree","text":"","title":"s_wakeup_tree"},{"location":"help/#constant-s_wakeup_tree","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 101 . This signal is used to wake up a process and all the processes created by it, by sending the imperative order wakeup to them. This is a version of the signal s_wakeup , which wakes a process up, but not the processes that it had created. That is to say, the signal s_wakeup_tree will wake up the process and all its descendants. Thus, all these processes will return to their normal state in the following frames of the game. Processes that have been made dormant with the signal s_sleep_tree or frozen with the signal s_freeze_tree can be woken up (reactivated). The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_wakeup","title":"Constant: s_wakeup_tree"},{"location":"help/#s_sleep_tree","text":"","title":"s_sleep_tree"},{"location":"help/#constant-s_sleep_tree","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 102 . This signal is used to make a process and all the processes created by it dormant , by sending the imperative order sleep to them. This is a version of the signal s_sleep , which makes a process dormant, but not the processes that it had created. That is to say, the signal s_sleep_tree will make the process and all its descendants dormant. Thus, all these processes will disappear in the following frames of the game (but they won't be eliminated). These asleep processes can be woken up (reactivated) with the signal s_wakeup_tree . The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_sleep","title":"Constant: s_sleep_tree"},{"location":"help/#s_freeze_tree","text":"","title":"s_freeze_tree"},{"location":"help/#constant-s_freeze_tree","text":"This constant is used as a parameter of the signal() function (to send signals to the processes). Its value is 103 . This signal is used to freeze (immobilise) a process and all the processes created by it, by sending the imperative order freeze to them. This is a version of the signal s_freeze , which freezes a process, but not the processes that it had created. That is to say, the signal s_freeze_tree will freeze the process and all its descendants. Thus, all these processes will stop processing in the following frames of the game (they will remain immobile, as they won't execute their statements). These frozen processes can be unfrozen (reactivated) with the signal s_wakeup_tree . . The whole list of the constants used as signals that can be sent to the different processes of a program is the following one: s_kill s_wakeup s_sleep s_freeze s_kill_tree s_wakeup_tree s_sleep_tree s_freeze_tree ---See: Constants - signal() - s_freeze","title":"Constant: s_freeze_tree"},{"location":"help/#all_text","text":"","title":"all_text"},{"location":"help/#constant-all_text","text":"This constant is used as a parameter of the delete_text() function, to delete all the texts displayed in the program with the write() and write_int() functions. That is to say, the following statement must be executed in order to make disappear all the texts displayed on screen: delete_text(all_text); The value assigned to this constant is 0 . ---See: Constants - delete_text()","title":"Constant: all_text"},{"location":"help/#all_sound","text":"","title":"all_sound"},{"location":"help/#constant-all_sound","text":"This constant is used as a parameter of the stop_sound() function, to stop all the sound effects previously activated with the sound() function. That is to say, the following statement must be executed in order to stop all the sound channels, active at a specific moment: stop_sound(all_sound); The value assigned to this constant is -1 . ---See: Constants - stop_sound() - sound()","title":"Constant: all_sound"},{"location":"help/#g_wide","text":"","title":"g_wide"},{"location":"help/#constant-g_wide","text":"This constant is used as a parameter of the graphic_info() function, to ask for information about the width (in pixels) of a specific graphic. Its value is 0 . The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info()","title":"Constant: g_wide"},{"location":"help/#g_height","text":"","title":"g_height"},{"location":"help/#constant-g_height","text":"This constant is used as a parameter of the graphic_info() function, to ask for information about the height ** (in pixels) of a specific graphic. Its value is 1**. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info()","title":"Constant: g_height"},{"location":"help/#g_x_centre","text":"","title":"g_x_centre"},{"location":"help/#constant-g_x_centre","text":"This constant is used as a parameter of the graphic_info() function, to ask for information about the horizontal centre of a specific graphic. Its value is 2 . The horizontal centre of a graphic will be half the width (in pixels), if control point number 0 (graphic centre) has not been defined in the painting tool. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info()","title":"Constant: g_x_centre"},{"location":"help/#g_y_centre","text":"","title":"g_y_centre"},{"location":"help/#constant-g_y_centre","text":"This constant is used as a parameter of the graphic_info() function, to ask for information about the vertical centre of a specific graphic. Its value is 3 . The vertical centre of a graphic will be half the height (in pixels), if the control point number 0 (graphic centre) has not been defined in the painting tool. The constants that can be used as parameter of this function are the following ones: g_wide g_height g_x_centre g_y_centre ---See: Constants - graphic_info()","title":"Constant: g_y_centre"},{"location":"help/#c_screen","text":"","title":"c_screen"},{"location":"help/#constant-c_screen","text":"This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 0 . This is the value by default of ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to the screen. The (0,0) coordinate is the upper left corner. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype","title":"Constant: c_screen"},{"location":"help/#c_scroll","text":"","title":"c_scroll"},{"location":"help/#constant-c_scroll","text":"This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 1 . This is the value assigned to ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to a scroll window, to coordinates with respect to the foreground's graphic. For further information about the scroll windows , it is possible to access the start_scroll() function used to activate them. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype - start_scroll()","title":"Constant: c_scroll"},{"location":"help/#c_m7","text":"","title":"c_m7"},{"location":"help/#constant-c_m7","text":"This constant is used to be assigned to the predefined ctype local variable used to define the type of coordinates that a process will have. Its value is 2 . This is the value assigned to ctype , used for the coordinates of the graphic of the process to be interpreted as if they were referred to a mode 7 window, three-dimensionally folded in that window. For further information about the mode 7 windows , it is possible to access the start_mode7() function used to activate them. There are other constants used for other systems of coordinates. The whole list is the following one: c_screen - Screen coordinates c_scroll - Scroll coordinates c_m7 - Mode 7 coordinates c_m8 - coordinates of mode 8 ---See: Constants - ctype - start_mode7()","title":"Constant: c_m7"},{"location":"help/#partial_dump","text":"","title":"partial_dump"},{"location":"help/#constant-partial_dump","text":"This constant is used to be assigned to the predefined dump_type global variable used to define the type of dump that will be performed on screen. Its value is 0 . The following statement is used: dump_type=partial_dump; This statement indicates to the manager of processes of DIV Games that the following dumps must be partial . Dump is the name given to the system of sending the game frames to the monitor (to the video memory of the graphics card). There are two types of dumps: Partial : Only the graphics that are updated and that have varied with regard to the previous frame will be dumped on screen. It is advisable to activate this dump in order to gain speed when programming a game (or a section of it) without a scroll or mode 7 window occupying the whole screen. That is to say, either when the game shows graphics movements against a fixed background or when the active scroll or mode 7 windows are smaller that the screen. Complete : All the screen will be dumped, irrespective of whether the graphics have changed or not. This is the dump by default and it is slower that the partial dump . However, the complete dump must be used when the game has a scroll or mode 7 window occupying the whole screen. The other constant used to designate the type of dump is complete_dump which, unlike this one, defines a complete dump. ---See: Constants - dump_type - complete_dump","title":"Constant: partial_dump"},{"location":"help/#complete_dump","text":"","title":"complete_dump"},{"location":"help/#constant-complete_dump","text":"This constant is used to be assigned to the predefined dump_type global variable used to define the type of dump that will be performed on screen. Its value is 1 . This is the value by default of the dump_type variable. To establish this value, it is necessary to use the following statement: dump_type=complete_dump; This statement indicates that the following dumps must be complete to the manager of processes of DIV Games. Dump is the name given to the system of sending the game frames to the monitor (to the video memory of the graphics card). There are two types of dumps: Partial : Only the graphics that are updated and that have varied with regard to the previous frame will be dumped on screen. It is advisable to activate this dump in order to gain speed when programming a game (or a section of it) without a scroll or mode 7 window occupying the whole screen. That is to say, either when the game shows graphics movements on a fixed background or when the active scroll or mode 7 windows are smaller that the screen. Complete : All the screen will be dumped, irrespective of whether the graphics have changed or not. This is the dump by default and it is slower that the partial dump . However, the complete dump must be used when the game has a scroll or mode 7 window occupying the whole screen. The other constant used to designate the type of dump is partial_dump which, unlike this one, defines a partial dump. ---See: Constants - dump_type - partial_dump","title":"Constant: complete_dump"},{"location":"help/#no_restore","text":"","title":"no_restore"},{"location":"help/#constant-no_restore","text":"This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is -1 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. The following statement must be used to establish this value: restore_type=no_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game frames {it is not necessary to restore the screen background}. If the background is not restored, speed will be gained in the execution of the game (that will go faster in slow computers). But this mode of restoration ( no_restore ) can only be applied in games or in their sections in which there is a scroll or mode 7 window occupying the whole screen . The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type","title":"Constant: no_restore"},{"location":"help/#partial_restore","text":"","title":"partial_restore"},{"location":"help/#constant-partial_restore","text":"This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is 0 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. The following statement must be used to establish this value: restore_type=partial_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game frames only the screen areas in which graphics have been painted or texts have been written must be restored . This mode of restoration ( partial_restore ) is faster than a complete restoration (option by default), but it must only be applied in games, or in their sections, in which there ISN'T a scroll or mode 7 window occupying the whole screen . The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type","title":"Constant: partial_restore"},{"location":"help/#complete_restore","text":"","title":"complete_restore"},{"location":"help/#constant-complete_restore","text":"This constant is used to be assigned to the predefined restore_type global variable used to define the type of restoration that must be applied to the screen background after each game frame. Its value is 1 . The name background restoration deals with the operation of restoring the screen areas in which graphics have been painted or texts have been written in the previous frame. That is to say, to delete both the painted graphics and the written texts. This is the value by default of the restore_type variable and, it is the slowest mode of the three available restoration modes. The following statement must be used to establish this value: restore_type=complete_restore; This statement indicates to the manager of processes of DIV Games Studio that, after the following game's frames the screen background must completely be restored . This mode of restoration ( complete_restore ) is the slowest one (and it is the option by default). Therefore, it can be changed by another one in order to gain speed in the execution of the game (so it will go faster in slow computers). As a matter of fact, this mode of restoration is only interesting for games (or for their sections) that DON'T have a scroll or mode 7 window occupying the whole screen, but that have a great number of graphics moving through the screen. The three types of restoration that can be applied correspond with the following three constants: no_restore - The fastest; it doesn't restore the background partial_restore - Average, partial restorations complete_restore - The slowest one, complete restoration ---See: Constants - restore_type","title":"Constant: complete_restore"},{"location":"help/#numbers-of-window","text":"","title":"Numbers of window"},{"location":"help/#constants-c_0-c_9","text":"These constants are used to be assigned to the predefined cnumber local variable that is used to define the scroll or mode 7 windows in which the graphic of a process must appear. This will only be necessary when several scroll or mode 7 windows have been activated, and it ISN'T aimed to display the graphic of the process in all of them. Up to 10 windows of these types may be defined, numbered from 0 to 9 , and that directly correspond with the constants c_0 , c_1 , c_2 ... c_9 . For the graphic of a process to appear in one of these windows only, the corresponding constant must be assigned to its cnumber local variable. For instance, if the aim was for the graphic of a process to appear only in (scroll or mode 7) window number 3, the following statement would be included in its code: cnumber=c_3; If the aim for the graphic of a process is to appear in several of these windows, then the constants must be added. For instance, for a process to appear in the windows 0, 4, and 5, the following assignment will be performed: cnumber=c_0+c_4+c_5; For the graphic to appear in all the windows, suffice will be to assign 0 to the cnumber variable. It won't be necessary if this variable has not been modified, as it is its value by default. The values equivalent to these constants correspond with the following powers of 2: c_0 = 1 scroll / mode-7 number 0 c_1 = 2 scroll / mode-7 number 1 c_2 = 4 scroll / mode-7 number 2 c_3 = 8 scroll / mode-7 number 3 c_4 = 16 scroll / mode-7 number 4 c_5 = 32 scroll / mode-7 number 5 c_6 = 64 scroll / mode-7 number 6 c_7 = 128 scroll / mode-7 number 7 c_8 = 256 scroll / mode-7 number 8 c_9 = 512 scroll / mode-7 number 9 ---See: Constants - cnumber .","title":"Constants: c_0 ... c_9"},{"location":"help/#key-codes","text":"","title":"Key codes"},{"location":"help/#constants-key-codes","text":"These constants are normally used as a parameter of the key() function, to indicate which key is the one that the user wishes to know whether it is pressed. It can also be used to compare the scan_code global variable, that contains the code of the last key that has been pressed, with these values. The character _ (underlining) followed by the name of the key, is normally used to designate each constant. For instance, for the [ A ] key, the constant referred to its code will be _a . The whole list of these constants, with their respective values, is as follows (according to the standard arrangement of the keytable): _esc = 1 [ESC] or escape _f1 = 59 [F1] or function 1 _f2 = 60 [F2] or function 2 _f3 = 61 [F3] or function 3 _f4 = 62 [F4] or function 4 _f5 = 63 [F5] or function 5 _f6 = 64 [F6] or function 6 _f7 = 65 [F7] or function 7 _f8 = 66 [F8] or function 8 _f9 = 67 [F9] or function 9 _f10 = 68 [F10] or function 10 _f11 = 87 [F11] or function 11 _f12 = 88 [F12] or function 12 (DEBUGGER) _prn_scr = 55 [PRINT SCREEN] _scroll_lock = 70 [SCROLL LOCK] _wave = 41 [\u00ba] or [\u00aa] key _1 = 2 Number \"1\" key _2 = 3 Number \"2\" key _3 = 4 Number \"3\" key _4 = 5 Number \"4\" key _5 = 6 Number \"5\" key _6 = 7 Number \"6\" key _7 = 8 Number \"7\" key _8 = 9 Number \"8\" key _9 = 10 Number \"9\" key _0 = 11 Number \"0\" key _minus = 12 Symbol \"?\" key _plus = 13 Symbol \"\u00bf\" key _backspace = 14 Delete ( <- ) key _tab = 15 Tabulator [TAB] key _q = 16 Letter \"Q\" key _w = 17 Letter \"W\" key _e = 18 Letter \"E\" key _r = 19 Letter \"R\" key _t = 20 Letter \"T\" key _y = 21 Letter \"Y\" key _u = 22 Letter \"U\" key _i = 23 Letter \"I\" key _o = 24 Letter \"O\" key _p = 25 Letter \"P\" key _l_brachet = 26 Key [^] or ['] _r_brachet = 27 Key [*] or [+] _enter = 28 [ENTER] (Enter or Return) _caps_lock = 58 [CAPS LOCK] or capitals lock _a = 30 Letter \"A\" key _s = 31 Letter \"S\" key _d = 32 Letter \"D\" key _f = 33 Letter \"F\" key _g = 34 Letter \"G\" key _h = 35 Letter \"H\" key _j = 36 Letter \"J\" key _k = 37 Letter \"K\" key _l = 38 Letter \"L\" key _semicolon = 39 Letter \"\u00d1\" key _apostrophe = 40 [ { ] key _backslash = 43 [{}}] key _l_shift = 42 [SHIFT] or left capitals _z = 44 Letter \"Z\" key _x = 45 Letter \"X\" key _c = 46 Letter \"C\" key _v = 47 Letter \"V\" key _b = 48 Letter \"B\" key _n = 49 Letter \"N\" key _m = 50 Letter \"M\" key _comma = 51 Key [;] or [,] key _point = 51 [:] or [.] key _slash = 51 [_] or [-] key _r_shift = 54 [SHIFT] or right capitals _control = 29 [CONTROL] keys _alt = 56 [ALT] or [ALT GR] keys _space = 57 [SPACE] or spacebar _ins = 82 [INSERT] _home = 71 [HOME] _pgup = 73 [PGUP] or page up _del = 83 [DEL] or delete _end = 79 [END] _pgdn = 81 [PGDN] or page down _up = 72 Up cursor _down = 80 Down cursor _left = 75 Left cursor _right = 77 Right cursor _num_lock = 69 [NUM LOCK] or numeric lock _c_backslash = 53 Symbol [/] of the numeric keytable _c_asterisk = 55 Symbol [*] of the numeric keytable _c_minus = 74 Symbol [-] of the numeric keytable _c_home = 71 [HOME] of the numeric keytable _c_up = 72 Up cursor of the numeric keytable _c_pgup = 73 [PGUP] of the numeric keytable _c_left = 75 Left cursor of the numeric keytable _c_centre = 76 [5] key of the numeric keytable _c_right = 77 Right cursor of the numeric keytable _c_end = 79 [END] of the numeric keytable _c_down = 80 Down cursor of the numeric keytable _c_pgdn = 81 [PG DN] of the numeric keytable _c_ins = 82 [INS] of the numeric keytable _c_del = 83 [DEL] of the numeric keytable _c_plus = 78 Symbol [+] of the numeric keytable _c_enter = 28 [ENTER] of the numeric keytable It is indifferent to use these constants or the numeric values that they represent. That is to say, it is possible to call the key() function, to verify whether the [ A ] key is pressed, such as key(_a) or key(30) (in the previous list, it is possible to verify that 30 is the numeric value of the constant _a ). Important: Some of these codes can vary in certain keytables. In case of doubt it is possible to execute the following sample program, that shows a table on screen, corresponding to the key() function (indicating the codes of the keys that are pressed at any moment), besides the values of the scan_code , ascii and shift_status variables (also related to the reading of the keytable). Example program: PROGRAM example_codes_of_the_keytable; GLOBAL keys[128]; BEGIN write(0, 0, 0, 0, \"Codes of the pressed keys, according to key()\"); FROM x=0 TO 127; write_int(0, (x%16) 20, (x/16) 10+20, 0, OFFSET keys[x]); END write(0, 0, 160, 0, \"Code of the last key pressed (scan_code):\"); write_int(0, 320, 160, 2, OFFSET scan_code); write(0, 0, 180, 0, \"Code ASCII of the last key (ascii):\"); write_int(0, 320, 180, 2, OFFSET ascii); write(0, 0, 190, 0, \"State of the special keys (shift_status):\"); write_int(0, 320, 190, 2, OFFSET shift_status); LOOP FROM x=1 TO 127; IF (key(x)) keys[x]=x; ELSE keys[x]=0; END END FRAME; END END - This program may be used (by clicking on the text \" Example program: \" with the mouse and then, by pressing the [ F10 ] key) to find out the code that any specific key has. This numeric code can later be used as a parameter of the key() function, to verify in the game whether this key is pressed at a specific moment. ---See: Constants - key() - scan_code - ascii - shift_status","title":"Constants: Key codes"},{"location":"help/#min_int","text":"","title":"min_int"},{"location":"help/#constant-min_int","text":"This constant defines the minimum value that any variable can store in this language. This value is -2147483648 . All the data are 32 bit integers with sign in this language. For that reason, only integers within the range ( -2147483648 ... +2147483647 ) may be used. When the result of an arithmetic operation exceeds that range, the system won't report any error. In order to avoid this situation, much care must be taken. ---See: Constants - max_int","title":"Constant: min_int"},{"location":"help/#max_int","text":"","title":"max_int"},{"location":"help/#constant-max_int","text":"This constant defines the maximum value that any variable can store in this language. This value is 2147483647 . All the data are 32 bit integers with sign in this language. For that reason, only integers within the range ( -2147483648 ... +2147483647 ) may be used. When the result of an arithmetic operation exceeds that range, the system won't report any error. In order to avoid this situation, much care must be taken. ---See: Constants - min_int","title":"Constant: max_int"},{"location":"help/#pi","text":"","title":"pi"},{"location":"help/#constant-pi","text":"This constant defines the equivalence in degree thousandths of the mathematical constant pi (approximately 3.14159265 radians). Its value is 180000 degree thousandths (180 degrees), equivalent to pi radians . It is normally used to define angles. For instance, 180 degrees could be defined as pi , -90 degrees as -pi/2 , 45 degrees as pi/4 , etc. ---See: Constants - Use of angles in the language","title":"Constant: pi"},{"location":"help/#predefined-global-data","text":"Each of the predefined global data are now described. STRUCT dirinfo - List of files in a directory STRUCT fileinfo - Information about the file STRUCT joy - Parameters of the joystick STRUCT m7[9] - Control of the mode 7 windows STRUCT m8[9] - Control of the mode 8 windows STRUCT mouse - Parameters of the mouse STRUCT net - Parameters of the net hardware STRUCT scroll[9] - Control of the scroll windows STRUCT setup - Control of the sound card STRUCT video_modes[31] - Modes of video disposed argc - Number of arguments argv[] - Arguments of the program ascii - Reading of keytable ASCII codes {#1416,channel[31] - Sound Channels draw_z - Depth plane of the drawing dump_type - Dump type of the screen fading - Fading indicator of the screen fps - Number of frames per second joy_filter - Filter applied to the joystick joy_state - State of the joystick max_process_time - Max time of execution of the process num_video_modes - Number of detected video modes restore_type - Restore type of the screen scan_code - Reading of codes of the key-board shift_state - State of the special keys text_z - Depth plane of the texts timer[9] - time counter unit_size - Size of the unity of reading/writing vsync - vertical synchronisation ---See: Constants - Local data - Syntax","title":"Predefined global data"},{"location":"help/#predefined-local-data","text":"Each of the predefined local data are now described. STRUCT reserved - Internal parameters of the processes father - Identifier of the process' father son - Identifier of the process' son smallbro - Identifier of the process' younger brother bigbro - Identifier of the process' elder brother priority - Priority of the process' execution ctype - Type of coordinates used by the process x - Horizontal coordinate of the process y - Vertical coordinate of the process z - Depth plane of the process' graphic graph - Code of the graphic assigned to the process flags - Indicators of mirror and transparency size - Size of the process' graphic angle - angle of the process' graphic region - Screen region assigned to the process file - File code of the process' graphic xgraph - OFFSET of the graphic table of the process height - Height of the process in mode 7 windows cnumber - Numbers of scroll or mode 7 windows resolution - Resolution of the process' coordinates m8_nextsector - Sector where the process is going next m8_sector - Number of sector the process is in m8_step - Height which the process can rise m8_wall - Wall number of map of sectors opposite with which you collided radius - Radius of the mode 8 processes ---See: Constants - Global data - Syntax","title":"Predefined local data"},{"location":"help/#constants-predefined","text":"Each of the predefined constants are now described. m320x200 .. m1024x768 - Videomodes true - True value false - False values s_kill - Signal to kill processes s_wakeup - Signal to wake processes up s_sleep - Signal to make processes dormant s_freeze - Signal to freeze processes s_kill_tree - Signal to kill processes and sons s_wakeup_tree - Signal to wake processes and sons up s_sleep_tree - Signal to make processes and sons dormant s_freeze_tree - Signal to freeze processes and sons all_text - Indicator of all the texts all_sound - Indicator of all the sounds g_wide - Indicator of width g_height - Indicator of height g_x_centre - Indicator of horizontal centre g_y_centre - Indicator of vertical centre c_screen - Screen coordinates c_scroll - Scroll window coordinates c_m7 - Mode7 window coordinates partial_dump - Partial background dump complete_dump - Complete background dump no_restore - Disabled screen restoration partial_restore - Partial screen restoration complete_restore - Complete screen restoration c_0 .. c_9 - Indicators of windows min_int - Minimum value of data max_int - Maximum values of data pi - Mathematical value of pi Key codes - Keytable codes _case_sensitive - Distinguish capital and small letters _extended_conditions - Extended conditions _free_syntax - Free syntax _hidden - Hidden file _ignore_errors - Ignore all errors _max_process - Max number of processes _no_check - Do not check execution errors _no_id_check - Do not check the identifiers _no_null_check - Do not check accesses to NULL _no_optimization - Do not optimise the codes _no_range_check - Do not check the rank _no_strfix - Do not enlarge the text strings _normal - file normal _simple_conditions - Simple conditions _subdir - Subdirectory _system - system file _volid - Volume etiquette all_drawing - Indicator of all drawings seek_cur - Current position of the file seek_end - Final position of the file seek_set - Beginning of file ---See: Global data - Local data - Syntax","title":"Constants predefined"},{"location":"help/#program-debugger","text":"See: Index - Help about the menus system --- The programs debugger is an advanced tool, whose use first requires a correct understanding of all the programming concepts explained from chapter number 5 of the DIV Games Studio's book (User's Handbook). The debugger is a dialog box that can be activated in programs' run time for one of the following reasons: The program was entered with the option programs \\ debug program . The F12 key was pressed in a program's run time. An error of execution arose in the program. A debug statement was found in the executed program. This tool allows us to execute the program statement by statement, verifying the value taken by the different program's data when necessary. It is useful because, on checking the program's execution step by step, it can find the mistakes eventually made by the programs. As it is a dialog with a great deal of information, each of its sections are now described separately. - Upper information line Two messages are reported in the upper part of the window. To the left, there is one indicating the number of processes active in the program out of the total that can be created . For instance, if it reports 23/3201, it means that there are 23 processes active in the program and that up to 3201 could be created before using up the available memory for processes. The maximum number of processes vary from some programs to others, depending on the number of their local and private variables. The identifying code of the process selected in the list, as well as its current state (normal, killed, asleep or frozen) are indicated to the right. List of active processes This list appears in the upper left part of the debugger with a scrolling bar to its right. All the active processes in the program are shown in it. By active processes we mean the processes that have been created and that still have not been disappear. The following information appears for each process: The process name in the program. Its identifying code in brackets (occasionally, there is no space to put it entirely). A letter indicating its state ( A -Normal, K -killed, S -Asleep and F -Frozen). The percentage of accomplished execution for the following frame. The scrolling bar must be used to move through the processes' list. Important : One of the processes appears with a white tip arrow pointing out its name. This is the process that is being executed in the program currently. Therefore, the next statement of the program will belong to this process. One of the processes appears tagged with a black band. This is the process about which information is shown in the right part of the window (close to this list of processes). This process may be selected with the mouse, by clicking on the list. It is very important to distinguish between the process in execution and the process about which the information is shown, as they don't have to necessarily be equal. For the information about the process in execution to be shown, it is necessary to select it (that of the white arrow) by clicking on the list with the left mouse button. Information box about the indicated process To the right of the previous list, information about the program tagged with a black band in the list (not the process in execution) is shown. Its identifying code and its state was shown in the uppermost line. The complete process name is shown in a dark background's box. Below it there is another box with the graphic of this process (when it is bigger, it will be reduced to fit this box). The button See data appears to the right of the graphic. This button allows us to access another dialog box in which all the data of the process must be consulted and modified. It will be later explained in the section Inspecting data . The ( x , y ) coordinates of the process, the system of coordinates used by it (referred to the screen , to a scroll or to a mode 7 ) and the mirrors or transparencies applied to the graphic of the process are always shown following this button.. Finally, four buttons allow us to access the father process (the process that called the one is selected), the son process (last process called by the selected one), the younger brother ( smallbro , the last one called by the father before it) and the elder brother ( bigbro , the following one called by the father after it). If these buttons don't lead to any other process, that is because there is no process with that relationship. Partial execution controls Two buttons called Exec.Process and Next FRAME below the previous information box allow us to execute the program partially. Execution of the process . This first button allows the program to continue just to the end of the process currently under execution (the one pointed with the white arrow in the list). All its statements will be executed until it reaches the next FRAME (until the process is ready for the next frame of the game). Next FRAME . The second button will execute the program to its next frame, first executing all the pending processes and displaying the next frame of the game (in the debugger's background). The debugger will stop in the first statement of the first process to be executed in the new frame. It is possible to displace the dialog box with the debugger (by dragging its title bar) in order to contemplate the result of the previous frame of the game. Debugging box of the program's listing The code of the program is shown in the lower part of the debugger. The identifying code of the process under execution (again, the one pointed with the white arrow in the list) appears in the left upper corner. Below it, there are three buttons and, to its right, the code window. In the code window , another white arrow indicates the line including the next statement to be executed by the process. It can be notice how the statement also appears highlighted in white from the rest of the code. This window's contents can be displaced with the cursors keys. The program's lines can be tagged with a black band. Nevertheless, it is not possible to modify the program from the debugger. Indeed, to modify the program it is necessary to finish its execution (which can be done by pressing ALT+X ) and return to the editor of the environment. The first button called Process allows us to go in the code window to one of the processes of the program directly. A list containing all the processes found in the program will appear, being necessary to select the desired process with the mouse. However, it won't change the process currently under execution, which will continue to be the same. The second button allows us to establish a Breakpoint in the program. For that, it is first necessary to tag the line of the listing with the black band. On reaching this line (with the cursors), the program must stop. Then, this button must be activated, appearing the line in red. Breakpoints can not be established in all the lines of the program, but only in those for which the executable code has been generated (in which any action is performed). Many breakpoints can be established in the program. To execute the program until it reaches one of these points, suffice will be to close the debugger or press the ESC key. To disable a breakpoint, it is necessary to select the line and click on the same button again. The last button, Debug , is the one that really allows us to debug the program statement by statement. Every time it is clicked on, one of the program's statements will be executed. When a process finishes its execution, or completes a frame, you will pass to the first statement to be executed of the next process. Inspecting data By clicking on the button See data of the programs' debugger it is possible to access this other dialog box, in which the values of the program's data can be consulted (and even modified) in the point in which it has stopped, normally with the aim of carrying out tests in it. Most of this box is occupied by the data list. Each of them are shown with their name and numeric value. This list always appears in alphabetical order. The data set appearing in this list can be selected through a series of switches. The two upper switches define the two following sets. Predefined . When this switch is activated, all the data predefined in the language will be included in the list. Thus, it will be possible to access the predefined local data (such as x, y, angle, size, ...), the predefined global data and the predefined constants. Defined by the user . This switch selects all the new data defined in the program. These are the specific constants, variables, tables and structures of every program. Besides selecting the data depending on whether they are predefined or new, they can be selected according to the sphere in which they have been declared, with the following switches. CONST . This switch is used to include the constants in the list, even if the constants are not data, but synonymous of a numeric value. Therefore, they can not be modified. GLOBAL . On activating this switch, all the global data (accessible by all the processes) will be included in the list. LOCAL . When this switch is activated, the local data (the data that all the processes of the program have) will be included in the list. PRIVATE . This switch selects the specific data of the process tagged in the debugger window to include them in the list. These data exclusively are for the program's internal use. The list of data can be displaced with the vertical scrolling bar or with the cursors and Pg.Up / Pg.Dn keys. The button Change allows us to modify the value of the selected data; only the constants can not be modified. A new dialog will appear with a text box in which the new value of the variable must be input. Any variable of the list can be selected with the cursors or clicking on it. Below this button, there are other two buttons with the symbols - and + . They are used to modify the index of tables and structures , which can also be done with the right cursor and left cursor keys. The table or structure whose index is intended to change must previously be selected in the list. This is the way to observe or modify any element of a table or structure Finally, a series of buttons appears in the lower part of this dialog. These buttons, mentioned below, allow us to display the value of a variable in a specific way: Angle . This button allow us to display the variable as an angle. The angles are specified internally (in the programs) in degree thousandths. The value of the variable will be displayed as an angle in degrees and radians. Process . If the variable is the identifying code of a process, on selecting this display filter, the name of this process will appear in the list as a value of the variable. Text . When the variable is a text or a pointer oriented to a text (to a literal of the program), that text will be displayed in the list by clicking on this button. Logical . If a variable contains a logical value, on applying this filter to it, in the upper list will be shown whether it is false or true . In the language, on evaluating them as logical conditions, the odd numbers are considered true, and the even numbers are considered false. Once the display filter of a variable has been established, it will remain during the rest of the program's execution. The same button must be double-clicked to display again the contents of the variable as a numeric value. -","title":"Program debugger"},{"location":"help/#commands-in-the-graphic-environment","text":"Commands in the graphic environment ALT+X - To exit from the graphic environment to the operative system. ESC+Control - To exit the environment and programs directly. ALT+S - To execute a session of the MS-DOS operative system. ESC - To cancel a dialog box. TAB - To chose the selected control of a window or box. Enter - To activate the selected control. F1 - To invoke the help window. F2 - To save the selected program. F4 - To open a program. F10 - To save and execute the selected program. F11 - To compile the selected program. F12 - To save and debug the selected program. Control+ALT+P - To save a snapshot of the graphic environment (DIV_*.PCX)","title":"Commands in the graphic environment"},{"location":"help/#common-commands-in-the-games","text":"Common commands in the games ALT+X - To exit the game. ESC+Control - To exit the game. Control+ALT+P - To save a snapshot of the game (SNAP*.PCX) F12 - To invoke the programs' debugger. Pause - To stop the game immediately.","title":"Common commands in the games"},{"location":"help/#commands-in-the-programs-debugger","text":"Commands in the programs' debugger Cursors. - Shift through the listing. Pg.Up. - Previous page. Pg.Dn. - Following page. F4 - Execute until the selected line is reached. F5 - To see the listing of a process. F6 - To execute the current process. F7 - To see or edit data. F8 - To debug a statement. F9 - To set a breaking point. F10 - Execute the following statement or call a process. F11 - To see the timing profiles of the program. F12 - To invoke the debugger / To advance frames. F - To execute to the following frame. TAB - To select a button. Enter - To activate a button. ESC - To exit the debugger.","title":"Commands in the programs' debugger"},{"location":"help/#commands-in-the-programs-editor","text":"Commands in the programs' editor Generic commands. F5 - To go to the beginning of a program's process. Control+Z - To zoom the selected program's window. Basic movement and edit commands. Cursors - Basic movement of the cursor. Home - To go to the beginning of the line. End - To go to the end of the line. Pgdn - Following page. Pgup - Previous page. Insert - To toggle between insert and overwrite. Delete - To delete the cursor character. Clear - To delete the character previous to the cursor. TAB - To go to the following tabulation. Shift+TAB - Distabulate. Control+Delete, Control+Y - To delete the current line. Control+Right - Following word. Control+Left - Previous word. Control+Pgup - To go to the beginning of the program. Control+Pgdn - To go to the end of the program. Control+Home - To go to the beginning of the page. Control+End - To go to the end of the page. Search and replacement commands. ALT+F, Control+F - To search for a text. ALT+N, F3, Control+L - To repeat search. ALT+R, Control+R - To replace a text. Blocks commands of type Q EDIT. ALT+A - To tag the beginning or the end of a permanent block. ALT+U - To untag the permanent block. ALT+C - To copy the block to the current position. ALT+M - To move the block to the current position. ALT+D, ALT+G - To delete the block. Blocks commands of type EDIT. Shift+Movement keys - To tag the volatile block (Movement keys: Cursors, Control + Right, Control + Left, Pg.Up, Pg.Dn, Home, End ). Shift+Insert - To paste block. Control+Insert - To copy block. Shift+Delete - To cut block. Control+X - To cut block. Control+C - To copy block. Control+V - To paste block. Delete - To delete block.","title":"Commands in the programs' editor"},{"location":"help/#commands-in-the-graphic-editor","text":"Commands in the graphic editor Generic commands. F1 - To invoke the help window. ESC - To exit the graphic editor. Cursors, OP/QA - Movement of the cursor. Space bar - Equivalent to clicking with the left mouse button. Shift+Movement - 8 by 8 pixels movement. Shift+Left button - To take the colour from the screen. W, S - To choose colour within the current range. Shift+W, S - To choose current range. Control+Cursors - To choose colour and range. Backspace - To undo. Shift+Delete - To repeat action (redo). 0 - To select the transparent colour. B - To highlight the transparent colour. C - colours window. M - Mask window. T - Select a paintbrush. U - Select a texture. X - visualise a texture. Z - To change the zoom percentage. Commands of selecting tool. F2 - Pen, for hand drawing. F3 - Straight lines. F4 - Multi line, stringed lines. F5 - Curves b\u00e9zier. F6 - Multi curve, stringed curves. F7 - Rectangles and boxes. F8 - Circles and circumferences. F9 - Paint spray. F10 - Filling of surfaces. F11 - Blocks edit. F12 - Undo and redo actions. Shift+F1 - To write texts. Shift+F2 - To position control points. Shift+F3 - Dotting bar. Specific commands. Control - To move selection (bar: to select a block). D - To stump (bars: pen, lines, curves and spray). H - To hide the cursor (bar: offset block). K - Copy window (bar: select block). ** +, -** - To vary the strength (bar: multi curve). ** +, -** - Change the checkpoint (bar: checkpoints).","title":"Commands in the graphic editor"},{"location":"help/#common-help-questions-about-div","text":"Where can I find information about DIV? The DIV Games Studio Environment has its own dedicated web site WWW.DIV-ARENA.COM , from here you can download upgrades and utility packages, get technical support, review / submit Games designs and chat to other DIV users about cool new games, hints on obtaining the best from DIV etc.. in fact talk about whatever you wish. How can I obtain help about ... ? All options accessible from options menus are described exclusively in the user manual for DIV Games Studio 2. How can I resolve a configuration problem ? For sound problems, incomplete installations, etc., see the chapter resolution of problems of this electronic help. What improvements have been made for this version? They are divided in two groups: the new language capabilities (explained in this help ), and the new environment (explained in the user's manual ). Why did I get the error message \"Can't recognise the file type\"? It is possible that you are attempting to load a file with an incorrect menu, which means, the palette menu serves only to load palettes, the files menu only loads graphics files (groups of graphics), the programs menu loads programs or text files, etc. You may also be attempting to load a PCX or BMP Map in true colour, this version of DIV can work only with 256 colour graphics, so these types of files are impossible to import. The graphics which you want to load into DIV must first be converted into 256 colours with another application. How can I stretch a graphic? To stretch a graphic you must press the left mouse button in the map window, not on the bar with its name, but on the proper graphic contained in the window. Then move the mouse to the position in which you want leave the graphic and let go of the left mouse button (you can stretch maps in files, to the trash, to the background, in other maps or in the fonts generator). How can I drag a graphic contained in another graphic out? You must select the part of the graphic which you want to drag out from the section blocks. The new section could be represented as a rectangle, painting contours, etc. - Once the selection has been extracted many new icons will appear on the toolbar, including the icon cut the window . After pressing on this the desktop creates a new map window and inserts the selected zone into it. - How can I cut and copy the graphics? See also the last question. To cut and move graphics you must access the toolbar , inside the picture window, selecting the icon which shows cutters. From the desktop some operations can be achieved, such as copying one graphic into another, this can be made by dragging the first one into the second. Also a copy of a graphic can be created if you drag it to the background (area of the desktop which doesn't contain any windows). What must I do if the system becomes unstable? DIV Games Studio is a very complex program and, although it is stable in its execution, it is possible that a module makes an error after completing a determined action, or crashes the PC. If this happens, to return the system to its original state, you must load DIV from the MSDOS prompt indicating the parameter /SAFE (introducing the command D.EXE /SAFE from the directory where the program was installed), to enter DIV in \"debug mode\". What must I do to learn the programming language ? The basic concepts are not explained in this help file, but in the user's manual for DIV Games Studio 2, in the chapters 4, 5 & 6. Also you can learn a lot from the Examples of the language functions (See the list of functions in the language help) and the tutorials, which are simple mini-games designed to simplify the learning of the language (you can find these tutorials in the directory PRG/TUTOR of DIV Games Studio 2). How are the graphics loaded into the games? In a game the graphics contained in the map (MAP or PCX files) can be used, loading them using the functions load_map() or load_pcx , or placing some graphics in FPG file of several graphics and then loading them with the function load_fpg() , this last option has an advantage because many graphics can be loaded at the same time in the game. Often the graphics are assigned to the variable LOCAL graph of the processes of the game. How to show a new graphic in the game? To create a new graphic or \"sprite\" in a game, first a new process ( PROCESS ) must be created with the commands which will manage its conduct in the game, then every time you want to create a process of this type, you must call the process (See how to make a call to a process ). How to undo a process? To undo or \"kill\" a process of the game, you can execute a RETURN statement from itself or, to kill a process from another process, send a signal s_kill (See the function signal() , which is used for this). Which are the functions that manage the mouse? The mouse is not controlled by any function, but by the global structure mouse , you can access the help file about language / global data to see the other structures which control other important aspects of the games. Where are all DIV files loading from ? When the function load_fpg( ... ) is called in a program the internal manager of DIV attempts to locate this file following this method (supposing that it intends to load the file \"DIR/file.EXT\"): First it checks where the executable (EXE) of the game is, or in the main directory of DIV (where D.EXE is) in case the game will be executed from this environment. Then the program attempts to open the file from the directory specified in the function (\"DIR/file.EXT\"). If the program has still failed to open the file, it will attempt to load the file inside a directory which has the same extension as the one specified, such as \"EXT/DIR/file.EXT\". If this is still not found, the program will try to load the file without a specific path, meaning \"file.EXT\". Finally, if the file was not found in any of those directories, the program will attempt to find the file in the directory whose name coincides with the extension of the file, ignoring the path passed to the function, such as \"EXT/file.EXT\".","title":"Common help/ questions about DIV"},{"location":"help/#help-about-the-calculator","text":"How it functions? The calculator included in the environment functions differently from conventional calculators, it is made for programmers, and therefore functions as an evaluator of expressions. Its use is very simple, you write the mathematical expression and press the Enter key. Pressing F1 will always take you to this help page. For example, you can type in the calculator the expression 2+2 and press Enter ; the value 4 will appear in the results window. To introduce a new expression the previous one must first be rubbed out, this can be done by pressing the ESC key. It is possible to introduce complex expressions, using parentheses ( ) to indicate the priorities in the calculations. The operators which can be used in the calculator expressions are the following (indicates all symbols accepted in each operator): ** + -** Addition and Subtraction. ** * /** Multiplication and division. ** % MOD** Modulus, or remainder from whole division. ** < <<** Binary rotation to the left. ** > >>** Rotation to the right. ** ^ ^^ XOR** OR exclusive binary. ** | || OR** OR binary. ** & && AND** AND binary. ** ! NoT** Binary negation. ** SQRT** Square root. The calculator has two cells which can change their {mode of functioning}. Their options are the following: Int - If this cell activates, all operations will be rounded down to whole number values, as in the language DIV. For example, the result of the division 8/3 will be 2. Hex - When this cell is activated, the result will be shown in the hexadecimal system. Also numbers in this system can be introduced inside the expressions preceded by ' 0x ' (as in the language). Note: On the desktop as many calculators as necessary can be opened, so many different expressions can be visible simultaneously .","title":"Help about the calculator"},{"location":"help/#compilation-options","text":"These options modify the form in which DIV interprets a program and the code which it generates for DIVl. Normally it is not necessary to specify any options. To add one or more of these options to program the word COMPILER_OPTIONS must be specified as the initial statement of the program (commentaries in margin) followed by the names of the included options. If many options are included, they must appear separated by commas, adding always a semicolon at the end (after the last option). disposed compilation options : _max_process=x Where x is a whole positive number. This defines the max number of simultaneous processes permitted during execution. This can be set when a program is completed (when it is known how many processes it will have in one moment), to optimise memory during execution. When this value isn't defined, a min of 1 Mb (and a max of 2 Mb) will be reserved for the program memory. _extended_conditions Allows you to use assignations inside a condition (such as: IF(id2=get_id(...))...) ; it was permitted by default in the first version. It may be necessary to declare this option in order to ensure that programs written with DIV1 function in DIV2. _simple_conditions Interprets the symbol = as a comparison, when it appears inside a condition. This is the opposite case to previously (and incompatible with l), once this option is included you will be able to make comparisons like IF(x=0)... , instead of interpreting them as an assignation of the value 0 to the variable x. _case_sensitive This option Differentiates between capital and small letters. If this option is active Abc and abc will be two different names. It is important to know that, if activated, all reserved words of the language such as ( program , loop , frame , if , ...) must be put in small letters. _ignore_errors Forbids the appearance of error messages during the execution of the program. The majority of errors will be ignored (such as memory errors, file not found, divisions by zero, etc.) , we don't advise you use this option but, if you want it to be included, then do so only if the programs are finished, sufficiently checked, and without known errors, before compiling the installation (See the final considerations). _free_syntax Permits you to use free syntax. With this option the symbols ; (semicolon) at the end of the statements will no longer be necessary and parentheses are no longer required in statements like IF , WHILE or UNTIL . For example, in this mode statements such as: IF a<0 a=0 END (See before final considerations) will be valid. _no_strfix Will not finish automatically text strings. When you put a character in a variable of type STRING , normally the program inserts the character after the end of the string, and adds white spaces with the character NUL (ascii 0) at the end of the string. This option disables this characteristic. _no_optimization Do not optimise the generated code. By default the programs are optimised. This option can be included to disable these optimisation processes. This means, if this option is specified, the programs will go slower and will occupy more memory. _no_range_check Doesn't check that values accessed are out of the range of tables and structures. The compiler generates code to check during the execution that expressions used as indexes of a table or structure are in the permitted limits, and to show an error when a value is out of range. This option prevents this code being generated. _no_id_check Do not check the validity of the identification code. The compiler also generates code to check the validity of the identifier when it is used to access a local variable from another process (as in id2.graph ). If this option is specified at the beginning of the program, then this checking will not be done. _no_null_check Do not check the accesses to null pointers ( NULL POINTER ). This disables the checking of attempts to access memory with null pointers or undefined pointers. Including this option means the code to protect these accesses of reading or writing in memory will not be generated . _no_check Does not allow any security checking. This option unites the three previous options, and forbids the compiler to generate code to check any type of anomalous operation during the execution. The programs will run faster, but it is not recommended to use these options until the programs have been tested and are without errors. To use these options, for example, the program can be begun with the following statement: COMPILER_OPTIONS _max_process=64,_no_id_check; In this case the compiler is set to reserve memory for 64 simultaneous processes in the execution of the program, and no validity checks on the identifiers to local variables of other processes will be made (it is useful to switch off these checks, when the programmer has sufficient experience to know what he's doing). Important: considerations about some of the options. 1. New users of DIV or those with little programming experience can simplfy a little the conditions with the option _simple_conditions , so that two values with the symbol = (also with the symbol == ) can be compared. In contrast, users who have more experience, will probably prefer to activate the option _extended_conditions so that more complex conditions can be created, with assignations inside of them. 2. The options _ignore_error and all variants of _no_check must be used only by experienced programmers, and only in the finished version of the program. Otherwise we don't recommend you use it, because major execution errors can be produced, and it will be more difficult to find the cause without these error messages. 3. In general the programs are already optimised (the generated code is 60% faster than in the previous version), but any of these options will significantly change the speed of execution. The profiles of time of the debugger can be used to see the repercussions of each option. 4. The option _ignore_errors is often not the best, nearly always it is better to use the function ignore_error() to ignore selectively some predetermined errors the program is known to generate during execution. 5. The use of free syntax (with _free_syntax ) also has many dangers. Because there is no differentiation between lines and white spaces, and in some cases incorrect interpretations can be produced . For example, in the statement: IF right ++x END , the compiler will interpret that the symbol ++ is the post increment of right , instead of the pre increment of x (although this symbol is united with this last variable). Another similar anomaly can happen using C programming style pointers, for instance, with these two consecutive assignations: a=1 *ptr=2 , the compiler will interpret them as: a=(1*ptr)=2 (although they were in different phrases). But in general, if you are not using preincrements or C programming style pointers, there will be no problems with the free syntax (also parentheses or semicolons can be used in concrete cases, to resolve these small problems). 6. However, the option _max_process (which is the only one which must be followed by the the symbol = and a number value) is strongly recommended. If the number of processes which the program can have running simultaneously is known, then less memory needs to be reserved (leaving this free for graphics, sounds, etc.).","title":"compilation options"},{"location":"help/#types-of-data","text":"In DIV there exists data of the types INT ), STRING (text strings), WORD (16 bit whole positive values), BYTE (8 bit whole positive values) and POINTER (pointers, of all these types). Also tables and structures (also of any types) of 2 or 3 dimensions (see the declaration of a table )can be defined. INT - whole numerical data between -2147483648 and +2147483647 ( min_int ... max_int ). WORD - whole numerical data between 0 and 65535 (whole of 16 bit without sign). BYTE - whole numerical data between 0 and 255 (whole of 8 bit without sign). POINTER - Pointers to data of any type. STRING - strings of text (tables of 8 bit characters without sign, between 0 and 255) Note: The reserved word INT can be omitted, because all data will be of this type by default (32 bit whole numbers with sign). ---See: Declaration of data","title":"types of data"},{"location":"help/#data-of-type-int","text":"Whole numerical data between -2147483648 and +2147483647 (values defined in the constants min_int ... max_int ). This is the basic data type of the language, when the type of the data is not otherwise specified , it will be INT by default. ---See: types of data - Declaration of a data","title":"data of type INT"},{"location":"help/#data-of-type-word","text":"Numerical whole data between 0 and 65535 (16 bit whole value without sign). Tables of type WORD can signify a big saving of memory, with respect to tables of type INT (which occupy twice as much memory). But the fastest will be operations with data of type INT . See the adjustment of data in memory , where the amount of memory occupied with the different types of data is shown. ---See: types of data - Declaration of a data","title":"data of type WORD"},{"location":"help/#data-of-type-byte","text":"Whole numerical data between 0 and 255 (8 bit whole value without sign). The tables of type BYTE can signify a big saving of memory, with respect to the tables of type INT (which occupy 4 times more memory). But the fastest operations will be with data of type INT . See the adjustment of data in memory , where the amount of memory occupied with the different types of data is shown. ---See: types of data - Declaration of a data","title":"data of type BYTE"},{"location":"help/#data-of-type-pointer","text":"Pointers to data of any type ( INT ), WORD , BYTE and STRING ). The pointers in the DIV language are different to other programming languages, for one thing they are more simple to use. These pointers are used as if they were mobile tables, that is, tables which can be defined where they are situated, assigning them an OFFSET (to the data). So you can access the data situated in this position from pointer[index] , for reading and writing of the values. different data of type pointer: INT POINTER - Pointer to whole number data. The word INT can be omitted, declaring a pointer to data of type INT as POINTER name; . WORD POINTER - Pointer to a list or table of data of type WORD . BYTE POINTER - Pointer to a list or table of data of type BYTE . STRING POINTER - Pointer to a string of text contained in a STRING . STRUCT POINTER - Pointer to a structure, which must be declared as {STRUCT POINTER name_structure ;}. Where will be the pointer to the structure. For example, if in a program there exist different tables of type WORD (declared as WORD t1[9], t2[9], t3[9]; ), then a denominated pointer ptr can be defined which permits you to access to any of the tables (as WORD POINTER ptr ;). In addition you must assign the direction or location of the specific table to the pointer (such as ptr = OFFSET t1; ) to access it. From then on you can access the values of the table with the pointer (you can access t1[n] using the term ptr[n] ). The functioning of the pointers INT ), WORD and BYTE are practically identical (they allow you to access a list of consecutive data). The pointers STRING permit you to access only one string of text (all characters contained in that string). In the declaration of the pointers of type STRUCT , the name of the structure to which the pointers refer must be declared. The pointers can give access to only one structure but, after assigning the OFFSET of the structure (or of any register) you than have access to all fields and successive registers, as if the pointer were a conventional structure. Note: To declare a pointer to a structure it is necessary to have previously defined the structure. It's enough to define the different fields, but it is not necessary to define the number of registers of the structure. Limitation in the access of the pointers. You can't access the written data before the OFFSET of the pointer is established. This OFFSET can't be assigned in the declaration of the pointer, it must be done in a statement of the program, until this statement is reached the pointer will value 0 ( pointer zero ). The access to data with the pointer zero will provoke an execution error. It is possible to limit the range of access of a pointer , indicating in its declaration the max value from the index permitted for it. For it must be only indicated in brackets, after the name of the pointer. For example, the following declaration: STRING POINTER s[32]; Defines the pointer to one string of text, but it will stop to access directly to its 33 (from 0 to 32) firsts characters. If it is intended to access out of these limits, the program will advert it indicating an access out of the rank. ---See: types de data - Declaration of a data - OFFSET","title":"data of type POINTER"},{"location":"help/#data-of-type-string","text":"The STRING tables are different to the other data types, for one thing their data can only be strings of text and they can only have 1 dimension . If a literal is not assigned to them, the string will stay initiated as \"\" ( empty string ). If a string is defined as STRING s=\"abc\"; , then when it is accessed by its name ( s ), it will refer to the contained string ( \"abc\" ). Also you can access any character of the string as if it were an element of a table (for Example, the statement s[3]=\"d\"; would add a \"d\" to the string). Note: It is not necessary to declare in brackets the length of the text strings (by default 256 characters will be set aside for the string). operations with strings of text. Inside a program, supposing the data s and r are of type STRING , then the following operations can be performed on the data. 1. data of type STRING can be used in all functions which require text (such as write (0,0,0,0,s), load_fpg (r), ...). 2. It is also possible to assign literals to a string by writing s=\"any text...\"; or assigning one string to another, as s=r; . 3. the strings Can be summed with statements such as s+=\"text to be added\"; or s=r+\"ho\"+\"the\"; . 4. Also a character can be added to a string with statements such as s+=ascii; or r+=\"a\"; . 5. A character can be deleted (from the end) of the string with s--; , s-=1; or r=s-1; . 6. Strings can be compared with conditions such as (s==\"hello\") , (s>=r) , (s<\"0\"+r) , etc. 7. And, finally, a great number of functions for text management exist (See the {#1032, list of functions of the language}). Literals of many lines. It is possible to define literals over many lines, for this you only need to divide the text into many texts, and place them one after the other (without any separation with symbols). For example, a constant can be defined as: greetings=\"\u00a1Ho\" ** \"the!\";** This can also be used to initiate data of type STRING . There is no limit in the number of lines allowed. Between two following literals only commentaries can appear. ---See: types of data - Declaration of data","title":"data of type STRING"},{"location":"help/#adjustment-of-data-in-memory","text":"It is important to stress that all data in this language will be adjusted to 4 bytes of memory (the size of data of type INT . This means that the OFFSET of all data will always be situated in one area of absolute memory multiple of picture . It has direct implications for data of types WORD and BYTE . Because they occupy respectively 2 bytes and 1 byte . therefore, if you define a variable of type WORD , so, 2 bytes of memory won't be used, and if you define a variable of type BYTE 3 bytes won't be used (because the following data will also be adjusted to 4 bytes). Therefore, to use the PC memory better, we recommend you use these two types of data as tables (see the declaration of a table ), because the different elements of a table always save as the following, and don't adjust in memory. Examples of occupation of memory: BYTE b1; - required memory 1, occupied memory 4. WORD w1; - required memory 2, occupied memory 4. INT i1; - required memory 4, occupied memory 4. BYTE b2[7]; - required memory 8, occupied memory 8. WORD w2[2]; - required memory 6, occupied memory 8. BYTE b3[2]; - required memory 3, occupied memory 4. WORD w3[3] - required memory 8, occupied memory 8. As you can see, the occupied memory (in bytes) by data will always be a multiple value of 4. You must also remember this in the fields of the structures of data because for example; two consecutive variables of type WORD will occupy 8 bytes , while a WORD table with two elements occupies only 4 bytes . ---See: types of data - Declaration of data","title":"Adjustment of data in memory"},{"location":"help/#the-function-blocks","text":"The new FUNCTION blocks behave the same way as the functions of any other programming languages, they execute sequentially (not in parallel as the PROCESS blocks do), not returning before they are finished. FUNCTION ( ) BEGIN ; ... END These blocks will continue to function in a similar way as the normal processes, but with one important difference: they will halt the calling process until the function has finished, in other words, the process which called these functions will be sleeping, until these functions return or their process will be finished. If the function doesn't use the statements FRAME , it will behave as a normal process, but if a function executes the statement FRAME , it will not return to the block from which it was called (as it would do in a normal process). Therefore, a function can always return a value with RETURN ( ) , including after executing one or more FRAME statements. successive programming. It is not recommended to program only with functions in a successive way, but it is useful to know how it is possible to simplify the understanding of programming DIV for programmers of other languages. It is possible to make a program in the traditional programming style using exclusively FUNCTION blocks, this way at each moment in the execution there will only be one process. After programming in this way, the statement FRAME converts in exactly the same order as it converts to video . Logically, if there is only one process executing, when it executes this order the system will show the following frame of the program. But, programming this way, could different graphics be shown on screen?. The answer is yes, because mini-processes can be created which will function as an instruction of the type \"paint the graphic for the following frame\" (different to functions such as put() , which paint a graphic forever). To show a graphic in the following frame a process must be constructed which receives the necessary visual parameters and only executes the FRAME statement, for example: PROCESS paint_graphic(x,y,graph) BEGIN ** FRAME;** END After calling this process {a temporal process will be created which will be painted in the next frame} and then disappear. Other parameters can be sent to this process (besides x , y , such as file , size , angle , z , ... (See the predefined local data ). It is clear that, after programming this way, a table of sprites needs to be created (normally in a global structure ) in such way that the program could manage all the graphics. This may seem difficult, but is the normal way games are programmed in any other language other than DIV. Applications in the main program. The statements which appear between the words BEGIN and END of the main program (after the declarations of data), control the main process of the program . It initiates the program, draws the images and graphics, controls the menu loops , the game loops (creating necessary processes), and closes the program. From the main program, it can be very useful to call the FUNCTION blocks. Because this way the main program will be temporarily stopped while the program executes the contents of this function. For example, the presentation sequence can be made in a function, the menu options in other, etc. Also, remember that functions can always, after finishing, return a value with the RETURN ( ) , which can be useful, for example in the menu to return the option number that was selected. Note: Reaching the end of execution of the main code doesn't mean the execution of the program is finished, so it will continue if any other processes are still active; if you want to force the program to close after this code has finished, you can use, for example, the function let_me_alone() just before the END of the main code , or also the function exit() (in any point of the program). ---See: Los blocks PROCESS - syntax","title":"The FUNCTION blocks"},{"location":"help/#global-argv-global-argc","text":"argv[]; // Arguments of the program argc; // Number of arguments--- You can access the last parameters of the program (normally after executing it from MS-DOS), in a similar way to how it is done in the programming language C, in the global predefined data argc and argv[] . The variable argc will contain, after executing the program, a number of parameters. the min number of parameters is 1 , because the program always counts as a parameter the name of the game executable. The table argv[] is a list of text strings , and will contain as many elements as are indicated in the variable argc , but the name of the program will always be stored in argv[0] . Note: When a program executes from the DIV environment, it will not receive any more parameters, just the name of the executable. Therefore these variables will be useful only for the versions already installed in the programs. ---See: global data","title":"GLOBAL argv[], GLOBAL argc"},{"location":"help/#global-struct-net","text":"STRUCT net; device; // Connection mechanism com; // communications Port speed; // Speed of connection number; // Telephone number init; // Modem initiation string mode; // Mode (press or tone) server; // Indicates if the PC is a server max_players; // Max number of players num_players; // Current number of players END This data structure requires you to have extensive programming experience to know how to create a game oriented for net connection (you can find out more information in the user's manual ). It contains data about your PC's net hardware, which are needed in conjunction with the functions net_join_game() and net_get_games() . The structure net has only one register. In its different fields are established the parameters which define the type of connection. device - Mechanism with which the connection will be established, it can be one of three values: 1 - Connection in one local net , with protocol IPX. 2 - Connection by cable (only two crews). 3 - Modem connection (only two crews). For the connection mechanism to function the fields of the structure net must be initiated, because many of these parameters are needed to control the mechanism. com - communications port used for the connection, it means, the number of COM mechanism (from COM1 to COM4), indicating it as numerical value between 1 and 4 . This field only needs to be defined for connections by cable or modem. speed - speed in bauds (number of bits per second), up to 115000. This speed must correspond to the cable or modem's capabilities, and to the amount of data the program requires to run. This field only needs to be defined for cable or modem connections. number - Telephone number, of course this field is necessary only for modem connections. For example, the telephone number which the modem needs to dial must be assigned with a statement like the following: net.number=\"912345678\"; . init - Initiation string, it is a field only required for modem connections; for example a statement like: net.init=\"ATZ\"; . mode - mode in which the modem connection must be established (also only for this connection mechanism), the values can be one of the following: 0 - Pulse. 1 - Tones. server - indicates if a PC (computer) is the server. This (field is only for reading, it can't be modified). In a connection, only one PC will have the field net.server being the value 1 , this PC will be the server of the game, and will coordinate and control the most important actions of the program. max_players - The max number of players which is allowed per game, from 2 to 16 . This field is useful only for LAN (local area network) connections, because in cable or modem connections the max number of players will always be 2 . This number must coincide with the max number of registers the global structure has used in its communication parcels between the different PCs. num_players - The current number of players connected to the game, from 1 to net.max_players . This is a dynamic value, which changes as (players connect and disconnect from the current game) in real time. The game program must predetermine if players can dynamically enter and exit from the game as they wish, or if all of them must be connected before the game starts. ---See: global data - net_join_game() - net_get_games()","title":"GLOBAL STRUCT net"},{"location":"help/#global-struct-m8","text":"STRUCT m8[9]; z; // Priority of impression camera; // Camera identifier height; // Camera height angle; // Vertical angle END This structure of 10 registers contains certain fields concerning the modifiable parameters for mode 8 windows . The ten registers have the same field names, but each one of them modifies the parameters of a mode 8 window differently (because up to 10 mode 8 windows can be activated). A mode 8 window can be defined as a region of the screen which shows a three-dimensional map of sectors. For a register (from 0 to 9 ) of the structure m8 to have any sense or purpose, you must first activated its corresponding mode 8window (from 0 to 9 ) with the function start_mode8() (see this function for more information about mode 8 windows}. The fields of this structure are complementary to the call parameters for this last function. To see a practical example of a mode 8 window, you can look up help about the function load_wld() or about start_mode8() . form of use for an m8 structure : To access these fields the name of the field must be preceded by the word m8 , the register number in brackets and the symbol . (full stop) . For example, if two mode 8 windows are initiated, the number 0 and the number 1, you can access to the camera variable of both windows with the terminology m8[0].camera and m8[1].camera , respectively. When you access mode 8 window number 0 you can also omit the brackets around the window number, this means, that the variable m8.camera and the variable m8[0].camera are, to all purposes, the same. In continuation a detailed description of each field is shown z - priority of impression of the mode 8 window, where the plane of depth (layer)that this window must be painted in is indicated, with respect to the rest of the processes. By default, this variable has the value 256 which means that, as processes by default have their local z variable set to layer 0 , the mode 8 window will be painted to a plane of further depth, or more to the background, with the processes' graphics being displayed in front of the window. To change this situation you can modify the variable z of the window (for example change it to ** -1 ) or the variable z of processes (for example place it at 257**), then the process graphics will be hidden behind the window. camera - Identifier code of the process where the camera is situated. To move the camera which controls the visible region of the mode 8, all you need to do is create a mode 8 process, in other words one which has its local variable ctype = c_m8 , and put its identifier code in the camera variable of this structure. Then, in order to move the camera's position you only need to modify the local variables x , y , z and angle of this process and, for instance, use the function advance() to move the camera forward. height - camera height with respect to the process, by default this field is initialised as 32 . The mode 8 process will be positioned on screen in its vertical coordinate z , its local variable height determines the height of the main process, and the field ( m8.height ) determines the height of the camera (the user's viewpoint of the process with respect to its base). angle - vertical angle of the camera, the value of this angle is between ** -128 and 128 . It defines whether the camera is pointing upwards or downwards. When m8.angle values 0**, which is the default value, the camera will be looking horizontally. The horizontal angle will be the local variable angle of the main process which is used as the window camera (which identifier is contained in m8.camera ). See also these other local variables with respect to mode 8 . LOCAL radius LOCAL m8_wall LOCAL m8_sector LOCAL m8_nextsector LOCAL m8_step ---See: global data - start_mode8()","title":"GLOBAL STRUCT m8"},{"location":"help/#c_m8","text":"","title":"c_m8"},{"location":"help/#constant-c_m8","text":"This constant is used to assign to the predefined local variable ctype which serves to define the type and number of coordinates (dimensions) a process will have. Its value is set to 3 . This value (3) is the value the variable ctype understands as meaning the graphic coordinates are contained in a mode 8 window, a three-dimensional sector map which the graphics are shown. For more information about mode 8 windows , you can access the function start_mode8() , used to activate them. Other constants exist which are used for other coordinates systems, here is the complete list : c_screen - coordinates of screen c_scroll - coordinates of scroll c_m7 - coordinates of mode 7 c_m8 - coordinates of mode 8 ---See: constants - ctype - start_mode8()","title":"constant: c_m8"},{"location":"help/#global-struct-dirinfo","text":"STRUCT dirinfo; files; // Number of files in list name[1024]; // File names END This global predefined structure is used as the return value of the function get_dirinfo() , to contain the list of files in a directory (or folder). It consists of one structure register, which groups one variable files and one table of pointers in the text strings ( name[] ). In continuation a detailed description of each field is shown name[] - The function get_dirinfo() only returns the total number of files listed; the names of these files are saved in the global structure, in the table name[] (the first name of file is saved in dirinfo.name[0] , the second in dirinfo.name[1] , etc.). files - The total number of files listed which this function returns are also saved in this field (in dirinfo.files ). The list of file names are always saved in alphabetical order, the function qsort() can be used to order the structure by other criterion. ---See: global data - get_dirinfo()","title":"GLOBAL STRUCT dirinfo"},{"location":"help/#global-struct-fileinfo","text":"STRUCT fileinfo; string fullpath[254]; // Full name drive; // Drive letter string dir[254]; // Directory string name[7]; // Name string ext[3]; // Extension size; // Size (in bytes) day; // Day month; // Month year; // Year hour; // Hour min; // Minute sec; // Second attrib; // Attributes END This global predefined structure is used as the return value of the function get_fileinfo() , to contain the attributes of a file (or subdirectory). It is a one register structure, which groups different strings of text (data of type STRING ) and numeric variables (data of type INT ). Below is a detailed description of each field is shown fullpath - Full name (including the path). The file path can be specified completely (beginning with the root directory of the drive, such as \"C:\\WINDOWS...\") or relative to the current directory (starting from where the game executes, such as \"MAP\\MIOS...\"). In all cases, fileinfo.fullpath always returns the full path from the root directory, including the drive letter. drive - Drive disk where the file is situated. The drive disk is returned not as its corresponding letter, but as a number, establishing the following correspondence: 1 for A: , 2 for B :, 3 for C: , etc. dir - The directory where the file is situated. This string not only returns the name of the folder or directory where the file is, but also the full path, beginning with the current directory and listing all the directories in the path (for example \"\\DIV\\MAP\\\") relative to the directory of the program executable. The return value always has an inverted bar () at the beginning and at the end. name - the filename, this field ( fileinfo.name ), returns the name of the file, without its suffix/extension, up to a maximum of 8 characters . ext - Extension of the file. The extension of the file is returned in this field, in a string which includes the point which separates the filename from its extension. size - file size, this value will be 0 if the information refers to a directory. The size returns as a number of simple data, this means, as a multiple of data like INT (number of bytes in multiples of four (4,8,12,16 etc...)). It is possible to change this relationship by modifying the global variable unit_size ). day - Day of the month of the last actualisation of the file. month - Month of the last actualisation of the file. year - Year of the last actualisation of the file. hour - Hour of the last actualisation (from 0 to 23 ). min - Minute of the hour. sec - Second of the minute. attrib - Attributes of the file, they indicate the characteristics of the file, if it is a system file, a read-only file, an archive file ,etc. This value is the sum of the following constants: 0 - Normal file. 1 - Read-only file. 2 - file archive. 4 - System file. 8 - Volume Label. 16 - Subdirectory. 32 - file speed. For example, for a system and archive file, the value of fileinfo.attrib would be 6 (2 archive + 4 system). ---See: global data - get_fileinfo()","title":"GLOBAL STRUCT fileinfo"},{"location":"help/#global-struct-video_modes","text":"STRUCT video_modes[31]; width; // Width of mode height; // Height of mode mode; // Number of mode END In the global predefined structure video_modes , at the beginning of all programs, the list of VESA modes supported by the PC's video adaptor are detailed (all of them of 256 colours ), up to a maximum of 32 (from [0] to [31]). The number of found VESA modes is saved in the global variable num_video_modes . This information is generated by the system automatically, so you don't need to call any function. For all found modes the following information is registered : width - Number of horizontal pixels of the video mode. height - Number of vertical pixels of the video mode. mode - Number of mode. This value can be used directly as a parameter for the function set_mode() . Once the width and height of the video mode which you want to activate has been selected, and therefore the number of registers its structure shall consist of has been defined, you must then activate it by calling the function with : set_mode(video_modes[ ].mode); Note: Besides the registered modes in this structure, there also exists a list of standard video modes, which numbers are contained in the constants m320x200 ... m1024x768 . ---See: global data - num_video_modes - set_mode()","title":"GLOBAL STRUCT video_modes"},{"location":"help/#global-channel","text":"channel[31]; // Use of sound channels--- The global table channel maintains information about the use of the different (up to 32) sound channels of the audio system. Each time when you play a sound with the function sound() , it is sent to one of these channels. And if the playback of one musical module with the function song() is initiated, a determined number of channels (up to 24) are reserved for it. In this table, each position represents one of these sound channels, and the system sets the value of each position to 1 when its respective channel is used. The function change_channel() allows you to modify the parameters of each one of these channels. Note: The system will never automatically set the value of the positions of the table channel to 0 , this must be done with the program code, and similarly the program must determine when a channel is used once more. ---See: global data - change_channel()","title":"GLOBAL channel[]"},{"location":"help/#global-vsync","text":"vsync=0; // Wait the vertical retrace--- The global predefined variable vsync defines a logical value (0 or 1) which indicates if it is necessary to wait before doing a vertical retrace the following frame is converted to video (when all processes execute the statement FRAME ). By default this variable will be set to 0 , which means, the process does not delay the vertical retrace before converting each frame to video. To indicate to the system that it must delay the vertical retrace you must set this variable to 1 (with the statement vsync=1; ). Note: Delaying the vertical retrace can make movements more soft to the eye (this effect is visible most of all in the panoramic effects, see start_scroll() ), but delaying the retrace will also slow the programs down in the great majority of cases. ---See: global data","title":"GLOBAL vsync"},{"location":"help/#global-draw_z","text":"draw_z=-255; // plane of depth of the primitive graphics --- The primitive graphics are such things as straight lines, rectangles, circles, etc., which are painted with the function draw() . In this global variable the plane of depth in which the primitive graphic must appear on screen is indicated, this means what must appear in front and what must appear behind on screen. The plane of depth can be any whole number inside the range ( min_int ... max_int ), the bigger the number the more to the background the frame will be situated . The process' graphics have their local z variable set to 0 by default, the texts text_z are set to ** -256 and the mouse pointer has its z - value mouse.z set to ** -512 by default. This means, that by default, if these values are not modified, the primitive graphic will appear in front of the processes, but behind the mouse pointer and the texts. Note 1: The variable draw_z is GLOBAL for all primitive graphics, in other words, they cannot be represented in different planes. ---See: global data - draw()","title":"GLOBAL draw_z"},{"location":"help/#global-num_video_modes","text":"num_video_modes; // Number of detected video modes--- The global variable num_video_modes contains the number of VESA video modes which were detected in the system's graphics adaptor. The parameters of each one of these modes are registered in the global structure video_modes , therefore the variable num_video_modes defines the total number of registers defined in this structure. Note: Besides the modes registered in this structure, there exists a list of 10 standard video modes , which numbers are contained in the constants m320x200 ... m1024x768 . ---See: global data - STRUCT video_modes - set_mode()","title":"GLOBAL num_video_modes"},{"location":"help/#global-unit_size","text":"unit_size=4; // Minimum unit of reading/writing--- The global predefined variable unit_size indicates the minimum unit of reading and writing for the functions of files situated in handles . By default it always has the value 4 , because 4 bytes is the unit size of the standard data INT (32 bit whole number), and each piece of data has 4 bytes assigned in memory (see the assignation of data in memory ). The functions which count up the number of these unit_size blocks a variable contains are the following: fread() fwrite() fseek() ftell() filelength() And also the field size of the global structure fileinfo . The minimum size of 4 implies that it is impossible to write to or to read from any files whose length is not a multiple of this number. This size can be changed; for example assigning 1 to unit_size (with the statement unit_size=1; ). By doing this, all lengths of the previous functions will be indicated in bytes (and not in units of data). However, after changing the unit size, you must remember the following: SIZEOF() will continue to return the data length (in units of 4 bytes). For example, to save a table on the drive it will be not enough to indicate sizeof( ) as its length, you will also need to multiply this value by 4 (if its unit_size is defined as 1 ). The functions of files save() and load() (which are not functions based on the file handles ) will continue to indicate file length in data. The functions of dynamic memory malloc() and free() also will continue to work with the length in data, therefore adjustments must be made to cater for working with both groups of functions. ---See: global data - Alignment of data in memory","title":"GLOBAL unit_size"},{"location":"help/#local-radius","text":"radius; // Radius (width) of the mode 8 processes --- This predefined variable is LOCAL , that means that each process will have their own value in its variable radius . This local variable is used exclusively in mode 8 processes (which have assigned c_m8 to ctype ). radius indicates the radius, or horizontal size, of the process. The system requires this value to calculate any collisions with the limits outlining the borders of the sectors of the three-dimensional map. The smaller the value of radius is for a process, the nearer it can be to its walls and, therefore, the bigger the pixels (or texel) of its textures will be. Note: For more information about mode 8 windows, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8()","title":"LOCAL radius"},{"location":"help/#local-m8_wall","text":"m8_wall; // Wall number of the sector map --- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_wall . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). the system stores in the variable m8_wall , the number of the wall the process has just collided against. This information can be useful to detect distinct active zones inside a map of sectors (such as ports, interrupts, etc.). Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to set up regions of this type. ---See: local data - start_mode8()","title":"LOCAL m8_wall"},{"location":"help/#local-m8_sector","text":"m8_sector; // Number of sector in where the process is--- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_sector . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_sector the system automatically saves the number of the sector over which the process is situated, inside the map. The information about the sector number can be useful to program events where a process enters the specific sector. Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8()","title":"LOCAL m8_sector"},{"location":"help/#local-m8_nextsector","text":"m8_nextsector; // Sector the process is directed towards--- This predefined variable is LOCAL , that means that each process has its own value in its m8_nextsector variable. This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_nextsector the system automatically saves the sector a process is directed towards. This means that, when the process collides with one of the map walls (borders), the system checks to see if any other sectors exist beyond this boundary, and if so, will store its number in this variable. This information can be useful, for example, to obtain the heights at which this sector is situated (See get_sector_height() ) and, in this way, can check if the program must adjust its height, and by how much, to proceed to the named sector. Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8()","title":"LOCAL m8_nextsector"},{"location":"help/#local-m8_step","text":"m8_step; // height to which can lift the process--- This predefined variable is LOCAL , that means that each process will have its own value in its variable m8_step . This local variable is used exclusively in mode 8 processes (which have assigned the value c_m8 to ctype ). In m8_step the maximum height which the process can be raised to reach the sectors is given, as \"the height of step\" which this process can rise by. When a process comes across a more elevated sector, the system checks with help of this variable to see if the process can reach this elevated sector, if the answer is yes the new height of the process will be set automatically and, but in the contrary case, the process will stop (it will collide with the boundary that separates both sectors). Note: For more information about mode 8, see the global structure m8 and the function start_mode8() , which is used to initiate regions of this type. ---See: local data - start_mode8()","title":"LOCAL m8_step"},{"location":"help/#global-fps","text":"fps; // Number of frames per second--- The global predefined variable fps (frames per second) maintains the number of frames per second which the program shows. This variable is set by the internal processes of DIV Games Studio automatically. It doesn't determine this value in an instant, but rather takes an average over the last few seconds. The function set_fps() allows you to set the number of frames per second of the program, but this establishes the ideal number of frames and not the actual (which is stored in fps ). This means, that this variable serves as a counter to determine how many frames per second, on average, are converted to video. Note: The variable fps contains data only for reading, and its value cannot be modified by the program. ---See: global data - set_fps()","title":"GLOBAL fps"},{"location":"help/#welcome-to-div-2015","text":"This help file outlines the basic concepts required in the usage of the DIV Games Studio development environment. Using this electronic help you can access a lot of information about this environment, but even so, the learning of the programming language and the menu options are described only in the User's manual . Note: If you are using the DIV programming environment for the first time, you should know that in order to exit from DIV (or any game created with DIV), you should use the key combination ALT + X . What's new in DIV2? New language commands and variables New environment aspects introductory chapters How to use the help system Frequently asked questions (FAQ) Resolution of configuration problems What is DIV Games Studio? Working with windows Types of windows Fixing a video mode The configuration window First contact with the language Debugging your program DIV Games Studio appeared on the market in December 1998 as the first development environment with a programming language designed exclusively for games programming. In the beginning, our wish as developers was not the creation of a professional environment, but more to create a simple and interesting environment which could serve as an introduction to the fascinating world of games development; something like a \"game to make games\" in which any person could learn how to program. The very good response to DIV1 leads us to make this second version of the environment, in which the same philosophy is maintained. A great number of received opinions, criticism and wishes permitted us to create the new DIV Games Studio with improvements in all areas. We intended to improve, although only a little, all areas of the environment. In this sense there are major differences with the previous version, (and they are very practical and logical ones). We would like to thank everyone who has supported our ideas and this product. At the time of releasing this second version we don't know if an alternative to the DIV environment exists, which although on the one hand seems regretful, it does give us pride in the knowledge that such an environment exists here. The DIV Games Studio team.","title":"Welcome to DIV 2015!"},{"location":"help/#new-language-commands-etc-in-div-version-20","text":"More extensive programming language. The programming language has been enlarged, including many new characteristics and internal functions, the more prominent of which are detailed below. The compilation options are a new characteristic of this version, which allow you to adapt the process of compilation to the individual requirements of each project (see Compiler_options ). - In addition to the first version's data (which are now known as INT ), there now also exists data of the types STRING (strings of text), WORD (16 bit positive whole number values), BYTE (8 bit positive whole number values) and POINTER (pointers, to all these types). - Also 2 or 3 dimensional tables and structures (also of any of these types) can be defined (see the declaration of a table ), and the structures can be initiated globally (see declaration of a structure ). - The new FUNCTION blocks behave in a similar way to the functions of other programming languages, they execute sequentially (and not parallel as the processes do), not returning until they are finished. - Different aspects of the program debugger have been improved, with new functions and support for new types of data. Also new are the time profiles , which you can access from the debugger using the keyboard command F11 , here you can observe the time taken in the execution and painting of each process. - The error control system for the programs has been improved, creating a more stable and better executable, there also now exists the possibility to ignore certain execution errors to allow the program to continue running (see the function ignore_error() . - new functions of file management have been added, which give you much more flexibility and potential over the way a program handles files; see for example fopen() , fseek() , get_dirinfo() , chdir() , remove() ) or disk_free() . - Besides support for CD-Audio music and digital effects, there now exist different functions for the reproduction / playback of music modules MOD , S3M and XM (see load_song() , song() or set_song_pos() ). - Optimised code generator. The code generated for the programs is better and faster (at least 60%) than the previous version. Also the created programs EXE are much smaller. - Functions for playing games over the internet or other network. With DIV Games Studio 2, it is possible to create games to play by cable , modem and local net IPX . This functionality is very simply controlled by the functions net_join_game() and net_get_games() . - Also new is the integration into the language of the ability to manipulate strings of text, with data of type STRING , many new functions (such as for example strcat() , strchr() , upper() or strdel() ) have been added along with adapted syntax to work with string expressions directly in the language. - Dynamic memory support . It is possible to ask for and free up memory dynamically whilst a program is running, thanks to the functions malloc() and free() (complemented with the new data type POINTER ). Also the function memory_free() allows you to determine the free disposed memory in the system at a certain point in the program. - You can also now order and disorder data, with the simple function qsort() which permits you to order and disorder data structures, taking any field as its index. - Another new feature is the ability to search for a path . This is achieved with different functions (see path_find() ) which, for instance, allow you to find the shortest and best available routes between two points, avoiding any obstacles. - Compression of data. Everything is more compact; the executables and installed data (can be created as compact and protected installations ). Also functions of compression are included in the language (see compress_file() ). - New mode 8. A new mode with up to 10 screen regions, which allows you to visualise maps of three-dimensional sectors. These three-dimensional environments also include an integrated editor in the environment and many specific functions (see for example start_mode8() , set_sector_height() , or set_fog() ). - And much more. What's new in the language doesn't stop here, there are many other improvements and functions (besides the bugs in the original version which have been fixed). Outlined below we describe what else is new in the DIV programming language. - A new function, called force_pal() , allows all {graphics loaded in a program to adapt automatically to a palette} at the time of execution. Functions for data encryption also exist, such as encode() , encode_file() and decode_file() . The library declarations reside now in the headline of the program, just after the PROGRAM statement (see IMPORT ). It is now possible to create programs in much more video modes , because the available VESA modes can also be detected (See video_modes ). In this new version assignations inside a condition are prohibited, to simplify the programming for less advanced users. However this can be changed (see _extended_conditions and _simple_conditions ). Now it is possible to define the max number of processes which can be active in the program during execution (see _max_process ). It is now possible to define literals over many lines , to do this the text must only be divided into distinctive literals, and put successively (see the limitation symbols of literals ). The sound system is completely new, and it is now possible to play back WAV files of better quality in the programs (See load_wav() and new fields of the structure setup ). Also new sound functions such as change_channel() or is_playing_sound() have been added. Also it is now permitted to use directly frames of PCX format in the programs (See load_pcx() ), and to save these files (See save_map/pcx() ). Functions now exist to fix a colour of the palette , such as ( set_color() ) and also to localise colours ( find_color() ). Trigonometric mathematical functions as sin() , cos() , tan() , asin() , ... have been added. Also a primitives painting tool has been included to create distinct graphics on screen: such as lines, rectangles and boxes, circles, ... (See draw() ). other functions have been added which increase the existing possibilities in the creation of programs, such as screen_copy() , write_in_map() , calculate() , load_screen() , xadvance() , new_map() , ... Also you can count the frames per second (See fps ), obtain the parameters of the program (See argv[] ), delay the vertical retrace (See vsync ), control the mouse in the programs better (See mouse.cursor and mouse.speed ), etc. And of course, all functions, data and possibilities which were available in the first version of DIV Games Studio, still remain! :) --- See also: New graphical environment changes","title":"New language commands etc.. in DIV version 2.0"},{"location":"help/#new-additions-to-the-environment-in-version-20","text":"More flexibility and simplicity in use. The development environment of DIV Games Studio has evolved into several smaller modules, and together they form a more intuitive structure than in the previous version. A new help. The help section has been restructured, and of course covers everything that's new in the DIV language. The window includes a new navigation bar. - Multiple paintbrush sizes. In the graphical editor paintbrushes of various sizes and forms can now be selected, either in monochrome or in greyscale. By pressing the key T you access the new dialogue; new paintbrushes can also be added, adding them to the file BRUSH.FPG of the SYSTEM directory. - Cover a Picture with coat or textures. In the graphical editor using the key U you can access the new dialogue where you can select any of the maps from the desktop as a texture to paint onto the surface of an image (with the key X you can see and allocate this texture). The aerosol tool has been improved, as has the bar of shade checkpoints , and also new keyboard commands were added (such as K to copy a graphic in a window, or +/- to change the checkpoint). - Graphical visualisers. Almost all windows to open files can display a square window thumbnail which allow you to view the contents of these files before they are loaded. It is also possible {to load different files at once} highlighting them with the mouse while the control key is held down (the Shift key allows you to highlight isolated consecutive graphics). - Developed system of files. In this version the internal management of the FPG files has been improved; errors have been eliminated, thumbnails of the contained maps can be viewed, lists can be printed, a complete FPG file transferred to a map and vice versa. - Sound effects editor. The audio has been completely revised, permitting many more operations, formats and including a mixer and effects editor of the sound. You can access this editor from the sounds menu. - Evaluation of expressions. Now you can access the new calculator windows (from the system menu) to evaluate numerical expressions while programming, without having to exit from the DIV environment. - Sprite Generator. The character generator is also a new characteristic of this version. It was made to create a base on which the realistic pictures of humans and animations can be realised. These photo-images can then be modified in the graphical editor. - Three-dimensional maps editor. A menu for 3D maps, their editor and all functions related to them in the programming language, are also a new characteristic of this version of DIV Games Studio. - Time profiles. From the program debugger you can access, by pressing F11, the time profiles of the program. These statistics indicate the time consumption of a process during the executing of the program, and allow the manual optimisation of the speed of these programs. - New examples. Several sample games and programs developed by users of the previous version of DIV Games Studio are included in this version. Also, on the CD-ROM you can find multiple shareware utilities available for free use in this development environment. - Facility of impression. This version of DIV Games Studio allows you to print, in addition to a program list, lists of the graphics contained in the FPG file and the electronic help pages. - Volume Controls. Amongst the improvements included in the audio system, there now exists a better volume level control, in the environment and the program. In the CD player window there is a small button which gives you access to the mixer. - Library of graphics. The library of graphics included in the program has been enlarged and better structured. Also now maps can be imported of any colour depth in the formats BMP, PCX or JPG. - New installation system. The installation system of the program has been completely re-done, generating a more compact and protected installation, and using a more intuitive and graphical adaptable interface . - And much more. Many more small improvements in the environment exist, many of them imperceptible, but they make the environment more powerful and easy to use. Outlined below you can see in detail the more relevant of these. - The process of entering and exiting from the environment has been optimised , as has the execution of programs from it, also the environment loads faster and all delays between processes are shorter. The program editor is now in colour , highlighting the key-words of the language, also you can define more clearly, for example, the tabulation size. Now, after loading the environment, you have the option to {continue with the previous session} or start a new one . It is possible to select more visualisation modes for the environment, depending on the modes supported by the installed video-card and VESA adaptator. A colour palette editor simplifies the generation of explosions (which can now be aborted) and the preparation of the background (a preview is now shown). The speed of the mouse pointer can be configured using the small bar presented in the configuration window of the system menu. In the fonts windows a sample of letters appears , which indicate which collection of characters are selected. It is possible to generate fonts of letters with shadows or outlines , by simply creating them with an outline of 1 pixel of the background colour. --- See also: New features of the programming language","title":"New additions to the environment in version 2.0"},{"location":"help/#resolution-of-configuration-problems","text":"General resolution of audio problems. If the audio system couldn't be initiated, it is most likely because of a sound card conflict. This problem is often produced by one of these causes : The card is being used at the same time by another program . It cannot initiate the sound if any other program is reading or writing data via the card (such as an MP3 player or sound capture device). A problem can occur with the auto-detection of the soundcard's parameters. You must execute the sound configuration program or define these values in the variable BLASTER or ULTRASND of the system environment (you can find more information in the user's manual for DIV Games Studio 2). Because the soundcard is incompatible with DIV. If the card is not a GRAVIS (tm) or SOUND BLASTER (tm), it may be incompatible with DIV Games Studio. The majority of commercial cards are compatible with SOUND BLASTER, but may not be 100% compatible and may present some problems. If your particular problem doesn't fit into any of these three cases, you must first execute the sound configuration program. This can be called from DIV by pressing F4 , or loading the program SETUP.PRG from the SETUP directory , and executing it with the key command F10 . In this program you must input the parameters of your sound card. To obtain these parameters in MS Windows it is probably best to consult the soundcard's handbook, but normally you can also access them the following way: pressing with the right mouse button in \"My Computer\", activating the Properties menu \\ Device Manager \\ Sound, video and games Controllers, selecting your audio card (normally one compatible with \"Sound Blaster\" or \"SB\") and pressing the Properties button. Then a dialogue will appear with the characteristics of your sound card where, in the Resources pane you'll find: 1. The IRQ number of your card as an \"interrupt request value\". 2. The DMA and of DMA2 (also denominated as HDMA or DMA16) numbers which are the two \"direct memory access\" values. 3. The port number as the initial value of the first \"enter/exit value\". Also you can try to configure the sound system indicating in the configuration program a simpler card (previous to yours). For example, if you have a soundcard compatible with a Sound Blaster AWE 64 or 128 and cannot get the sound system to initiate; try to configure the system as if it were a Sound Blaster 16 , or Sound Blaster Pro card. As the last recourse, if it is not possible to configure the sound in your system, you must deactivate it. For this you must execute the configuration program and select the value in the field which defines the type of card. Then press the button to establish this configuration and deactivate the sound in DIV Games Studio 2. If you are unable to hear the sound effects in your program on your PC, you probably have a sound card which is not 100% compatible with the Sound Blaster or Gravis Ultrasound family of cards. Consult your dealer. Note: The reproduction of CD-Audio is independent of the digital sound system whose configuration is described here; therefore CD music will be reproduced although the sound system may not have been correctly initialised. Video or Graphics card Problems. If at any time DIV enters a resolution which cannot be displayed properly, the first thing which must be done is to exit from the environment by pressing the key combination ESC+control (or ALT+X and Enter in succession) and, then, re-enter the program in safety mode. To enable this mode you must, from the MS-DOS command prompt and in the directory (FOLDER) in which the program was installed , execute the following command: ** D /SAFE** This way you will load up the environment in a low resolution (in 320x200, the most compatible mode), from this mode you can attempt to put in other resolutions which will be compatible with your graphics card and with your monitor. On those PCs where the graphics card is not compatible with the standard VESA system you must install VESA driver for the card. For this, you must contact your card supplier or technical support of your hardware for the driver. ( A driver is a small program which must be installed on the PC to give support for some hardware or utilities such as, in this case, your video or graphics card). Problems with the mouse. If the mouse is jumping on the screen, instead of moving smoothly from point to point, it is because you're using an incorrect or out of date mouse handler (the mouse driver is not functioning properly). You can resolve this problem in one of these ways: 1. Contact with the supplier of your PC to obtain the latest driver for your mouse. 2. Change the resolution of the program (with the option system\\video mode ) to another which does not produce this problem. 3. (MS-DOS, only for advanced users). Comment out the line in your autoexec.bat file in which the mouse driver is loaded. This can be done from the DIV environment, by loading this file (situating on the root directory of your hard disk) with the key command F4 and adding the word REM at the beginning the line which loads the mouse driver (a line which normally finishes with the text ... mouse.com). Then press F2 to save the file, close it (pressing on the upper left corner of the text window), exit from DIV (ALT+X) and re-start your PC. If you then have problems with another program which requires this driver, return to edit the same autoexec.bat file and remove the word REM which was added. Solution of possible installation problems. If you find any problem, check the minimum requirements indicated in the program. If you have doubts about one of the elements consult the technical support of your PC or your PC supplier. The most likely problem is reading from the CD-ROM drive; for this, clean the surface of the DIV Games Studio CD carefully with a clean and dry duster, and attempt the installation of the program once more. Manual installation If you couldn't install the program correctly and have a lot of free space on the hard disk of your PC (sufficient to allow a maximum installation) you can attempt a manual installation of the program, by following these steps: MS-DOS users - Supposing that your CD-ROM disk drive is the letter D:, select the CD-ROM drive with the following command: ** D:** And press Enter. Then introduce the following commands (supposing that your hard disk is the C: drive): ** XCOPY DATA*. C:\\DIV*. /S** ** C:** ** CD \\DIV** ** DEL INSTALL . ** Pressing Enter after each one of these commands. If you have sufficient space the program will be installed without any problem, introduce this command to execute it afterwards: ** D /SAFE** For the next steps in executing the program, follow the conventional instructions. Users of Windows 95/98 - Open the MS-DOS prompt (double clicking on its icon, or via start menu \\ programs \\ ms-dos) and follow the instructions for MS-DOS users. For the remaining executions of the program you can use the instructions that come with the operating system, remembering that the program will be installed in the DIV folder of your hard disk. If you cannot get the program to function correctly with these suggestions, then contact your FastTrak Technical Support, its tel. is (44) 1923 495497 (01923 495497 for UK users) during normal office hours Monday to Friday from 09:00 to 17:30 or go to http://www.div-arena.com and try the message forums or the live chatroom. Remember though, that as DIV Games Studio is a big selling product with limited technical support facilities, it is best to first try and follow carefully all instructions and check the website before making a call to this service. Important: This technical support service does not provide any consultation regarding the programming language, because we could not give any more advice than is contained in the help file and the user's manual of the program. With these you can find a solution for any doubts regarding the programming language you have.","title":"Resolution of configuration problems"},{"location":"help/#what-is-div-games-studio","text":"It is a graphical environment which integrates a new programming language for videogames together with other utilities such as a painting tool, tools to create fonts, palettes, etc. The programming language was made exclusively for the creation of games and, as you can see, allows you to obtain very good results with very short and simple programs. It is not necessary to know how to program to use it, DIV was designed so that the user could learn to program with it. It has a user-friendly environment to make you lose the fear of the word \"programming\" ... ---See: Working with windows - Introduction to 2","title":"What is DIV Games Studio?"},{"location":"help/#working-with-windows","text":"The windows, can be moved to any position on screen if you press on the title bar with the mouse and drag it to the new position. Title bar. - Is the top zone of the window, where the name of the window is shown in white against a blue background. When the name of the window appears in grey scale, it is because the window is not selected (as another window is currently selected ), to select it press on it. Drag. - This term is applied inside the graphical environment to mean the action of holding the mouse button down over an object, moving it to the new position, and finally releasing the mouse button. To ask the system to place the window automatically, you must double click with the mouse on the title bar of the window. If the system finds a better position for the window, it will move it there. The windows can be in different modes , and therefore their functions and operations will be distinct from each other. These modes are described below : 1. Active windows: Are those which, normally, have an illuminated title bar, in white letters against a blue background and are situated foremost on the desktop. 2. Inactive windows: These type of windows have a dark title bar, in black letters against a dark grey background. To activate one of these windows simply click on them with the mouse. 3. Windows in the second plane: These are windows which are obscured; this is because they are at least partially, covered by other windows. With these windows you can't interact with them until they come into the foremost plane by clicking on them with the mouse. 4. Icons: The icons are the minimised windows, this means, the windows which were reduced temporarily. The icons don't have a picture, just a button with the sign \"+\" followed by the title of the window. Note: To drag the graphics (to a file, to the desktop, etc.) don't press on the title bar of the window, but on the contents of the window. This means, you must press the mouse button in the middle of the window and, without releasing the mouse button, move it to the new position. ---See: Types of windows - Introduction a DIV 2","title":"Working with windows"},{"location":"help/#types-of-windows","text":"The windows can be classified by their function, into the following groups: 1. Interactive dialogues: These are windows which are used to impart information to the user; there exists a huge variety of them, which you'll see in the respective options. 2. Error message Windows : Are the dialogues in which the title bar appears in white against a red background and inform the user about the problem which has arisen. 3. Options Menus : These menus contain the list of options which call other menus, windows or dialogues after they have been clicked on. All these menus stem from the main menu. Some menus may have certain options disabled (a pointer is shown with the prohibited symbol if you place the mouse over it); this is because these options interact only with the specific types of windows, and there is no window of this type currently active (it must be created or loaded beforehand). 4. Programs: In these windows the programs are created and are effectively text windows. To edit a program its window must be activated (only one program window can be activated at any one time). The text is similar to that of other text editors (supports the standard DOS command EDIT). To ask for help in a program about a specific word of the programming language you must place the blinking cursor (not the mouse pointer) on it and, then, press the key F1 . These windows can be changed in size by pressing on the their lower right button and dragging with the mouse or by pressing the keys control + Z . 5. Maps or graphics: These windows are those which contain a map (bitmap) or graphic and are controlled with help of the menu of maps. They can be loaded from a MAP file (proper format), or imported from a PCX, BMP or JPG file. To edit the graphics you must double click with the mouse button in the centre of these windows thus opening, in this way, the graphics editor (described in the user's manual ). These graphics can be dragged to the background (to make a copy), to another graphic (to insert in them), to a file of graphics (to include them) or to the trash (to delete them), to drag them you must drag from the centre of the windows, and not from the title bar. 6. 3D Maps: These are vector maps created in the 3D maps editor, how a collection of closed polygons is shown in their window representing the vertical section of a plan. Its creation is not a trivial matter, and is explained in the user's manual . These maps are saved on disk in files with the extension WLD. 7. FPG or graphics library files : These windows show the contents of one file on the drive. These files are libraries or collections of graphics used in the game. Their purpose is to load a large quantity of maps into a game. They have two basic modes of function, activated with the help of buttons named \"Info\" and \"Images\" along the bottom of the window. When the \"info\" button is not activated (by default), graphics can be created and moved, or dragged (to the background, to other files, maps or the trashcan). When the \"info\" button is activated, the graphics codes and their descriptions are displayed with a thumbnail image. These FPG files are always controlled from the FPG file menu. The FPG file windows are always just a reflection of the \"graphics file\" contained on the hard disk of the PC, and therefore can be closed at any time, without need to save them before. Their contents will never be lost. The option Files \\ Save allows you to make a copy of the FPG saving it under another name (as temporary or security copy). 8. Fonts of letters: The fonts or letter types are small windows which display the current typography. You must click on them with the mouse to see an example of the font in real size. They correspond to FNT files (official font format) and are controlled by the fonts menu, from which you can access the fonts generator, which is the tool used to create new fonts of letters. The fonts of letters are used inside the painting program and in the programs to write texts. 9. Sound effects: These windows represent on screen a PCM file (press code modulation) or WAV file with a sound effect. They are controlled with the sounds menu, so you can create new effects (with the sound recorder) or edit them. You can find a library of sound effects already prepared for use in the games. To hear these sound effects you must have a sound card compatible with the Gravis Ultrasound or Sound Blaster family, correctly configured and then click over one of these windows. 10. Musical modes: Songs in the formats MOD, S3M and XM can be loaded . They are represented in a small window which allows you to activate or stop its playback. You cannot compose new modules from the environment though. 11. Help window : It is controlled mainly with the mouse, but you can also use the cursors, and the PageUp, PageDown and BackSpace keys to return to the previous page. In the help windows the texts are shown in white which make reference to other help pages. You must click on these references to access to these pages. In the help windows are also shown example programs which can be selected by clicking on their title, executed with the key F10 and closed by clicking ALT+X. 12. Calculators: The calculators windows function as evaluators of mathematical expressions, in the style of expressions presented in the programs. Their functioning is very simple, because you need only introduce an expression and press Enter to see the result. You can use parentheses to indicate subexpressions. Note: The trash window must be activated first from the system menu, with the corresponding option ( System \\ Trash ). ---See: Fixing the video mode - Introduction to DIV 2","title":"Types of windows"},{"location":"help/#demo-session","text":"This is a version of DIV Games Studio 2 designed for evaluation purposes only, and is limited to 31 executions of the program. This demo version is completely functional, and was created with the aim that you could evaluate the possibilities of the program and its compatibility with your system, before obtaining the full registered copy. There are only two restricted functions in this version: The program size which can be compiled is limited by the maximum number of objects allowed in this version. All finished programs (after creating an EXE independent from DIV with the option Programs \\ Create installation ) will be marked with a message stating this is a demo version only. These restrictions don't exist in the commercial version of the program, but in addition remember that the full version also contains a User's manual which is essential to access all the functions of the program and to effectively learn the programming language of DIV 2. Note: The information contained in the User's manual of DIV Games Studio 2 (about what's new in the environment, the program options, a tutorial for the new language, ...) cannot be found in this electronic help.","title":"Demo Session"},{"location":"help/#conflict-with-the-sound-system","text":"The audio system of DIV Games Studio was not initiated because of a conflict with your sound card. This problem is often produced for these reasons: The card is being used at the same time by another program . It cannot reproduce the sound if any other program exists which reading or writing data to the card (such as an MP3 player or sound capture device). A problem with the auto-detection of the card's parameters can occur. You must execute the sound configuration program or define these values in the variable BLASTER or ULTRASND of the system environment (you can find more information on this in the user's manual of DIV Games Studio 2). Because of the incompatibility of the card. If the card is not a mark GRAVIS (tm) or SOUND BLASTER (tm), it may be incompatible with DIV Games Studio. The majority of commercially available cards are compatible with SOUND BLASTER cards, but they still may not be 100% compatible and may present some problems. General solution of the audio problems. If your particular problem doesn't fit into any of these three cases, you must first execute the sound configuration program. This can be accessed from DIV by pressing F4 , loading the program SETUP.PRG from the SETUP directory, and executing it with the key command F10 . In the first chapter of the user's manual you can find the information about how to obtain the parameters of your sound card. Also you can try the configure the sound system indicating in the configuration program as if your card was a simpler one (previous to yours). For example, if you have a card compatible with a Sound Blaster AWE 64 or 128 and cannot initiate the sound system; try to configure the system as a Sound Blaster 16 , or Sound Blaster Pro card. As the last recourse, if it still wasn't possible to configure the sound in your system, you must deactivate it. To do this execute the configuration program and select in the field which defines the type of card. Then press the button to establish this configuration and deactivate the sound in DIV Games Studio 2. Note: The playback of CD-Audio is independent of the digital sound system which configuration is described here; therefore CD music will continue to be played although the sound system has not been initiated properly.","title":"conflict with the sound system"},{"location":"help/#the-sound-system-is-not-working","text":"Digital sounds cannot be played back inside DIV Games Studio 2 if the sound system is deactivated. Probably, in the configuration program the option was selected, instead of indicating the type of card you have installed on your PC (or one compatible with it). ---See: conflicts with the sound dispositive","title":"The sound system is not working"},{"location":"help/#fixing-a-video-mode","text":"The option System \\ Video mode gives access to the dialogue window which permits you to modify the resolution used by the graphical environment of DIV Games Studio 2. The video resolutions are indicated as the number of horizontal and vertical pixels the video will be displayed in on screen in this mode and will be a value between 320x200 (low resolution) and the max resolution which your video card permits. To select a new resolution you must click on the list which appears in the window over the resolution desired and then select the button Accept . Note: Some of these video modes can be visualised incorrectly (for example, a resolution which is permitted by your video card but not by your monitor); in this case you must wait 15 seconds for the environment to restore the previous resolution. Don't press any key, don't do anything, just be patient and wait. Selection of the system font. There are two settings allowed to select the font used by the system, which not only have differences in the size of the letters but, also in the size of the windows of the environment. They are : 1. Small font (and small windows). In this mode all windows, menus and pictures are seen in a small size, being ideal for low modes of resolution or a PC with a big monitor (17\" or more). 2. Big font (and big windows). This mode can be activated only in resolutions from 640x480 up and is ideal for small monitors (15\" or less). Note: The font of letters used in the programs and in the help window is independent from that selected for the system, and is defined in the configuration window, also accessible from this system menu. ---See: The window of configuration - Introduction to DIV 2","title":"Fixing a video mode"},{"location":"help/#the-configuration-window","text":"With help of the option System\\Configuration you can access the following dialogue window divided into sections, which are outlined below. Colours windows This first section establishes the colours used by the environment; the colours for background of the windows, the colour of letters / fonts and the colour of the title bar can be selected. To change these colours click on the boxes. The system not only uses these three colour windows but, starting from them, generates a gamma array of colours used for texts, cursors, buttons, etc. Programs Editor This establishes the appearance of the program windows. Different colours for different objects (words or symbols) presented in the program can be selected. 1. Background of the edition window. 2. General colour of letters. 3. Cursor. 4. Commentaries of the programs. 5. Symbols and operators of expressions. 6. Reserved words of the language. 7. Numbers inside the program. 8. Literals, or texts in inverted commas. The text blocks marked inside the editor are seen with the interchanged colours of paint and background. A text box allows you to define the size (n number of spaces) of the tabulator in the programs editor, as a number between 1 and 16. By default the program tabulates every 4 columns. It is also possible to select here the size of the letters of the programs and the help, from 6x8 up to 9x16 points. All fonts of letters are fixed for a particular setup. **Painting Program ** Defines the quantity of memory reserved to carry out operations in the graphics editor, the speed of the mouse pointer and its representation. The quantity of \"memory\" is specified in Kbytes, and by default is set at 1088Kb (more than one megabyte), but it is not necessary to modify this value even if an operation can't be realised in the graphical editor because of not enough memory available (in this case the program will divert more memory to it). Please note though, that the more memory reserved for graphics, the less memory will be disposed in the system for the rest of the actions. The speed of the mouse pointer is defined with the small horizontal bar (faster to the left and slower to the right), and affects the mouse in all window environments, not only the painting program. Global options of the environment 1. Emergent windows. Indicate all windows effects to be visualised, when they are opening, closing, minimising, etc. If this option is deactivated, the environment will lose these effects but will gain a faster response speed. 2. Move complete windows. With this option enabled, windows will show their complete content whilst being dragged, otherwise only the outline will be shown. It can be useful to deactivate this option on slower PCs. 3. Always save session. Means that when exiting from DIV Games Studio, the contents of the desktop and all its objects (programs, maps, sounds,etc.) must be saved. If this option is deactivated then entering and exiting from the environment will be faster, but there is a risk of losing the work which was not saved prior to exiting from DIV. 4. Colour of the lists. Indicates that, when a file with the extension PRG is being edited, all colours previously selected for the editor must be applied. Alternatively only the colours of the background and cursor will be applied. The same applies when you are editing a file which is not a PRG div source program file. Note: If you close the configuration window or press the key ESC all changes you have just made will be lost, and the values of the previous configuration will be restored. ---See: First contact with the language - Introduction to DIV 2","title":"The configuration window"},{"location":"help/#first-contact-with-the-language","text":"In this section it is explained how to execute the Sample games of DIV Games Studio and quick instructions how to start learning about DIV, receiving the first notions about this programming language. General instructions All included games are simple examples, they don't pretend to compete with the commercial games which can be created with this tool. Although we're talking about complete games, the majority of them are very simple or very short. The aim was to demonstrate the techniques which are used and how the programs are made, by use of examples, instead of huge lists of instructions in which the user gets easily confused. Note: These games can never show the true capabilities of this environment, because practically no single game uses all of them. The majority of the new and potential capabilities of this version of DIV Games Studio weren't used in these example, giving you the opportunity to be the first persons who attempt, or maybe manage, to explore these possibilities to the full. To execute any of these examples you must, first, load the program with the option Programs\\Open program , and then a window will appear with a list of the loaded programs. The help system One of the best ways of learning the DIV environment; after placing the cursor on a reserved word, constant, variable, function, etc., of the language you can press the key F1 to see a help page about this subject. If, after pressing F1, help about the subject doesn't appear (but instead the general index appears) it is because this is not a specific word of the DIV language, and the data or process is not directly from the game language (processes are functions which control the behaviour of the graphics, or 'sprites', in the games). Note: We recommend you begin by learning with simple games, as tutorials or, better still, with the examples included in the electronic help; to access them you must press the Functions button in the help window and, from this page, access the different explanations of the functions of the programming language, from where small examples can be viewed by pressing on their headline or title. Texts which begin with the symbol // (double bar) are explanation comments, they don't form part of the program, but only consist of \"explanatory notes\" about the internal functioning of the program. These comments are often a big help in understanding the functioning of the programs. The comments can also appear between the symbols / and / (covering many lines of the program). To go to one of the program processes (one of the program blocks used to control a graphic or sprite of the game), you must press the F5 key and select the name of the process with the help of the mouse. Execution of the examples To execute one of the loaded programs, press with the mouse on its window and then with the key F10 (this action can also be instigated with the option programs \\ execute). The contents of the games are different, but the majority of them allow you to exit by pressing the ESC key and are managed with the cursor and control keys (See the general commands in the games ). The Pause key can be used in all games to immediately stop the execution of the program. All programs can be aborted at any point, independent of their programming, if the combination of keys ALT+X is pressed. ---See: Debugging your program - Introduction to DIV 2","title":"First contact with the language"},{"location":"help/#monitoring-or-debugging-the-programs","text":"The more active people can find out more detail about the progress of the games during runtime by pressing the key F12 (from the game itself, during its execution), that allows you to access the program debugger, which permits you to execute the games step by step. Here you can observe all processes and modify their data (if you have convenient data, all dynamic parameters of the game can be changed, the phase number, the lives left, ammunition left ...). In the upper part of this window there appears a list with the processes currently active at any moment (such as toys or graphics which are being used by program). They can be selected with the mouse and, by pressing the button see data , all variables, counters, etc. which the process is using will be seen. In the lower part of the screen appears the lists of the program, which basically are the order in which the PC must action things whilst the game is running. It is normally divided into small blocks which begin with the word PROCESS (one of the reserved words of the programming language). In each one of these blocks the orders for a main element of the game are specified (for example, for a shot being fired, an enemy or an explosion). General functioning of the programs In short, the games always consist of a sequence of frames. Each frame is composed of different elements (or processes)of the game. All these elements must, in each frame, complete a series of operations or calculations (normally very simple) to determine what their appearance must be in the following frame (which picture or graphics the frame must show, in which position, of which size, which orientation etc.) The PC is realising the orders specified for each process until it comes to the orders for the FRAME (frame or fotogram) itself. This order indicates that a process is already prepared to be shown in the following frame, which means, all the parameters which will define its appearance in the following frame have already been allocated. Note: The orders specified in a program are denoted as statements. Each one of these statements indicates an operation or calculations which the PC must realise. In this way, the PC continues realising all these operations and calculations which the orders of each process have specified, until all active processes have reached the order statement FRAME . At this moment, the PC stops executing orders and will focus instead on composing the following frame which must be displayed on screen. In the games these two tasks are consistently alternating, first the orders are executed, and then the frames are composed and displayed. Basic controls of the debugger This can be viewed from the program debugger, with the help of different buttons which allow the actions of the program or game to be realised step by step, visibly on screen. These main buttons are the following: 1. Step. Indicates to the PC to execute the following order of the next process. The next process appears in white in the most prominent list of the debugger, and the following order to be realised (by this process) appears in the program list in the same colour. 2. Exec.process. This button instructs the PC to execute all instructions of the following process until it reaches the order FRAME, this means, it must realise all necessary operations required before the next process can be displayed in the next frame. 3. Foll.Frame. This button is used to advance the game frame by frame. Each time it is pressed, all necessary orders of all active processes will be executed, the new frame will be composed, and finally the frame will be converted to video (the term \"convert to video\" means that the action of one frame of the is composed in the video / graphics card, and thus will be displayed on the monitor of the PC). When a program is realised, all its aspects can be controlled: the order in which the different processes are executed, the order in which the graphics are displayed on screen, the interactions of the processes on screen (when they \"are touching\" one another, for instance), when sound effects must be played, the reactions of each process on the keyboard, mouse, etc ... ---See: Introduction to DIV 2","title":"Monitoring or debugging the programs"},{"location":"help/#the-last-possible-term-inside-this-hypertext","text":"","title":"The last possible term inside this hypertext"},{"location":"host/","text":"Host Your Own HippieDB Server \ud83c\udf08\ud83c\udf0d Hey, tech-savvy hippie! \ud83c\udf1f Want to spread the love by hosting your own HippieDB server? That\u2019s far out! By running your own server, you can create a new node in the HippieDB network and share it with the community. Let\u2019s get groovy and walk through the steps, man. Why Host Your Own Server? \ud83d\udee0\ufe0f Expand the Network : More servers mean more space for everyone to share their data. Customize Your Vibe : You can set up your server however you like, man. Make it your own! Help the Community : By hosting a server, you\u2019re contributing to the growth of the HippieDB ecosystem. Peace and love, baby! Step 1: Set Up Your Server \ud83c\udf31 First, you\u2019ll need to get the HippieDB server software running. Here\u2019s how: Download the Software : Grab the latest version of the HippieDB server from the official repository. If you\u2019re a coder, you can even build it from source. Far out! Run the Server : Fire up your server with a simple command. For example: java -jar hippiedb-1.1.1.jar 1970 This starts your server on port 1970 (or whatever port you dig). Test It Locally : Use a client (like the Python or Node.js examples ) to connect to your server and make sure it\u2019s working. Try setting and getting some keys to test the vibes. Step 2: Register Your Server on the Main HippieDB \ud83c\udf10 Once your server is up and running, it\u2019s time to let the world know about it! You can register your server on the main HippieDB by adding a key with your server\u2019s details. Choose a Key Name : Pick a unique key name for your server, like server.groovyhippie . Set the Key Value : The value should include your server\u2019s host and port. For example: set server.groovyhippie my.hippie.host:9669 OK Share the Love : Now, anyone on the main HippieDB can find your server by looking up your key: get server.groovyhippie my.hippie.host:9669 Step 3: Spread the Word \ud83c\udf1f Now that your server is registered, let the community know about it! Here\u2019s how: Announce It : Use a shared key like community.announcements to tell everyone about your new server: set community.announcements hey everyone, check out my new server at my.hippie.host:1970! peace and love! OK Invite Collaborators : Encourage others to connect to your server and start using it. The more, the merrier! Step 4: Keep Your Server Groovy \ud83c\udfb8 Running a server is a big responsibility, man. Here are some tips to keep it running smoothly: Monitor Performance : Keep an eye on your server\u2019s performance to make sure it\u2019s handling the load. If it gets too busy, you might need to scale up. Back Up Your Data : Regularly back up your server\u2019s data to avoid losing anything important. Peace of mind, man. Stay Connected : Keep your server connected to the main HippieDB network so others can find it. If you need to take it down for maintenance, let the community know first. Step 5: Be a Good Host \ud83c\udf3f Hosting a server is all about sharing the love. Here\u2019s how to be a great host: Be Responsive : If someone has questions or issues, help them out. Good vibes only, man. Encourage Collaboration : Use your server to host community projects, like collaborative art or storytelling. The more creativity, the better! Respect the Community : Follow the same guidelines as everyone else. Be kind, clean up after yourself, and keep the vibes positive. Final Thought: You\u2019re a HippieDB Hero \ud83c\udf08\u2728 By hosting your own server, you\u2019re helping to grow the HippieDB network and create a more connected, collaborative world. That\u2019s some next-level hippie stuff, man. So go forth, share your server, and keep spreading the love! Peace, love, and data forever. \u270c\ufe0f\ud83c\udf0d \ud83c\udf1f\ud83c\udfb6","title":"Hosting"},{"location":"host/#host-your-own-hippiedb-server","text":"Hey, tech-savvy hippie! \ud83c\udf1f Want to spread the love by hosting your own HippieDB server? That\u2019s far out! By running your own server, you can create a new node in the HippieDB network and share it with the community. Let\u2019s get groovy and walk through the steps, man.","title":"Host Your Own HippieDB Server \ud83c\udf08\ud83c\udf0d"},{"location":"host/#why-host-your-own-server","text":"Expand the Network : More servers mean more space for everyone to share their data. Customize Your Vibe : You can set up your server however you like, man. Make it your own! Help the Community : By hosting a server, you\u2019re contributing to the growth of the HippieDB ecosystem. Peace and love, baby!","title":"Why Host Your Own Server? \ud83d\udee0\ufe0f"},{"location":"host/#step-1-set-up-your-server","text":"First, you\u2019ll need to get the HippieDB server software running. Here\u2019s how: Download the Software : Grab the latest version of the HippieDB server from the official repository. If you\u2019re a coder, you can even build it from source. Far out! Run the Server : Fire up your server with a simple command. For example: java -jar hippiedb-1.1.1.jar 1970 This starts your server on port 1970 (or whatever port you dig). Test It Locally : Use a client (like the Python or Node.js examples ) to connect to your server and make sure it\u2019s working. Try setting and getting some keys to test the vibes.","title":"Step 1: Set Up Your Server \ud83c\udf31"},{"location":"host/#step-2-register-your-server-on-the-main-hippiedb","text":"Once your server is up and running, it\u2019s time to let the world know about it! You can register your server on the main HippieDB by adding a key with your server\u2019s details. Choose a Key Name : Pick a unique key name for your server, like server.groovyhippie . Set the Key Value : The value should include your server\u2019s host and port. For example: set server.groovyhippie my.hippie.host:9669 OK Share the Love : Now, anyone on the main HippieDB can find your server by looking up your key: get server.groovyhippie my.hippie.host:9669","title":"Step 2: Register Your Server on the Main HippieDB \ud83c\udf10"},{"location":"host/#step-3-spread-the-word","text":"Now that your server is registered, let the community know about it! Here\u2019s how: Announce It : Use a shared key like community.announcements to tell everyone about your new server: set community.announcements hey everyone, check out my new server at my.hippie.host:1970! peace and love! OK Invite Collaborators : Encourage others to connect to your server and start using it. The more, the merrier!","title":"Step 3: Spread the Word \ud83c\udf1f"},{"location":"host/#step-4-keep-your-server-groovy","text":"Running a server is a big responsibility, man. Here are some tips to keep it running smoothly: Monitor Performance : Keep an eye on your server\u2019s performance to make sure it\u2019s handling the load. If it gets too busy, you might need to scale up. Back Up Your Data : Regularly back up your server\u2019s data to avoid losing anything important. Peace of mind, man. Stay Connected : Keep your server connected to the main HippieDB network so others can find it. If you need to take it down for maintenance, let the community know first.","title":"Step 4: Keep Your Server Groovy \ud83c\udfb8"},{"location":"host/#step-5-be-a-good-host","text":"Hosting a server is all about sharing the love. Here\u2019s how to be a great host: Be Responsive : If someone has questions or issues, help them out. Good vibes only, man. Encourage Collaboration : Use your server to host community projects, like collaborative art or storytelling. The more creativity, the better! Respect the Community : Follow the same guidelines as everyone else. Be kind, clean up after yourself, and keep the vibes positive.","title":"Step 5: Be a Good Host \ud83c\udf3f"},{"location":"host/#final-thought-youre-a-hippiedb-hero","text":"By hosting your own server, you\u2019re helping to grow the HippieDB network and create a more connected, collaborative world. That\u2019s some next-level hippie stuff, man. So go forth, share your server, and keep spreading the love! Peace, love, and data forever. \u270c\ufe0f\ud83c\udf0d \ud83c\udf1f\ud83c\udfb6","title":"Final Thought: You\u2019re a HippieDB Hero \ud83c\udf08\u2728"},{"location":"namespace/","text":"Namespaces in HippieDB \ud83c\udf08\u270c\ufe0f Welcome to the land of peace, love, and namespaces! In HippieDB, namespaces are like your own little patch of grass in the communal database garden. They help you avoid stepping on anyone else\u2019s flowers (or data) and let you grow your own groovy stuff without hassle. Why Namespaces Are Far Out, Man \ud83c\udf3b Avoid Bad Vibes : Namespaces keep your keys chill and separate from others, so no one accidentally messes with your mojo. Stay Organized, Man : They help you keep your data as tidy as a tie-dye shirt collection. Share the Love : Namespaces let everyone coexist in harmony, like a big, happy database commune. Reserving Your Groovy Namespace \ud83d\udd4a\ufe0f First, check if your dream namespace is free, man: get namespace_garden If it\u2019s wide open, claim it with good vibes: set namespace_garden reserved by hiperbou OK Now you can start planting your data seeds in your namespace garden: set garden.myVar 1 OK get garden.myVar 1 What If Someone Else is Hogging the Namespace? \ud83c\udf3f If your desired namespace is already taken, don\u2019t freak out, man! You can either pick another groovy name or ask the current reserver to share the love. Sending a Peaceful Request \u270c\ufe0f If the namespace is already claimed, send a friendly request to the current reserver: get namespace_garden reserved by hiperbou set namespace_garden_request hey, can I borrow this namespace? I promise to water the data plants! OK The current reserver will see your request: get namespace_garden_request hey, can I borrow this namespace? I promise to water the data plants! They might ask you a question, like, who even are you, man? set namespace_garden_request what\u2019s your vibe, friend? OK You can reply with your groovy identity: set namespace_garden_request just a fellow data hippie, dblover42 at your service! OK Transferring the Namespace \ud83c\udf08 If the current reserver is feeling generous, they can pass the namespace torch to you: set namespace_garden reserved by dblover42 OK They might even leave you a little note of encouragement: set namespace_garden_request here you go, friend! may your data bloom like wildflowers! OK Don\u2019t forget to spread the gratitude, man: get namespace_garden_request here you go, friend! may your data bloom like wildflowers! set namespace_garden_request thanks a million, peace and love to you! OK Checking the Namespace Vibes \ud83c\udf38 You can always check the status of a namespace to see who\u2019s tending to it: get namespace_garden reserved by dblover42 Groovy Tips for Namespace Harmony \ud83c\udfb6 Pick a Unique Name : Choose something as unique as your spirit animal. Be Cool : When asking for a namespace, always come in peace and love. Keep It Tidy : Use your namespace consistently to keep the database garden blooming. \ud83c\udf08\u2728","title":"Namespaces"},{"location":"namespace/#namespaces-in-hippiedb","text":"Welcome to the land of peace, love, and namespaces! In HippieDB, namespaces are like your own little patch of grass in the communal database garden. They help you avoid stepping on anyone else\u2019s flowers (or data) and let you grow your own groovy stuff without hassle.","title":"Namespaces in HippieDB \ud83c\udf08\u270c\ufe0f"},{"location":"namespace/#why-namespaces-are-far-out-man","text":"Avoid Bad Vibes : Namespaces keep your keys chill and separate from others, so no one accidentally messes with your mojo. Stay Organized, Man : They help you keep your data as tidy as a tie-dye shirt collection. Share the Love : Namespaces let everyone coexist in harmony, like a big, happy database commune.","title":"Why Namespaces Are Far Out, Man \ud83c\udf3b"},{"location":"namespace/#reserving-your-groovy-namespace","text":"First, check if your dream namespace is free, man: get namespace_garden If it\u2019s wide open, claim it with good vibes: set namespace_garden reserved by hiperbou OK Now you can start planting your data seeds in your namespace garden: set garden.myVar 1 OK get garden.myVar 1","title":"Reserving Your Groovy Namespace \ud83d\udd4a\ufe0f"},{"location":"namespace/#what-if-someone-else-is-hogging-the-namespace","text":"If your desired namespace is already taken, don\u2019t freak out, man! You can either pick another groovy name or ask the current reserver to share the love.","title":"What If Someone Else is Hogging the Namespace? \ud83c\udf3f"},{"location":"namespace/#sending-a-peaceful-request","text":"If the namespace is already claimed, send a friendly request to the current reserver: get namespace_garden reserved by hiperbou set namespace_garden_request hey, can I borrow this namespace? I promise to water the data plants! OK The current reserver will see your request: get namespace_garden_request hey, can I borrow this namespace? I promise to water the data plants! They might ask you a question, like, who even are you, man? set namespace_garden_request what\u2019s your vibe, friend? OK You can reply with your groovy identity: set namespace_garden_request just a fellow data hippie, dblover42 at your service! OK","title":"Sending a Peaceful Request \u270c\ufe0f"},{"location":"namespace/#transferring-the-namespace","text":"If the current reserver is feeling generous, they can pass the namespace torch to you: set namespace_garden reserved by dblover42 OK They might even leave you a little note of encouragement: set namespace_garden_request here you go, friend! may your data bloom like wildflowers! OK Don\u2019t forget to spread the gratitude, man: get namespace_garden_request here you go, friend! may your data bloom like wildflowers! set namespace_garden_request thanks a million, peace and love to you! OK","title":"Transferring the Namespace \ud83c\udf08"},{"location":"namespace/#checking-the-namespace-vibes","text":"You can always check the status of a namespace to see who\u2019s tending to it: get namespace_garden reserved by dblover42","title":"Checking the Namespace Vibes \ud83c\udf38"},{"location":"namespace/#groovy-tips-for-namespace-harmony","text":"Pick a Unique Name : Choose something as unique as your spirit animal. Be Cool : When asking for a namespace, always come in peace and love. Keep It Tidy : Use your namespace consistently to keep the database garden blooming. \ud83c\udf08\u2728","title":"Groovy Tips for Namespace Harmony \ud83c\udfb6"}]}